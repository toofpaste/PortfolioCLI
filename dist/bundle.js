/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzPzFmYjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/base64-js/index.js\n");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzP2I2MzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLG9EQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxnREFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsZ0RBQVM7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/buffer/index.js\n");

/***/ }),

/***/ "./node_modules/clone/clone.js":
/*!*************************************!*\
  !*** ./node_modules/clone/clone.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var clone = (function() {\n'use strict';\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\nfunction clone(parent, circular, depth, prototype) {\n  var filter;\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    filter = circular.filter;\n    circular = circular.circular\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth == 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      if (Buffer.allocUnsafe) {\n        // Node.js >= 4.5.0\n        child = Buffer.allocUnsafe(parent.length);\n      } else {\n        // Older Node.js versions\n        child = new Buffer(parent.length);\n      }\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n};\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n};\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n};\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n};\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n};\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif ( true && module.exports) {\n  module.exports = clone;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xvbmUvY2xvbmUuanM/MjQxMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELElBQUksS0FBMEI7QUFDOUI7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jbG9uZS9jbG9uZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBjbG9uZSA9IChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDbG9uZXMgKGNvcGllcykgYW4gT2JqZWN0IHVzaW5nIGRlZXAgY29weWluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHN1cHBvcnRzIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgZGVmYXVsdCwgYnV0IGlmIHlvdSBhcmUgY2VydGFpblxuICogdGhlcmUgYXJlIG5vIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4geW91ciBvYmplY3QsIHlvdSBjYW4gc2F2ZSBzb21lIENQVSB0aW1lXG4gKiBieSBjYWxsaW5nIGNsb25lKG9iaiwgZmFsc2UpLlxuICpcbiAqIENhdXRpb246IGlmIGBjaXJjdWxhcmAgaXMgZmFsc2UgYW5kIGBwYXJlbnRgIGNvbnRhaW5zIGNpcmN1bGFyIHJlZmVyZW5jZXMsXG4gKiB5b3VyIHByb2dyYW0gbWF5IGVudGVyIGFuIGluZmluaXRlIGxvb3AgYW5kIGNyYXNoLlxuICpcbiAqIEBwYXJhbSBgcGFyZW50YCAtIHRoZSBvYmplY3QgdG8gYmUgY2xvbmVkXG4gKiBAcGFyYW0gYGNpcmN1bGFyYCAtIHNldCB0byB0cnVlIGlmIHRoZSBvYmplY3QgdG8gYmUgY2xvbmVkIG1heSBjb250YWluXG4gKiAgICBjaXJjdWxhciByZWZlcmVuY2VzLiAob3B0aW9uYWwgLSB0cnVlIGJ5IGRlZmF1bHQpXG4gKiBAcGFyYW0gYGRlcHRoYCAtIHNldCB0byBhIG51bWJlciBpZiB0aGUgb2JqZWN0IGlzIG9ubHkgdG8gYmUgY2xvbmVkIHRvXG4gKiAgICBhIHBhcnRpY3VsYXIgZGVwdGguIChvcHRpb25hbCAtIGRlZmF1bHRzIHRvIEluZmluaXR5KVxuICogQHBhcmFtIGBwcm90b3R5cGVgIC0gc2V0cyB0aGUgcHJvdG90eXBlIHRvIGJlIHVzZWQgd2hlbiBjbG9uaW5nIGFuIG9iamVjdC5cbiAqICAgIChvcHRpb25hbCAtIGRlZmF1bHRzIHRvIHBhcmVudCBwcm90b3R5cGUpLlxuKi9cbmZ1bmN0aW9uIGNsb25lKHBhcmVudCwgY2lyY3VsYXIsIGRlcHRoLCBwcm90b3R5cGUpIHtcbiAgdmFyIGZpbHRlcjtcbiAgaWYgKHR5cGVvZiBjaXJjdWxhciA9PT0gJ29iamVjdCcpIHtcbiAgICBkZXB0aCA9IGNpcmN1bGFyLmRlcHRoO1xuICAgIHByb3RvdHlwZSA9IGNpcmN1bGFyLnByb3RvdHlwZTtcbiAgICBmaWx0ZXIgPSBjaXJjdWxhci5maWx0ZXI7XG4gICAgY2lyY3VsYXIgPSBjaXJjdWxhci5jaXJjdWxhclxuICB9XG4gIC8vIG1haW50YWluIHR3byBhcnJheXMgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHdoZXJlIGNvcnJlc3BvbmRpbmcgcGFyZW50c1xuICAvLyBhbmQgY2hpbGRyZW4gaGF2ZSB0aGUgc2FtZSBpbmRleFxuICB2YXIgYWxsUGFyZW50cyA9IFtdO1xuICB2YXIgYWxsQ2hpbGRyZW4gPSBbXTtcblxuICB2YXIgdXNlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPSAndW5kZWZpbmVkJztcblxuICBpZiAodHlwZW9mIGNpcmN1bGFyID09ICd1bmRlZmluZWQnKVxuICAgIGNpcmN1bGFyID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGRlcHRoID09ICd1bmRlZmluZWQnKVxuICAgIGRlcHRoID0gSW5maW5pdHk7XG5cbiAgLy8gcmVjdXJzZSB0aGlzIGZ1bmN0aW9uIHNvIHdlIGRvbid0IHJlc2V0IGFsbFBhcmVudHMgYW5kIGFsbENoaWxkcmVuXG4gIGZ1bmN0aW9uIF9jbG9uZShwYXJlbnQsIGRlcHRoKSB7XG4gICAgLy8gY2xvbmluZyBudWxsIGFsd2F5cyByZXR1cm5zIG51bGxcbiAgICBpZiAocGFyZW50ID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgIHJldHVybiBwYXJlbnQ7XG5cbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIHByb3RvO1xuICAgIGlmICh0eXBlb2YgcGFyZW50ICE9ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGlmIChjbG9uZS5fX2lzQXJyYXkocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBbXTtcbiAgICB9IGVsc2UgaWYgKGNsb25lLl9faXNSZWdFeHAocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBuZXcgUmVnRXhwKHBhcmVudC5zb3VyY2UsIF9fZ2V0UmVnRXhwRmxhZ3MocGFyZW50KSk7XG4gICAgICBpZiAocGFyZW50Lmxhc3RJbmRleCkgY2hpbGQubGFzdEluZGV4ID0gcGFyZW50Lmxhc3RJbmRleDtcbiAgICB9IGVsc2UgaWYgKGNsb25lLl9faXNEYXRlKHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IERhdGUocGFyZW50LmdldFRpbWUoKSk7XG4gICAgfSBlbHNlIGlmICh1c2VCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKHBhcmVudCkpIHtcbiAgICAgIGlmIChCdWZmZXIuYWxsb2NVbnNhZmUpIHtcbiAgICAgICAgLy8gTm9kZS5qcyA+PSA0LjUuMFxuICAgICAgICBjaGlsZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShwYXJlbnQubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9sZGVyIE5vZGUuanMgdmVyc2lvbnNcbiAgICAgICAgY2hpbGQgPSBuZXcgQnVmZmVyKHBhcmVudC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgcGFyZW50LmNvcHkoY2hpbGQpO1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHByb3RvdHlwZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwYXJlbnQpO1xuICAgICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocHJvdG8pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgICBwcm90byA9IHByb3RvdHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2lyY3VsYXIpIHtcbiAgICAgIHZhciBpbmRleCA9IGFsbFBhcmVudHMuaW5kZXhPZihwYXJlbnQpO1xuXG4gICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGFsbENoaWxkcmVuW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGFsbFBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgYWxsQ2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSBpbiBwYXJlbnQpIHtcbiAgICAgIHZhciBhdHRycztcbiAgICAgIGlmIChwcm90bykge1xuICAgICAgICBhdHRycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cnMgJiYgYXR0cnMuc2V0ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjaGlsZFtpXSA9IF9jbG9uZShwYXJlbnRbaV0sIGRlcHRoIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIF9jbG9uZShwYXJlbnQsIGRlcHRoKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgZmxhdCBjbG9uZSB1c2luZyBwcm90b3R5cGUsIGFjY2VwdHMgb25seSBvYmplY3RzLCB1c2VmdWxsIGZvciBwcm9wZXJ0eVxuICogb3ZlcnJpZGUgb24gRkxBVCBjb25maWd1cmF0aW9uIG9iamVjdCAobm8gbmVzdGVkIHByb3BzKS5cbiAqXG4gKiBVU0UgV0lUSCBDQVVUSU9OISBUaGlzIG1heSBub3QgYmVoYXZlIGFzIHlvdSB3aXNoIGlmIHlvdSBkbyBub3Qga25vdyBob3cgdGhpc1xuICogd29ya3MuXG4gKi9cbmNsb25lLmNsb25lUHJvdG90eXBlID0gZnVuY3Rpb24gY2xvbmVQcm90b3R5cGUocGFyZW50KSB7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgYy5wcm90b3R5cGUgPSBwYXJlbnQ7XG4gIHJldHVybiBuZXcgYygpO1xufTtcblxuLy8gcHJpdmF0ZSB1dGlsaXR5IGZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBfX29ialRvU3RyKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn07XG5jbG9uZS5fX29ialRvU3RyID0gX19vYmpUb1N0cjtcblxuZnVuY3Rpb24gX19pc0RhdGUobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5jbG9uZS5fX2lzRGF0ZSA9IF9faXNEYXRlO1xuXG5mdW5jdGlvbiBfX2lzQXJyYXkobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuY2xvbmUuX19pc0FycmF5ID0gX19pc0FycmF5O1xuXG5mdW5jdGlvbiBfX2lzUmVnRXhwKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBSZWdFeHBdJztcbn07XG5jbG9uZS5fX2lzUmVnRXhwID0gX19pc1JlZ0V4cDtcblxuZnVuY3Rpb24gX19nZXRSZWdFeHBGbGFncyhyZSkge1xuICB2YXIgZmxhZ3MgPSAnJztcbiAgaWYgKHJlLmdsb2JhbCkgZmxhZ3MgKz0gJ2cnO1xuICBpZiAocmUuaWdub3JlQ2FzZSkgZmxhZ3MgKz0gJ2knO1xuICBpZiAocmUubXVsdGlsaW5lKSBmbGFncyArPSAnbSc7XG4gIHJldHVybiBmbGFncztcbn07XG5jbG9uZS5fX2dldFJlZ0V4cEZsYWdzID0gX19nZXRSZWdFeHBGbGFncztcblxucmV0dXJuIGNsb25lO1xufSkoKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/clone/clone.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/jquery.terminal/css/jquery.terminal.min.css":
/*!********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/jquery.terminal/css/jquery.terminal.min.css ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"/*!\\n *       __ _____                     ________                              __\\n *      / // _  /__ __ _____ ___ __ _/__  ___/__ ___ ______ __ __  __ ___  / /\\n *  __ / // // // // // _  // _// // / / // _  // _//     // //  \\\\/ // _ \\\\/ /\\n * /  / // // // // // ___// / / // / / // ___// / / / / // // /\\\\  // // / /__\\n * \\\\___//____ \\\\\\\\___//____//_/ _\\\\_  / /_//____//_/ /_/ /_//_//_/ /_/ \\\\__\\\\_\\\\___/\\n *           \\\\/              /____/                              version 2.12.0\\n * http://terminal.jcubic.pl\\n *\\n * This file is part of jQuery Terminal.\\n *\\n * Copyright (c) 2011-2019 Jakub Jankiewicz <https://jcubic.pl/me>\\n * Released under the MIT license\\n *\\n * Date: Wed, 01 Jan 2020 17:03:16 +0000\\n */.cmd-prompt,.cmd-prompt div,.cmd .format,.terminal .terminal-output .format{display:inline-block}.cmd,.terminal h1,.terminal h2,.terminal h3,.terminal h4,.terminal h5,.terminal h6,.terminal pre{margin:0}.cmd .cmd-clipboard{position:absolute;left:-16px;top:0;width:16px;height:16px;background-color:transparent;border:none;color:transparent;outline:none;padding:0;resize:none;z-index:1000;overflow:hidden;white-space:pre;text-indent:-9999em;top:calc(var(--cursor-line, 0)*1em)}.cmd .cursor+span:empty,.cmd div.cmd-end-line span[data-text]:last-child,.cmd div.cmd-end-line span[data-text]:last-child span,.cmd span.cmd-end-line,.cmd span.cmd-end-line span{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.terminal audio,.terminal canvas,.terminal img,.terminal object{cursor:default}.terminal{position:relative;overflow-y:auto}terminal.terminal-temp{visibility:hidden}.terminal{contain:content}body.terminal{min-height:100vh;height:100%}html{height:100%}body.full-screen-terminal,body.terminal{margin:0;height:100%}body.full-screen-terminal .terminal{height:100%}.terminal>div.terminal-fill{min-height:100%;height:100%}.terminal>.terminal-font .terminal-resizer,.terminal>.terminal-resizer{position:absolute;top:0;right:0;bottom:0;left:0;overflow:hidden;pointer-events:none;z-index:-1;height:100%;border:none;padding:0;width:100%}.cmd{padding:0;position:relative;width:100%}.terminal a[tabindex=\\\"1000\\\"],.terminal a[tabindex=\\\"1000\\\"]:active,.terminal a[tabindex=\\\"1000\\\"]:focus{outline:none}.cmd .cmd-inverted,.cmd .inverted,.terminal .inverted,.terminal .terminal-inverted{background-color:#aaa;color:#000}.cmd a[href] span,.terminal .terminal-output>:not(.raw) a[href] span{color:#0f60ff!important;--color:var(--link-color,#0f60ff);color:var(--link-color,#0f60ff)!important;text-decoration:underline}.cmd a[href]:hover span,.terminal .terminal-output>:not(.raw) a[href]:hover span{background-color:#0f60ff!important;background-color:var(--link-color,#0f60ff)!important;color:var(--background,#000)!important;text-decoration:none}.cmd .cmd-cursor{vertical-align:top}.cmd .cmd-cursor,.cmd .cmd-cursor-line>span,.cmd .cmd-cursor-line img{display:inline-block}.cmd-wrapper div [data-text]{vertical-align:top}.cmd .cmd-cursor.cmd-blink span:not(.emoji) span,.cmd .cmd-cursor .emoji{-webkit-animation:terminal-blink 1s linear infinite;-moz-animation:terminal-blink 1s infinite linear;-ms-animation:terminal-blink 1s infinite linear;animation:terminal-blink 1s linear infinite}.bar.cmd .cmd-inverted,.bar.terminal .inverted{box-shadow:-2px 0 0 -1px #aaa;box-shadow:-2px 0 0 -1px var(--original-color,#aaa)}.cmd .cmd-prompt,.terminal .terminal .terminal-output>div>div{display:block;height:auto}.cmd div,.terminal .terminal-output>div>div{min-height:14px;min-height:calc(var(--size, 1)*14px)}.terminal .terminal-output>div:not(.raw) div{white-space:nowrap}.cmd .cmd-prompt>span{float:left}.cmd span[style*=width],.terminal span[style*=width]{display:inline-block}.cmd,.cmd div,.cmd span,.terminal,.terminal-output>:not(.raw) a,.terminal-output>:not(.raw) div,.terminal-output>:not(.raw) span{font-family:monospace;font-size:12px;line-height:15px}.cmd span:not(.cmd-inverted):not(.token):not(.emoji),.terminal-output>:not(.raw) span:not(.token):not(.inverted):not(.terminal-inverted):not(.cmd-inverted):not(.terminal-error):not(.emoji){color:#aaa;background-color:#000}.cmd .emoji,.terminal-output>:not(.raw) .emoji{height:14px;background-size:contain;background-repeat:no-repeat;color:transparent;position:relative}.cmd .emoji,.cmd .emoji span,.terminal-output>:not(.raw) .emoji,.terminal-output>:not(.raw) .emoji span{display:inline-block;width:2ch}.cmd,.terminal{box-sizing:border-box;cursor:text}.cmd .cmd-cursor span:not(.token):not(.inverted){color:inherit;background-color:inherit}.cmd .emoji.emoji.emoji.emoji,.cmd .emoji.emoji.emoji.emoji span{color:transparent;background-color:transparent}.cmd .cmd-cursor *{background-color:transparent}.cmd div{clear:both}.cmd .cmd-prompt+div{clear:right}.cmd div,.terminal-output>div>div{min-height:15px}terminal .terminal-output>div{margin-top:-1px}.terminal-output>div.raw>div *{overflow-wrap:break-word;word-wrap:break-word}.terminal .terminal-font{position:absolute;float:left;font-size:inherit;line-height:inherit;top:-100%;left:0;margin-bottom:1px}.cmd>span:not(.cmd-prompt){float:left}.cmd .cmd-prompt span.cmd-line{display:block;float:none}.terminal table{border-collapse:collapse}.terminal td{border:1px solid #aaa}.cmd.cmd span[data-text]:not(.emoji) span{background-color:inherit;color:inherit}.cmd [role=presentation].cmd-cursor-line{position:relative;z-index:100}.cmd .cmd-prompt{position:relative;z-index:200}.cmd [role=presentation]:not(.cmd-cursor-line){overflow:hidden}.cmd{--original-color:var(--color,#aaa)}.cmd a[href]{--original-color:var(--link-color,#0f60ff)}@-webkit-keyframes terminal-blink{0%,50%{background-color:#bbb;background-color:var(--original-color,#bbb);color:#000;color:var(--background,#000)}50.1%,to{background-color:inherit;color:inherit}}@-moz-keyframes terminal-blink{0%,50%{background-color:#aaa;background-color:var(--original-color,#aaa);color:#000;color:var(--background,#000)}50.1%,to{background-color:inherit;color:inherit}}@keyframes terminal-blink{0%,50%{background-color:#aaa;background-color:var(--original-color,#aaa);color:#000;color:var(--background,#000)}50.1%,to{background-color:inherit;color:inherit}}@-webkit-keyframes terminal-glow{0%,50%{background-color:#aaa;background-color:var(--original-color,#aaa);color:#000;color:var(--background,#000);box-shadow:0 0 3px #aaa;-webkit-box-shadow:0 0 3px var(--color,#aaa);box-shadow:0 0 3px var(--color,#aaa)}50.1%,to{background-color:inherit;color:inherit;-webkit-box-shadow:none;box-shadow:none}}@-moz-keyframes terminal-glow{0%,50%{background-color:#aaa;background-color:var(--original-color,#aaa);color:#000;color:var(--background,#000);box-shadow:0 0 3px #aaa;-moz-box-shadow:0 0 3px var(--color,#aaa);box-shadow:0 0 3px var(--color,#aaa)}50.1%,to{background-color:inherit;color:inherit;-moz-box-shadow:none;box-shadow:none}}@keyframes terminal-glow{0%,50%{background-color:#aaa;background-color:var(--original-color,#aaa);color:#000;color:var(--background,#000);box-shadow:0 0 3px #aaa;box-shadow:0 0 3px var(--color,#aaa)}50.1%,to{background-color:inherit;color:inherit;box-shadow:none}}@-webkit-keyframes terminal-bar{0%,50%{box-shadow:-2px 0 0 -1px #aaa;box-shadow:-2px 0 0 -1px var(--original-color,#aaa)}50.1%,to{box-shadow:none}}@-moz-keyframes terminal-bar{0%,50%{box-shadow:-2px 0 0 -1px #aaa;box-shadow:-2px 0 0 -1px var(--original-color,#aaa)}50.1%,to{box-shadow:none}}@keyframes terminal-bar{0%,50%{box-shadow:-2px 0 0 -1px #aaa;box-shadow:-2px 0 0 -1px var(--original-color,#aaa)}50.1%,to{box-shadow:none}}@-webkit-keyframes terminal-underline{0%,50%{box-shadow:0 2px 0 #aaa;box-shadow:0 2px 0 var(--original-color,#aaa)}50.1%,to{box-shadow:none}}@-moz-keyframes terminal-underline{0%,50%{box-shadow:0 2px 0 #aaa;box-shadow:0 2px 0 var(--original-color,#aaa)}50.1%,to{box-shadow:none}}@keyframes terminal-underline{0%,50%{box-shadow:0 2px 0 #aaa;box-shadow:0 2px 0 var(--original-color,#aaa)}50.1%,to{box-shadow:none}}.underline-animation .cmd-cursor.cmd-blink a,.underline-animation .cmd-cursor.cmd-blink span span{-webkit-animation-name:terminal-underline;-moz-animation-name:terminal-underline;-ms-animation-name:terminal-underline;animation-name:terminal-underline}.glow-animation .cmd-cursor.cmd-blink a,.glow-animation .cmd-cursor.cmd-blink span span{-webkit-animation-name:terminal-glow;-moz-animation-name:terminal-glow;-ms-animation-name:terminal-glow;animation-name:terminal-glow}.bar-animation .cmd-cursor.cmd-blink a,.bar-animation .cmd-cursor.cmd-blink span span{-webkit-animation-name:terminal-bar;-moz-animation-name:terminal-bar;-ms-animation-name:terminal-bar;animation-name:terminal-bar}@supports (-ms-ime-align:auto){.cmd .cmd-clipboard{margin-left:-9999px}@keyframes terminal-blink{0%,50%{background-color:var(--original-color,#aaa);color:var(--background,#000)}50.1%,to{background-color:var(--background,#000);color:var(--original-color,#aaa)}}@keyframes terminal-bar{0%,50%{border-left-color:var(--color,#aaa)}50.1%,to{border-left-color:var(--background,#000)}}@keyframes terminal-underline{0%,50%{border-bottom-color:var(--color,#aaa);line-height:12px;line-height:calc(var(--size, 1)*12px)}50.1%,to{border-bottom-color:var(--background,#000);line-height:12px;line-height:calc(var(--size, 1)*12px)}}}@media (-ms-high-contrast:active),(-ms-high-contrast:none){.cmd .cmd-clipboard{margin-left:-9999px}.underline-animation .cursor.blink span span{margin-top:1px}@-ms-keyframes terminal-blink{0%,50%{background-color:#aaa;color:#000}50.1%,to{background-color:#000;color:#aaa}}}.cmd .prompt span::-moz-selection,.cmd>div::-moz-selection,.cmd>div span::-moz-selection,.cmd>span::-moz-selection,.cmd>span span::-moz-selection,.cmd div::-moz-selection,.terminal .terminal-output .raw div::-moz-selection,.terminal .terminal-output div div::-moz-selection,.terminal .terminal-output div div a::-moz-selection,.terminal .terminal-output div span::-moz-selection,.terminal h1::-moz-selection,.terminal h2::-moz-selection,.terminal h3::-moz-selection,.terminal h4::-moz-selection,.terminal h5::-moz-selection,.terminal h6::-moz-selection,.terminal pre::-moz-selection,.terminal td::-moz-selection{background-color:#aaa;color:#000}.cmd .prompt span::selection,.cmd>div::selection,.cmd>div span::selection,.cmd>span::selection,.cmd>span span::selection,.cmd div::selection,.terminal .terminal-output .raw div::selection,.terminal .terminal-output::selection,.terminal .terminal-output div div::selection,.terminal .terminal-output div div a::selection,.terminal .terminal-output div span::selection,.terminal h1::selection,.terminal h2::selection,.terminal h3::selection,.terminal h4::selection,.terminal h5::selection,.terminal h6::selection,.terminal pre::selection,.terminal td::selection{background-color:hsla(0,0%,66.7%,.99);color:#000}.terminal .terminal-output>:not(.raw) .terminal-error,.terminal .terminal-output>:not(.raw) .terminal-error *{color:red;color:var(--error-color,red)}.tilda{position:fixed;top:0;left:0;width:100%;z-index:1100}.ui-dialog-content .terminal{width:100%;height:100%;box-sizing:border-box}.ui-dialog .ui-dialog-content.dterm{padding:0}.clear{clear:both}.cmd a[href],.terminal .terminal-output>:not(.raw) a[href]{color:#0f60ff;color:var(--link-color,#0f60ff);cursor:pointer}.cmd a[href]:not(.terminal-inverted),.terminal .terminal-output>:not(.raw) a[href]:not(.terminal-inverted){--color:var(--link-color,#0f60ff)}.terminal .terminal-output>:not(.raw) a[href].terminal-inverted{background:var(--color,#ccc)}.cmd a[href]:hover,.terminal .terminal-output>:not(.raw) a[href]:hover{background-color:#0f60ff;background-color:var(--link-color,#0f60ff);color:var(--background,#000)!important;text-decoration:none}.terminal .terminal-fill{position:absolute;left:0;top:-100%;width:100%;height:100%;margin:1px 0 0;border:none;opacity:.01;pointer-events:none;box-sizing:border-box}.terminal,.terminal .terminal-fill{padding:10px}.terminal{padding-bottom:0}.terminal .cmd{margin-bottom:10px}@supports (--css:variables){.cmd,.cmd div,.cmd span:not(.cmd-inverted):not(.token):not(.emoji),.terminal,.terminal-output>:not(.raw) a,.terminal-output>:not(.raw) div,.terminal-output>:not(.raw) span:not(.token):not(.inverted):not(.terminal-inverted):not(.cmd-inverted):not(.terminal-error):not(.emoji){color:var(--color,#aaa);background-color:var(--background,#000)}.terminal span[style*=\\\"--length\\\"]{width:calc(var(--length, 1)*var(--char-width, 7.23438)*1px);display:inline-block}.cmd,.cmd div,.cmd span,.terminal,.terminal-output>:not(.raw) a,.terminal-output>:not(.raw) div,.terminal-output>:not(.raw) span{font-size:calc(var(--size, 1)*12px);line-height:calc(var(--size, 1)*14px)}.cmd .emoji,.terminal-output>:not(.raw) .emoji{height:calc(var(--size, 1)*14px)}.cmd .clipboard{top:calc(var(--size, 1)*14*var(--cursor-line, 0)*1px)}.cmd .inverted,.terminal .inverted{background-color:var(--color,#aaa);color:var(--background,#000)}.cmd div{min-height:calc(var(--size, 1)*14px)}.cmd .cmd-cursor.cmd-blink{color:var(--color,#aaa);background-color:var(--background,#000)}.cmd .cmd-cursor.cmd-blink .emoji,.cmd .cmd-cursor.cmd-blink a,.cmd .cmd-cursor.cmd-blink span:not(.emoji) span{-webkit-animation:var(--animation,terminal-blink) 1s infinite linear;-moz-animation:var(--animation,terminal-blink) 1s infinite linear;-ms-animation:var(--animation,terminal-blink) 1s infinite linear;animation:var(--animation,terminal-blink) 1s infinite linear}.cmd .cmd-cursor.cmd-blink .emoji span{color:transparent}.cmd .cmd-prompt span::-moz-selection,.cmd>div::-moz-selection,.cmd>div span::-moz-selection,.cmd>span::-moz-selection,.cmd>span span::-moz-selection,.cmd div::-moz-selection,.terminal .terminal-output div div::-moz-selection,.terminal .terminal-output div span::-moz-selection,.terminal h1::-moz-selection,.terminal h2::-moz-selection,.terminal h3::-moz-selection,.terminal h4::-moz-selection,.terminal h5::-moz-selection,.terminal h6::-moz-selection,.terminal pre::-moz-selection,.terminal td::-moz-selection{background-color:var(--color,#aaa);color:var(--background,#000)}.terminal .terminal-output div div a::-moz-selection{background-color:var(--link-color,rgba(15,96,255,.99))!important;color:var(--background,#000)!important}.terminal .terminal-output div div a:hover::-moz-selection{background-color:var(--link-color,rgba(2,50,144,.99))!important}.cmd .cmd-prompt span::selection,.cmd>div::selection,.cmd>div span::selection,.cmd>span::selection,.cmd>span span::selection,.cmd div::selection,.terminal .terminal-output div div::selection,.terminal .terminal-output div span::selection,.terminal h1::selection,.terminal h2::selection,.terminal h3::selection,.terminal h4::selection,.terminal h5::selection,.terminal h6::selection,.terminal pre::selection,.terminal td::selection{background-color:var(--color,hsla(0,0%,66.7%,.99))!important;color:var(--background,#000)!important}.terminal .terminal-output div div a::selection{background-color:var(--link-color,rgba(15,96,255,.99))!important;color:var(--background,#000)!important}.terminal .terminal-output div div a:hover::selection{background-color:var(--link-color,rgba(2,50,144,.99))!important}}@supports (-ms-ime-align:auto){.cmd .prompt span::selection,.cmd>div::selection,.cmd>div span::selection,.cmd>span::selection,.cmd>span span::selection,.cmd div::selection,.terminal .terminal-output div div::selection,.terminal .terminal-output div div a::selection,.terminal .terminal-output div span::selection,.terminal h1::selection,.terminal h2::selection,.terminal h3::selection,.terminal h4::selection,.terminal h5::selection,.terminal h6::selection,.terminal pre::selection,.terminal td::selection{background-color:hsla(0,0%,66.7%,.99);color:#000}}.cmd .style .token.string,.cmd .token.entity,.cmd .token.operator,.cmd .token.string,.cmd .token.token,.cmd .token.url,.cmd .token.variable,.terminal .style .token.string,.terminal .token.entity,.terminal .token.operator,.terminal .token.string,.terminal .token.token,.terminal .token.url,.terminal .token.variable{background-color:inherit}.cmd .cursor-wrapper ul{list-style:none;margin:0;padding:0;float:left;position:absolute;top:14px;left:0}.cmd .cursor-wrapper li{cursor:pointer;white-space:nowrap}.cmd .cursor-wrapper li:hover{background:#aaa;color:#000}.cursor-wrapper{position:relative}.terminal-output div[style*=\\\"100%;\\\"]{overflow:hidden}.terminal-output img{display:block}.cmd img{height:14px;height:calc(var(--size, 1)*14px);border:1px solid transparent}.cmd-cursor img{border-color:#ccc;border-color:var(--color,#ccc)}.terminal-output svg.terminal-broken-image{height:calc(var(--size, 1)*14px)}.terminal-output svg.terminal-broken-image use{fill:var(--color,#ccc)}.terminal-error{--color:var(--error-color)}.terminal-glow{--animation:terminal-glow}.terminal-glow .cmd-prompt>span,.terminal-glow .terminal-output>div a[href],.terminal-glow .terminal-output>div span,.terminal-glow [data-text] span,.terminal-glow a[data-text],.terminal-glow span[data-text]{text-shadow:1px 1px 5px #ccc;text-shadow:1px 1px 5px var(--color,#ccc)}.terminal-scroll-marker{position:relative;height:1px;margin-top:-1px;z-index:100}.terminal-scroll-marker div{position:absolute;bottom:0;left:0;right:0;z-index:200}\", \"\"]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LnRlcm1pbmFsL2Nzcy9qcXVlcnkudGVybWluYWwubWluLmNzcz81OWIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLDJGQUFzQztBQUN6RTtBQUNBLGNBQWMsUUFBUyx1eUJBQXV5QixxQkFBcUIsaUdBQWlHLFNBQVMsb0JBQW9CLGtCQUFrQixXQUFXLE1BQU0sV0FBVyxZQUFZLDZCQUE2QixZQUFZLGtCQUFrQixhQUFhLFVBQVUsWUFBWSxhQUFhLGdCQUFnQixnQkFBZ0Isb0JBQW9CLG9DQUFvQyxrTEFBa0wsMkJBQTJCLHlCQUF5Qix3QkFBd0Isc0JBQXNCLHFCQUFxQixpQkFBaUIsZ0VBQWdFLGVBQWUsVUFBVSxrQkFBa0IsZ0JBQWdCLHVCQUF1QixrQkFBa0IsVUFBVSxnQkFBZ0IsY0FBYyxpQkFBaUIsWUFBWSxLQUFLLFlBQVksd0NBQXdDLFNBQVMsWUFBWSxvQ0FBb0MsWUFBWSw0QkFBNEIsZ0JBQWdCLFlBQVksdUVBQXVFLGtCQUFrQixNQUFNLFFBQVEsU0FBUyxPQUFPLGdCQUFnQixvQkFBb0IsV0FBVyxZQUFZLFlBQVksVUFBVSxXQUFXLEtBQUssVUFBVSxrQkFBa0IsV0FBVywwR0FBMEcsYUFBYSxtRkFBbUYsc0JBQXNCLFdBQVcscUVBQXFFLHdCQUF3QixrQ0FBa0MsMENBQTBDLDBCQUEwQixpRkFBaUYsbUNBQW1DLHFEQUFxRCx1Q0FBdUMscUJBQXFCLGlCQUFpQixtQkFBbUIsc0VBQXNFLHFCQUFxQiw2QkFBNkIsbUJBQW1CLHlFQUF5RSxvREFBb0QsaURBQWlELGdEQUFnRCw0Q0FBNEMsK0NBQStDLDhCQUE4QixvREFBb0QsOERBQThELGNBQWMsWUFBWSw0Q0FBNEMsZ0JBQWdCLHFDQUFxQyw2Q0FBNkMsbUJBQW1CLHNCQUFzQixXQUFXLHFEQUFxRCxxQkFBcUIsaUlBQWlJLHNCQUFzQixlQUFlLGlCQUFpQiw2TEFBNkwsV0FBVyxzQkFB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QixzREFBc0QsbUNBQW1DLG1DQUFtQyw2QkFBNkIsU0FBUyxxQ0FBcUMsMkJBQTJCLHdCQUF3Qix3Q0FBd0MsZ0hBQWdILHFFQUFxRSxrRUFBa0UsaUVBQWlFLDZEQUE2RCx1Q0FBdUMsa0JBQWtCLCtmQUErZixtQ0FBbUMsNkJBQTZCLHFEQUFxRCxpRUFBaUUsdUNBQXVDLDJEQUEyRCxnRUFBZ0UsK2FBQSthLDZEQUE2RCx1Q0FBdUMsZ0RBQWdELGlFQUFpRSx1Q0FBdUMsc0RBQXNELGlFQUFpRSwrQkFBK0IsMmRBQTJkLHNDQUFzQyxZQUFZLDJUQUEyVCx5QkFBeUIsd0JBQXdCLGdCQUFnQixTQUFTLFVBQVUsV0FBVyxrQkFBa0IsU0FBUyxPQUFPLHdCQUF3QixlQUFlLG1CQUFtQiw4QkFBOEIsZ0JBQWdCLFdBQVcsZ0JBQWdCLGtCQUFrQixtQ0FBbUMsSUFBSSxnQkFBZ0IscUJBQXFCLGNBQWMsU0FBUyxZQUFZLGlDQUFpQyw2QkFBNkIsZ0JBQWdCLGtCQUFrQiwrQkFBK0IsMkNBQTJDLGlDQUFpQywrQ0FBK0MsdUJBQXVCLGdCQUFnQiwyQkFBMkIsZUFBZSwwQkFBMEIsZ05BQWdOLDZCQUE2QiwwQ0FBMEMsd0JBQXdCLGtCQUFrQixXQUFXLGdCQUFnQixZQUFZLDRCQUE0QixrQkFBa0IsU0FBUyxPQUFPLFFBQVEsWUFBWSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2pxdWVyeS50ZXJtaW5hbC9jc3MvanF1ZXJ5LnRlcm1pbmFsLm1pbi5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyohXFxuICogICAgICAgX18gX19fX18gICAgICAgICAgICAgICAgICAgICBfX19fX19fXyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fXFxuICogICAgICAvIC8vIF8gIC9fXyBfXyBfX19fXyBfX18gX18gXy9fXyAgX19fL19fIF9fXyBfX19fX18gX18gX18gIF9fIF9fXyAgLyAvXFxuICogIF9fIC8gLy8gLy8gLy8gLy8gLy8gXyAgLy8gXy8vIC8vIC8gLyAvLyBfICAvLyBfLy8gICAgIC8vIC8vICBcXFxcLyAvLyBfIFxcXFwvIC9cXG4gKiAvICAvIC8vIC8vIC8vIC8vIC8vIF9fXy8vIC8gLyAvLyAvIC8gLy8gX19fLy8gLyAvIC8gLyAvLyAvLyAvXFxcXCAgLy8gLy8gLyAvX19cXG4gKiBcXFxcX19fLy9fX19fIFxcXFxcXFxcX19fLy9fX19fLy9fLyBfXFxcXF8gIC8gL18vL19fX18vL18vIC9fLyAvXy8vXy8vXy8gL18vIFxcXFxfX1xcXFxfXFxcXF9fXy9cXG4gKiAgICAgICAgICAgXFxcXC8gICAgICAgICAgICAgIC9fX19fLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24gMi4xMi4wXFxuICogaHR0cDovL3Rlcm1pbmFsLmpjdWJpYy5wbFxcbiAqXFxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgalF1ZXJ5IFRlcm1pbmFsLlxcbiAqXFxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTkgSmFrdWIgSmFua2lld2ljeiA8aHR0cHM6Ly9qY3ViaWMucGwvbWU+XFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuICpcXG4gKiBEYXRlOiBXZWQsIDAxIEphbiAyMDIwIDE3OjAzOjE2ICswMDAwXFxuICovLmNtZC1wcm9tcHQsLmNtZC1wcm9tcHQgZGl2LC5jbWQgLmZvcm1hdCwudGVybWluYWwgLnRlcm1pbmFsLW91dHB1dCAuZm9ybWF0e2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5jbWQsLnRlcm1pbmFsIGgxLC50ZXJtaW5hbCBoMiwudGVybWluYWwgaDMsLnRlcm1pbmFsIGg0LC50ZXJtaW5hbCBoNSwudGVybWluYWwgaDYsLnRlcm1pbmFsIHByZXttYXJnaW46MH0uY21kIC5jbWQtY2xpcGJvYXJke3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTE2cHg7dG9wOjA7d2lkdGg6MTZweDtoZWlnaHQ6MTZweDtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlcjpub25lO2NvbG9yOnRyYW5zcGFyZW50O291dGxpbmU6bm9uZTtwYWRkaW5nOjA7cmVzaXplOm5vbmU7ei1pbmRleDoxMDAwO292ZXJmbG93OmhpZGRlbjt3aGl0ZS1zcGFjZTpwcmU7dGV4dC1pbmRlbnQ6LTk5OTllbTt0b3A6Y2FsYyh2YXIoLS1jdXJzb3ItbGluZSwgMCkqMWVtKX0uY21kIC5jdXJzb3Irc3BhbjplbXB0eSwuY21kIGRpdi5jbWQtZW5kLWxpbmUgc3BhbltkYXRhLXRleHRdOmxhc3QtY2hpbGQsLmNtZCBkaXYuY21kLWVuZC1saW5lIHNwYW5bZGF0YS10ZXh0XTpsYXN0LWNoaWxkIHNwYW4sLmNtZCBzcGFuLmNtZC1lbmQtbGluZSwuY21kIHNwYW4uY21kLWVuZC1saW5lIHNwYW57LXdlYmtpdC10b3VjaC1jYWxsb3V0Om5vbmU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1raHRtbC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS50ZXJtaW5hbCBhdWRpbywudGVybWluYWwgY2FudmFzLC50ZXJtaW5hbCBpbWcsLnRlcm1pbmFsIG9iamVjdHtjdXJzb3I6ZGVmYXVsdH0udGVybWluYWx7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3cteTphdXRvfXRlcm1pbmFsLnRlcm1pbmFsLXRlbXB7dmlzaWJpbGl0eTpoaWRkZW59LnRlcm1pbmFse2NvbnRhaW46Y29udGVudH1ib2R5LnRlcm1pbmFse21pbi1oZWlnaHQ6MTAwdmg7aGVpZ2h0OjEwMCV9aHRtbHtoZWlnaHQ6MTAwJX1ib2R5LmZ1bGwtc2NyZWVuLXRlcm1pbmFsLGJvZHkudGVybWluYWx7bWFyZ2luOjA7aGVpZ2h0OjEwMCV9Ym9keS5mdWxsLXNjcmVlbi10ZXJtaW5hbCAudGVybWluYWx7aGVpZ2h0OjEwMCV9LnRlcm1pbmFsPmRpdi50ZXJtaW5hbC1maWxse21pbi1oZWlnaHQ6MTAwJTtoZWlnaHQ6MTAwJX0udGVybWluYWw+LnRlcm1pbmFsLWZvbnQgLnRlcm1pbmFsLXJlc2l6ZXIsLnRlcm1pbmFsPi50ZXJtaW5hbC1yZXNpemVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO292ZXJmbG93OmhpZGRlbjtwb2ludGVyLWV2ZW50czpub25lO3otaW5kZXg6LTE7aGVpZ2h0OjEwMCU7Ym9yZGVyOm5vbmU7cGFkZGluZzowO3dpZHRoOjEwMCV9LmNtZHtwYWRkaW5nOjA7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJX0udGVybWluYWwgYVt0YWJpbmRleD1cXFwiMTAwMFxcXCJdLC50ZXJtaW5hbCBhW3RhYmluZGV4PVxcXCIxMDAwXFxcIl06YWN0aXZlLC50ZXJtaW5hbCBhW3RhYmluZGV4PVxcXCIxMDAwXFxcIl06Zm9jdXN7b3V0bGluZTpub25lfS5jbWQgLmNtZC1pbnZlcnRlZCwuY21kIC5pbnZlcnRlZCwudGVybWluYWwgLmludmVydGVkLC50ZXJtaW5hbCAudGVybWluYWwtaW52ZXJ0ZWR7YmFja2dyb3VuZC1jb2xvcjojYWFhO2NvbG9yOiMwMDB9LmNtZCBhW2hyZWZdIHNwYW4sLnRlcm1pbmFsIC50ZXJtaW5hbC1vdXRwdXQ+Om5vdCgucmF3KSBhW2hyZWZdIHNwYW57Y29sb3I6IzBmNjBmZiFpbXBvcnRhbnQ7LS1jb2xvcjp2YXIoLS1saW5rLWNvbG9yLCMwZjYwZmYpO2NvbG9yOnZhcigtLWxpbmstY29sb3IsIzBmNjBmZikhaW1wb3J0YW50O3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9LmNtZCBhW2hyZWZdOmhvdmVyIHNwYW4sLnRlcm1pbmFsIC50ZXJtaW5hbC1vdXRwdXQ+Om5vdCgucmF3KSBhW2hyZWZdOmhvdmVyIHNwYW57YmFja2dyb3VuZC1jb2xvcjojMGY2MGZmIWltcG9ydGFudDtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWxpbmstY29sb3IsIzBmNjBmZikhaW1wb3J0YW50O2NvbG9yOnZhcigtLWJhY2tncm91bmQsIzAwMCkhaW1wb3J0YW50O3RleHQtZGVjb3JhdGlvbjpub25lfS5jbWQgLmNtZC1jdXJzb3J7dmVydGljYWwtYWxpZ246dG9wfS5jbWQgLmNtZC1jdXJzb3IsLmNtZCAuY21kLWN1cnNvci1saW5lPnNwYW4sLmNtZCAuY21kLWN1cnNvci1saW5lIGltZ3tkaXNwbGF5OmlubGluZS1ibG9ja30uY21kLXdyYXBwZXIgZGl2IFtkYXRhLXRleHRde3ZlcnRpY2FsLWFsaWduOnRvcH0uY21kIC5jbWQtY3Vyc29yLmNtZC1ibGluayBzcGFuOm5vdCguZW1vamkpIHNwYW4sLmNtZCAuY21kLWN1cnNvciAuZW1vaml7LXdlYmtpdC1hbmltYXRpb246dGVybWluYWwtYmxpbmsgMXMgbGluZWFyIGluZmluaXRlOy1tb3otYW5pbWF0aW9uOnRlcm1pbmFsLWJsaW5rIDFzIGluZmluaXRlIGxpbmVhcjstbXMtYW5pbWF0aW9uOnRlcm1pbmFsLWJsaW5rIDFzIGluZmluaXRlIGxpbmVhcjthbmltYXRpb246dGVybWluYWwtYmxpbmsgMXMgbGluZWFyIGluZmluaXRlfS5iYXIuY21kIC5jbWQtaW52ZXJ0ZWQsLmJhci50ZXJtaW5hbCAuaW52ZXJ0ZWR7Ym94LXNoYWRvdzotMnB4IDAgMCAtMXB4ICNhYWE7Ym94LXNoYWRvdzotMnB4IDAgMCAtMXB4IHZhcigtLW9yaWdpbmFsLWNvbG9yLCNhYWEpfS5jbWQgLmNtZC1wcm9tcHQsLnRlcm1pbmFsIC50ZXJtaW5hbCAudGVybWluYWwtb3V0cHV0PmRpdj5kaXZ7ZGlzcGxheTpibG9jaztoZWlnaHQ6YXV0b30uY21kIGRpdiwudGVybWluYWwgLnRlcm1pbmFsLW91dHB1dD5kaXY+ZGl2e21pbi1oZWlnaHQ6MTRweDttaW4taGVpZ2h0OmNhbGModmFyKC0tc2l6ZSwgMSkqMTRweCl9LnRlcm1pbmFsIC50ZXJtaW5hbC1vdXRwdXQ+ZGl2Om5vdCgucmF3KSBkaXZ7d2hpdGUtc3BhY2U6bm93cmFwfS5jbWQgLmNtZC1wcm9tcHQ+c3BhbntmbG9hdDpsZWZ0fS5jbWQgc3BhbltzdHlsZSo9d2lkdGhdLC50ZXJtaW5hbCBzcGFuW3N0eWxlKj13aWR0aF17ZGlzcGxheTppbmxpbmUtYmxvY2t9LmNtZCwuY21kIGRpdiwuY21kIHNwYW4sLnRlcm1pbmFsLC50ZXJtaW5hbC1vdXRwdXQ+Om5vdCgucmF3KSBhLC50ZXJtaW5hbC1vdXRwdXQ+Om5vdCgucmF3KSBkaXYsLnRlcm1pbmFsLW91dHB1dD46bm90KC5yYXcpIHNwYW57Zm9udC1mYW1pbHk6bW9ub3NwYWNlO2ZvbnQtc2l6ZToxMnB4O2xpbmUtaGVpZ2h0OjE1cHh9LmNtZCBzcGFuOm5vdCguY21kLWludmVydGVkKTpub3QoLnRva2VuKTpub3QoLmVtb2ppKSwudGVybWluYWwtb3V0cHV0Pjpub3QoLnJhdykgc3Bhbjpub3QoLnRva2VuKTpub3QoLmludmVydGVkKTpub3QoLnRlcm1pbmFsLWludmVydGVkKTpub3QoLmNtZC1pbnZlcnRlZCk6bm90KC50ZXJtaW5hbC1lcnJvcik6bm90KC5lbW9qaSl7Y29sb3I6I2FhYTtiYWNrZ3JvdW5kLWNvbG9yOiMwMDB9LmNtZCAuZW1vamksLnRlcm1pbmFsLW91dHB1dD46bm90KC5yYXcpIC5lbW9qaXtoZWlnaHQ6MTRweDtiYWNrZ3JvdW5kLXNpemU6Y29udGFpbjtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7Y29sb3I6dHJhbnNwYXJlbnQ7cG9zaXRpb246cmVsYXRpdmV9LmNtZCAuZW1vamksLmNtZCAuZW1vamkgc3BhbiwudGVybWluYWwtb3V0cHV0Pjpub3QoLnJhdykgLmVtb2ppLC50ZXJtaW5hbC1vdXRwdXQ+Om5vdCgucmF3KSAuZW1vamkgc3BhbntkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoyY2h9LmNtZCwudGVybWluYWx7Ym94LXNpemluZzpib3JkZXItYm94O2N1cnNvcjp0ZXh0fS5jbWQgLmNtZC1jdXJzb3Igc3Bhbjpub3QoLnRva2VuKTpub3QoLmludmVydGVkKXtjb2xvcjppbmhlcml0O2JhY2tncm91bmQtY29sb3I6aW5oZXJpdH0uY21kIC5lbW9qaS5lbW9qaS5lbW9qaS5lbW9qaSwuY21kIC5lbW9qaS5lbW9qaS5lbW9qaS5lbW9qaSBzcGFue2NvbG9yOnRyYW5zcGFyZW50O2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9LmNtZCAuY21kLWN1cnNvciAqe2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9LmNtZCBkaXZ7Y2xlYXI6Ym90aH0uY21kIC5jbWQtcHJvbXB0K2RpdntjbGVhcjpyaWdodH0uY21kIGRpdiwudGVybWluYWwtb3V0cHV0PmRpdj5kaXZ7bWluLWhlaWdodDoxNXB4fXRlcm1pbmFsIC50ZXJtaW5hbC1vdXRwdXQ+ZGl2e21hcmdpbi10b3A6LTFweH0udGVybWluYWwtb3V0cHV0PmRpdi5yYXc+ZGl2ICp7b3ZlcmZsb3ctd3JhcDpicmVhay13b3JkO3dvcmQtd3JhcDpicmVhay13b3JkfS50ZXJtaW5hbCAudGVybWluYWwtZm9udHtwb3NpdGlvbjphYnNvbHV0ZTtmbG9hdDpsZWZ0O2ZvbnQtc2l6ZTppbmhlcml0O2xpbmUtaGVpZ2h0OmluaGVyaXQ7dG9wOi0xMDAlO2xlZnQ6MDttYXJnaW4tYm90dG9tOjFweH0uY21kPnNwYW46bm90KC5jbWQtcHJvbXB0KXtmbG9hdDpsZWZ0fS5jbWQgLmNtZC1wcm9tcHQgc3Bhbi5jbWQtbGluZXtkaXNwbGF5OmJsb2NrO2Zsb2F0Om5vbmV9LnRlcm1pbmFsIHRhYmxle2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZX0udGVybWluYWwgdGR7Ym9yZGVyOjFweCBzb2xpZCAjYWFhfS5jbWQuY21kIHNwYW5bZGF0YS10ZXh0XTpub3QoLmVtb2ppKSBzcGFue2JhY2tncm91bmQtY29sb3I6aW5oZXJpdDtjb2xvcjppbmhlcml0fS5jbWQgW3JvbGU9cHJlc2VudGF0aW9uXS5jbWQtY3Vyc29yLWxpbmV7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxMDB9LmNtZCAuY21kLXByb21wdHtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjIwMH0uY21kIFtyb2xlPXByZXNlbnRhdGlvbl06bm90KC5jbWQtY3Vyc29yLWxpbmUpe292ZXJmbG93OmhpZGRlbn0uY21key0tb3JpZ2luYWwtY29sb3I6dmFyKC0tY29sb3IsI2FhYSl9LmNtZCBhW2hyZWZdey0tb3JpZ2luYWwtY29sb3I6dmFyKC0tbGluay1jb2xvciwjMGY2MGZmKX1ALXdlYmtpdC1rZXlmcmFtZXMgdGVybWluYWwtYmxpbmt7MCUsNTAle2JhY2tncm91bmQtY29sb3I6I2JiYjtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLW9yaWdpbmFsLWNvbG9yLCNiYmIpO2NvbG9yOiMwMDA7Y29sb3I6dmFyKC0tYmFja2dyb3VuZCwjMDAwKX01MC4xJSx0b3tiYWNrZ3JvdW5kLWNvbG9yOmluaGVyaXQ7Y29sb3I6aW5oZXJpdH19QC1tb3ota2V5ZnJhbWVzIHRlcm1pbmFsLWJsaW5rezAlLDUwJXtiYWNrZ3JvdW5kLWNvbG9yOiNhYWE7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1vcmlnaW5hbC1jb2xvciwjYWFhKTtjb2xvcjojMDAwO2NvbG9yOnZhcigtLWJhY2tncm91bmQsIzAwMCl9NTAuMSUsdG97YmFja2dyb3VuZC1jb2xvcjppbmhlcml0O2NvbG9yOmluaGVyaXR9fUBrZXlmcmFtZXMgdGVybWluYWwtYmxpbmt7MCUsNTAle2JhY2tncm91bmQtY29sb3I6I2FhYTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLW9yaWdpbmFsLWNvbG9yLCNhYWEpO2NvbG9yOiMwMDA7Y29sb3I6dmFyKC0tYmFja2dyb3VuZCwjMDAwKX01MC4xJSx0b3tiYWNrZ3JvdW5kLWNvbG9yOmluaGVyaXQ7Y29sb3I6aW5oZXJpdH19QC13ZWJraXQta2V5ZnJhbWVzIHRlcm1pbmFsLWdsb3d7MCUsNTAle2JhY2tncm91bmQtY29sb3I6I2FhYTtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLW9yaWdpbmFsLWNvbG9yLCNhYWEpO2NvbG9yOiMwMDA7Y29sb3I6dmFyKC0tYmFja2dyb3VuZCwjMDAwKTtib3gtc2hhZG93OjAgMCAzcHggI2FhYTstd2Via2l0LWJveC1zaGFkb3c6MCAwIDNweCB2YXIoLS1jb2xvciwjYWFhKTtib3gtc2hhZG93OjAgMCAzcHggdmFyKC0tY29sb3IsI2FhYSl9NTAuMSUsdG97YmFja2dyb3VuZC1jb2xvcjppbmhlcml0O2NvbG9yOmluaGVyaXQ7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lfX1ALW1vei1rZXlmcmFtZXMgdGVybWluYWwtZ2xvd3swJSw1MCV7YmFja2dyb3VuZC1jb2xvcjojYWFhO2JhY2tncm91bmQtY29sb3I6dmFyKC0tb3JpZ2luYWwtY29sb3IsI2FhYSk7Y29sb3I6IzAwMDtjb2xvcjp2YXIoLS1iYWNrZ3JvdW5kLCMwMDApO2JveC1zaGFkb3c6MCAwIDNweCAjYWFhOy1tb3otYm94LXNoYWRvdzowIDAgM3B4IHZhcigtLWNvbG9yLCNhYWEpO2JveC1zaGFkb3c6MCAwIDNweCB2YXIoLS1jb2xvciwjYWFhKX01MC4xJSx0b3tiYWNrZ3JvdW5kLWNvbG9yOmluaGVyaXQ7Y29sb3I6aW5oZXJpdDstbW96LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9fUBrZXlmcmFtZXMgdGVybWluYWwtZ2xvd3swJSw1MCV7YmFja2dyb3VuZC1jb2xvcjojYWFhO2JhY2tncm91bmQtY29sb3I6dmFyKC0tb3JpZ2luYWwtY29sb3IsI2FhYSk7Y29sb3I6IzAwMDtjb2xvcjp2YXIoLS1iYWNrZ3JvdW5kLCMwMDApO2JveC1zaGFkb3c6MCAwIDNweCAjYWFhO2JveC1zaGFkb3c6MCAwIDNweCB2YXIoLS1jb2xvciwjYWFhKX01MC4xJSx0b3tiYWNrZ3JvdW5kLWNvbG9yOmluaGVyaXQ7Y29sb3I6aW5oZXJpdDtib3gtc2hhZG93Om5vbmV9fUAtd2Via2l0LWtleWZyYW1lcyB0ZXJtaW5hbC1iYXJ7MCUsNTAle2JveC1zaGFkb3c6LTJweCAwIDAgLTFweCAjYWFhO2JveC1zaGFkb3c6LTJweCAwIDAgLTFweCB2YXIoLS1vcmlnaW5hbC1jb2xvciwjYWFhKX01MC4xJSx0b3tib3gtc2hhZG93Om5vbmV9fUAtbW96LWtleWZyYW1lcyB0ZXJtaW5hbC1iYXJ7MCUsNTAle2JveC1zaGFkb3c6LTJweCAwIDAgLTFweCAjYWFhO2JveC1zaGFkb3c6LTJweCAwIDAgLTFweCB2YXIoLS1vcmlnaW5hbC1jb2xvciwjYWFhKX01MC4xJSx0b3tib3gtc2hhZG93Om5vbmV9fUBrZXlmcmFtZXMgdGVybWluYWwtYmFyezAlLDUwJXtib3gtc2hhZG93Oi0ycHggMCAwIC0xcHggI2FhYTtib3gtc2hhZG93Oi0ycHggMCAwIC0xcHggdmFyKC0tb3JpZ2luYWwtY29sb3IsI2FhYSl9NTAuMSUsdG97Ym94LXNoYWRvdzpub25lfX1ALXdlYmtpdC1rZXlmcmFtZXMgdGVybWluYWwtdW5kZXJsaW5lezAlLDUwJXtib3gtc2hhZG93OjAgMnB4IDAgI2FhYTtib3gtc2hhZG93OjAgMnB4IDAgdmFyKC0tb3JpZ2luYWwtY29sb3IsI2FhYSl9NTAuMSUsdG97Ym94LXNoYWRvdzpub25lfX1ALW1vei1rZXlmcmFtZXMgdGVybWluYWwtdW5kZXJsaW5lezAlLDUwJXtib3gtc2hhZG93OjAgMnB4IDAgI2FhYTtib3gtc2hhZG93OjAgMnB4IDAgdmFyKC0tb3JpZ2luYWwtY29sb3IsI2FhYSl9NTAuMSUsdG97Ym94LXNoYWRvdzpub25lfX1Aa2V5ZnJhbWVzIHRlcm1pbmFsLXVuZGVybGluZXswJSw1MCV7Ym94LXNoYWRvdzowIDJweCAwICNhYWE7Ym94LXNoYWRvdzowIDJweCAwIHZhcigtLW9yaWdpbmFsLWNvbG9yLCNhYWEpfTUwLjElLHRve2JveC1zaGFkb3c6bm9uZX19LnVuZGVybGluZS1hbmltYXRpb24gLmNtZC1jdXJzb3IuY21kLWJsaW5rIGEsLnVuZGVybGluZS1hbmltYXRpb24gLmNtZC1jdXJzb3IuY21kLWJsaW5rIHNwYW4gc3Bhbnstd2Via2l0LWFuaW1hdGlvbi1uYW1lOnRlcm1pbmFsLXVuZGVybGluZTstbW96LWFuaW1hdGlvbi1uYW1lOnRlcm1pbmFsLXVuZGVybGluZTstbXMtYW5pbWF0aW9uLW5hbWU6dGVybWluYWwtdW5kZXJsaW5lO2FuaW1hdGlvbi1uYW1lOnRlcm1pbmFsLXVuZGVybGluZX0uZ2xvdy1hbmltYXRpb24gLmNtZC1jdXJzb3IuY21kLWJsaW5rIGEsLmdsb3ctYW5pbWF0aW9uIC5jbWQtY3Vyc29yLmNtZC1ibGluayBzcGFuIHNwYW57LXdlYmtpdC1hbmltYXRpb24tbmFtZTp0ZXJtaW5hbC1nbG93Oy1tb3otYW5pbWF0aW9uLW5hbWU6dGVybWluYWwtZ2xvdzstbXMtYW5pbWF0aW9uLW5hbWU6dGVybWluYWwtZ2xvdzthbmltYXRpb24tbmFtZTp0ZXJtaW5hbC1nbG93fS5iYXItYW5pbWF0aW9uIC5jbWQtY3Vyc29yLmNtZC1ibGluayBhLC5iYXItYW5pbWF0aW9uIC5jbWQtY3Vyc29yLmNtZC1ibGluayBzcGFuIHNwYW57LXdlYmtpdC1hbmltYXRpb24tbmFtZTp0ZXJtaW5hbC1iYXI7LW1vei1hbmltYXRpb24tbmFtZTp0ZXJtaW5hbC1iYXI7LW1zLWFuaW1hdGlvbi1uYW1lOnRlcm1pbmFsLWJhcjthbmltYXRpb24tbmFtZTp0ZXJtaW5hbC1iYXJ9QHN1cHBvcnRzICgtbXMtaW1lLWFsaWduOmF1dG8pey5jbWQgLmNtZC1jbGlwYm9hcmR7bWFyZ2luLWxlZnQ6LTk5OTlweH1Aa2V5ZnJhbWVzIHRlcm1pbmFsLWJsaW5rezAlLDUwJXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLW9yaWdpbmFsLWNvbG9yLCNhYWEpO2NvbG9yOnZhcigtLWJhY2tncm91bmQsIzAwMCl9NTAuMSUsdG97YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1iYWNrZ3JvdW5kLCMwMDApO2NvbG9yOnZhcigtLW9yaWdpbmFsLWNvbG9yLCNhYWEpfX1Aa2V5ZnJhbWVzIHRlcm1pbmFsLWJhcnswJSw1MCV7Ym9yZGVyLWxlZnQtY29sb3I6dmFyKC0tY29sb3IsI2FhYSl9NTAuMSUsdG97Ym9yZGVyLWxlZnQtY29sb3I6dmFyKC0tYmFja2dyb3VuZCwjMDAwKX19QGtleWZyYW1lcyB0ZXJtaW5hbC11bmRlcmxpbmV7MCUsNTAle2JvcmRlci1ib3R0b20tY29sb3I6dmFyKC0tY29sb3IsI2FhYSk7bGluZS1oZWlnaHQ6MTJweDtsaW5lLWhlaWdodDpjYWxjKHZhcigtLXNpemUsIDEpKjEycHgpfTUwLjElLHRve2JvcmRlci1ib3R0b20tY29sb3I6dmFyKC0tYmFja2dyb3VuZCwjMDAwKTtsaW5lLWhlaWdodDoxMnB4O2xpbmUtaGVpZ2h0OmNhbGModmFyKC0tc2l6ZSwgMSkqMTJweCl9fX1AbWVkaWEgKC1tcy1oaWdoLWNvbnRyYXN0OmFjdGl2ZSksKC1tcy1oaWdoLWNvbnRyYXN0Om5vbmUpey5jbWQgLmNtZC1jbGlwYm9hcmR7bWFyZ2luLWxlZnQ6LTk5OTlweH0udW5kZXJsaW5lLWFuaW1hdGlvbiAuY3Vyc29yLmJsaW5rIHNwYW4gc3BhbnttYXJnaW4tdG9wOjFweH1ALW1zLWtleWZyYW1lcyB0ZXJtaW5hbC1ibGlua3swJSw1MCV7YmFja2dyb3VuZC1jb2xvcjojYWFhO2NvbG9yOiMwMDB9NTAuMSUsdG97YmFja2dyb3VuZC1jb2xvcjojMDAwO2NvbG9yOiNhYWF9fX0uY21kIC5wcm9tcHQgc3Bhbjo6LW1vei1zZWxlY3Rpb24sLmNtZD5kaXY6Oi1tb3otc2VsZWN0aW9uLC5jbWQ+ZGl2IHNwYW46Oi1tb3otc2VsZWN0aW9uLC5jbWQ+c3Bhbjo6LW1vei1zZWxlY3Rpb24sLmNtZD5zcGFuIHNwYW46Oi1tb3otc2VsZWN0aW9uLC5jbWQgZGl2OjotbW96LXNlbGVjdGlvbiwudGVybWluYWwgLnRlcm1pbmFsLW91dHB1dCAucmF3IGRpdjo6LW1vei1zZWxlY3Rpb24sLnRlcm1pbmFsIC50ZXJtaW5hbC1vdXRwdXQgZGl2IGRpdjo6LW1vei1zZWxlY3Rpb24sLnRlcm1pbmFsIC50ZXJtaW5hbC1vdXRwdXQgZGl2IGRpdiBhOjotbW96LXNlbGVjdGlvbiwudGVybWluYWwgLnRlcm1pbmFsLW91dHB1dCBkaXYgc3Bhbjo6LW1vei1zZWxlY3Rpb24sLnRlcm1pbmFsIGgxOjotbW96LXNlbGVjdGlvbiwudGVybWluYWwgaDI6Oi1tb3otc2VsZWN0aW9uLC50ZXJtaW5hbCBoMzo6LW1vei1zZWxlY3Rpb24sLnRlcm1pbmFsIGg0OjotbW96LXNlbGVjdGlvbiwudGVybWluYWwgaDU6Oi1tb3otc2VsZWN0aW9uLC50ZXJtaW5hbCBoNjo6LW1vei1zZWxlY3Rpb24sLnRlcm1pbmFsIHByZTo6LW1vei1zZWxlY3Rpb24sLnRlcm1pbmFsIHRkOjotbW96LXNlbGVjdGlvbntiYWNrZ3JvdW5kLWNvbG9yOiNhYWE7Y29sb3I6IzAwMH0uY21kIC5wcm9tcHQgc3Bhbjo6c2VsZWN0aW9uLC5jbWQ+ZGl2OjpzZWxlY3Rpb24sLmNtZD5kaXYgc3Bhbjo6c2VsZWN0aW9uLC5jbWQ+c3Bhbjo6c2VsZWN0aW9uLC5jbWQ+c3BhbiBzcGFuOjpzZWxlY3Rpb24sLmNtZCBkaXY6OnNlbGVjdGlvbiwudGVybWluYWwgLnRlcm1pbmFsLW91dHB1dCAucmF3IGRpdjo6c2VsZWN0aW9uLC50ZXJtaW5hbCAudGVybWluYWwtb3V0cHV0OjpzZWxlY3Rpb24sLnRlcm1pbmFsIC50ZXJtaW5hbC1vdXRwdXQgZGl2IGRpdjo6c2VsZWN0aW9uLC50ZXJtaW5hbCAudGVybWluYWwtb3V0cHV0IGRpdiBkaXYgYTo6c2VsZWN0aW9uLC50ZXJtaW5hbCAudGVybWluYWwtb3V0cHV0IGRpdiBzcGFuOjpzZWxlY3Rpb24sLnRlcm1pbmFsIGgxOjpzZWxlY3Rpb24sLnRlcm1pbmFsIGgyOjpzZWxlY3Rpb24sLnRlcm1pbmFsIGgzOjpzZWxlY3Rpb24sLnRlcm1pbmFsIGg0OjpzZWxlY3Rpb24sLnRlcm1pbmFsIGg1OjpzZWxlY3Rpb24sLnRlcm1pbmFsIGg2OjpzZWxlY3Rpb24sLnRlcm1pbmFsIHByZTo6c2VsZWN0aW9uLC50ZXJtaW5hbCB0ZDo6c2VsZWN0aW9ue2JhY2tncm91bmQtY29sb3I6aHNsYSgwLDAlLDY2LjclLC45OSk7Y29sb3I6IzAwMH0udGVybWluYWwgLnRlcm1pbmFsLW91dHB1dD46bm90KC5yYXcpIC50ZXJtaW5hbC1lcnJvciwudGVybWluYWwgLnRlcm1pbmFsLW91dHB1dD46bm90KC5yYXcpIC50ZXJtaW5hbC1lcnJvciAqe2NvbG9yOnJlZDtjb2xvcjp2YXIoLS1lcnJvci1jb2xvcixyZWQpfS50aWxkYXtwb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTt6LWluZGV4OjExMDB9LnVpLWRpYWxvZy1jb250ZW50IC50ZXJtaW5hbHt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2JveC1zaXppbmc6Ym9yZGVyLWJveH0udWktZGlhbG9nIC51aS1kaWFsb2ctY29udGVudC5kdGVybXtwYWRkaW5nOjB9LmNsZWFye2NsZWFyOmJvdGh9LmNtZCBhW2hyZWZdLC50ZXJtaW5hbCAudGVybWluYWwtb3V0cHV0Pjpub3QoLnJhdykgYVtocmVmXXtjb2xvcjojMGY2MGZmO2NvbG9yOnZhcigtLWxpbmstY29sb3IsIzBmNjBmZik7Y3Vyc29yOnBvaW50ZXJ9LmNtZCBhW2hyZWZdOm5vdCgudGVybWluYWwtaW52ZXJ0ZWQpLC50ZXJtaW5hbCAudGVybWluYWwtb3V0cHV0Pjpub3QoLnJhdykgYVtocmVmXTpub3QoLnRlcm1pbmFsLWludmVydGVkKXstLWNvbG9yOnZhcigtLWxpbmstY29sb3IsIzBmNjBmZil9LnRlcm1pbmFsIC50ZXJtaW5hbC1vdXRwdXQ+Om5vdCgucmF3KSBhW2hyZWZdLnRlcm1pbmFsLWludmVydGVke2JhY2tncm91bmQ6dmFyKC0tY29sb3IsI2NjYyl9LmNtZCBhW2hyZWZdOmhvdmVyLC50ZXJtaW5hbCAudGVybWluYWwtb3V0cHV0Pjpub3QoLnJhdykgYVtocmVmXTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMwZjYwZmY7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1saW5rLWNvbG9yLCMwZjYwZmYpO2NvbG9yOnZhcigtLWJhY2tncm91bmQsIzAwMCkhaW1wb3J0YW50O3RleHQtZGVjb3JhdGlvbjpub25lfS50ZXJtaW5hbCAudGVybWluYWwtZmlsbHtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOi0xMDAlO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7bWFyZ2luOjFweCAwIDA7Ym9yZGVyOm5vbmU7b3BhY2l0eTouMDE7cG9pbnRlci1ldmVudHM6bm9uZTtib3gtc2l6aW5nOmJvcmRlci1ib3h9LnRlcm1pbmFsLC50ZXJtaW5hbCAudGVybWluYWwtZmlsbHtwYWRkaW5nOjEwcHh9LnRlcm1pbmFse3BhZGRpbmctYm90dG9tOjB9LnRlcm1pbmFsIC5jbWR7bWFyZ2luLWJvdHRvbToxMHB4fUBzdXBwb3J0cyAoLS1jc3M6dmFyaWFibGVzKXsuY21kLC5jbWQgZGl2LC5jbWQgc3Bhbjpub3QoLmNtZC1pbnZlcnRlZCk6bm90KC50b2tlbik6bm90KC5lbW9qaSksLnRlcm1pbmFsLC50ZXJtaW5hbC1vdXRwdXQ+Om5vdCgucmF3KSBhLC50ZXJtaW5hbC1vdXRwdXQ+Om5vdCgucmF3KSBkaXYsLnRlcm1pbmFsLW91dHB1dD46bm90KC5yYXcpIHNwYW46bm90KC50b2tlbik6bm90KC5pbnZlcnRlZCk6bm90KC50ZXJtaW5hbC1pbnZlcnRlZCk6bm90KC5jbWQtaW52ZXJ0ZWQpOm5vdCgudGVybWluYWwtZXJyb3IpOm5vdCguZW1vamkpe2NvbG9yOnZhcigtLWNvbG9yLCNhYWEpO2JhY2tncm91bmQtY29sb3I6dmFyKC0tYmFja2dyb3VuZCwjMDAwKX0udGVybWluYWwgc3BhbltzdHlsZSo9XFxcIi0tbGVuZ3RoXFxcIl17d2lkdGg6Y2FsYyh2YXIoLS1sZW5ndGgsIDEpKnZhcigtLWNoYXItd2lkdGgsIDcuMjM0MzgpKjFweCk7ZGlzcGxheTppbmxpbmUtYmxvY2t9LmNtZCwuY21kIGRpdiwuY21kIHNwYW4sLnRlcm1pbmFsLC50ZXJtaW5hbC1vdXRwdXQ+Om5vdCgucmF3KSBhLC50ZXJtaW5hbC1vdXRwdXQ+Om5vdCgucmF3KSBkaXYsLnRlcm1pbmFsLW91dHB1dD46bm90KC5yYXcpIHNwYW57Zm9udC1zaXplOmNhbGModmFyKC0tc2l6ZSwgMSkqMTJweCk7bGluZS1oZWlnaHQ6Y2FsYyh2YXIoLS1zaXplLCAxKSoxNHB4KX0uY21kIC5lbW9qaSwudGVybWluYWwtb3V0cHV0Pjpub3QoLnJhdykgLmVtb2ppe2hlaWdodDpjYWxjKHZhcigtLXNpemUsIDEpKjE0cHgpfS5jbWQgLmNsaXBib2FyZHt0b3A6Y2FsYyh2YXIoLS1zaXplLCAxKSoxNCp2YXIoLS1jdXJzb3ItbGluZSwgMCkqMXB4KX0uY21kIC5pbnZlcnRlZCwudGVybWluYWwgLmludmVydGVke2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3IsI2FhYSk7Y29sb3I6dmFyKC0tYmFja2dyb3VuZCwjMDAwKX0uY21kIGRpdnttaW4taGVpZ2h0OmNhbGModmFyKC0tc2l6ZSwgMSkqMTRweCl9LmNtZCAuY21kLWN1cnNvci5jbWQtYmxpbmt7Y29sb3I6dmFyKC0tY29sb3IsI2FhYSk7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1iYWNrZ3JvdW5kLCMwMDApfS5jbWQgLmNtZC1jdXJzb3IuY21kLWJsaW5rIC5lbW9qaSwuY21kIC5jbWQtY3Vyc29yLmNtZC1ibGluayBhLC5jbWQgLmNtZC1jdXJzb3IuY21kLWJsaW5rIHNwYW46bm90KC5lbW9qaSkgc3Bhbnstd2Via2l0LWFuaW1hdGlvbjp2YXIoLS1hbmltYXRpb24sdGVybWluYWwtYmxpbmspIDFzIGluZmluaXRlIGxpbmVhcjstbW96LWFuaW1hdGlvbjp2YXIoLS1hbmltYXRpb24sdGVybWluYWwtYmxpbmspIDFzIGluZmluaXRlIGxpbmVhcjstbXMtYW5pbWF0aW9uOnZhcigtLWFuaW1hdGlvbix0ZXJtaW5hbC1ibGluaykgMXMgaW5maW5pdGUgbGluZWFyO2FuaW1hdGlvbjp2YXIoLS1hbmltYXRpb24sdGVybWluYWwtYmxpbmspIDFzIGluZmluaXRlIGxpbmVhcn0uY21kIC5jbWQtY3Vyc29yLmNtZC1ibGluayAuZW1vamkgc3Bhbntjb2xvcjp0cmFuc3BhcmVudH0uY21kIC5jbWQtcHJvbXB0IHNwYW46Oi1tb3otc2VsZWN0aW9uLC5jbWQ+ZGl2OjotbW96LXNlbGVjdGlvbiwuY21kPmRpdiBzcGFuOjotbW96LXNlbGVjdGlvbiwuY21kPnNwYW46Oi1tb3otc2VsZWN0aW9uLC5jbWQ+c3BhbiBzcGFuOjotbW96LXNlbGVjdGlvbiwuY21kIGRpdjo6LW1vei1zZWxlY3Rpb24sLnRlcm1pbmFsIC50ZXJtaW5hbC1vdXRwdXQgZGl2IGRpdjo6LW1vei1zZWxlY3Rpb24sLnRlcm1pbmFsIC50ZXJtaW5hbC1vdXRwdXQgZGl2IHNwYW46Oi1tb3otc2VsZWN0aW9uLC50ZXJtaW5hbCBoMTo6LW1vei1zZWxlY3Rpb24sLnRlcm1pbmFsIGgyOjotbW96LXNlbGVjdGlvbiwudGVybWluYWwgaDM6Oi1tb3otc2VsZWN0aW9uLC50ZXJtaW5hbCBoNDo6LW1vei1zZWxlY3Rpb24sLnRlcm1pbmFsIGg1OjotbW96LXNlbGVjdGlvbiwudGVybWluYWwgaDY6Oi1tb3otc2VsZWN0aW9uLC50ZXJtaW5hbCBwcmU6Oi1tb3otc2VsZWN0aW9uLC50ZXJtaW5hbCB0ZDo6LW1vei1zZWxlY3Rpb257YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvciwjYWFhKTtjb2xvcjp2YXIoLS1iYWNrZ3JvdW5kLCMwMDApfS50ZXJtaW5hbCAudGVybWluYWwtb3V0cHV0IGRpdiBkaXYgYTo6LW1vei1zZWxlY3Rpb257YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1saW5rLWNvbG9yLHJnYmEoMTUsOTYsMjU1LC45OSkpIWltcG9ydGFudDtjb2xvcjp2YXIoLS1iYWNrZ3JvdW5kLCMwMDApIWltcG9ydGFudH0udGVybWluYWwgLnRlcm1pbmFsLW91dHB1dCBkaXYgZGl2IGE6aG92ZXI6Oi1tb3otc2VsZWN0aW9ue2JhY2tncm91bmQtY29sb3I6dmFyKC0tbGluay1jb2xvcixyZ2JhKDIsNTAsMTQ0LC45OSkpIWltcG9ydGFudH0uY21kIC5jbWQtcHJvbXB0IHNwYW46OnNlbGVjdGlvbiwuY21kPmRpdjo6c2VsZWN0aW9uLC5jbWQ+ZGl2IHNwYW46OnNlbGVjdGlvbiwuY21kPnNwYW46OnNlbGVjdGlvbiwuY21kPnNwYW4gc3Bhbjo6c2VsZWN0aW9uLC5jbWQgZGl2OjpzZWxlY3Rpb24sLnRlcm1pbmFsIC50ZXJtaW5hbC1vdXRwdXQgZGl2IGRpdjo6c2VsZWN0aW9uLC50ZXJtaW5hbCAudGVybWluYWwtb3V0cHV0IGRpdiBzcGFuOjpzZWxlY3Rpb24sLnRlcm1pbmFsIGgxOjpzZWxlY3Rpb24sLnRlcm1pbmFsIGgyOjpzZWxlY3Rpb24sLnRlcm1pbmFsIGgzOjpzZWxlY3Rpb24sLnRlcm1pbmFsIGg0OjpzZWxlY3Rpb24sLnRlcm1pbmFsIGg1OjpzZWxlY3Rpb24sLnRlcm1pbmFsIGg2OjpzZWxlY3Rpb24sLnRlcm1pbmFsIHByZTo6c2VsZWN0aW9uLC50ZXJtaW5hbCB0ZDo6c2VsZWN0aW9ue2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3IsaHNsYSgwLDAlLDY2LjclLC45OSkpIWltcG9ydGFudDtjb2xvcjp2YXIoLS1iYWNrZ3JvdW5kLCMwMDApIWltcG9ydGFudH0udGVybWluYWwgLnRlcm1pbmFsLW91dHB1dCBkaXYgZGl2IGE6OnNlbGVjdGlvbntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWxpbmstY29sb3IscmdiYSgxNSw5NiwyNTUsLjk5KSkhaW1wb3J0YW50O2NvbG9yOnZhcigtLWJhY2tncm91bmQsIzAwMCkhaW1wb3J0YW50fS50ZXJtaW5hbCAudGVybWluYWwtb3V0cHV0IGRpdiBkaXYgYTpob3Zlcjo6c2VsZWN0aW9ue2JhY2tncm91bmQtY29sb3I6dmFyKC0tbGluay1jb2xvcixyZ2JhKDIsNTAsMTQ0LC45OSkpIWltcG9ydGFudH19QHN1cHBvcnRzICgtbXMtaW1lLWFsaWduOmF1dG8pey5jbWQgLnByb21wdCBzcGFuOjpzZWxlY3Rpb24sLmNtZD5kaXY6OnNlbGVjdGlvbiwuY21kPmRpdiBzcGFuOjpzZWxlY3Rpb24sLmNtZD5zcGFuOjpzZWxlY3Rpb24sLmNtZD5zcGFuIHNwYW46OnNlbGVjdGlvbiwuY21kIGRpdjo6c2VsZWN0aW9uLC50ZXJtaW5hbCAudGVybWluYWwtb3V0cHV0IGRpdiBkaXY6OnNlbGVjdGlvbiwudGVybWluYWwgLnRlcm1pbmFsLW91dHB1dCBkaXYgZGl2IGE6OnNlbGVjdGlvbiwudGVybWluYWwgLnRlcm1pbmFsLW91dHB1dCBkaXYgc3Bhbjo6c2VsZWN0aW9uLC50ZXJtaW5hbCBoMTo6c2VsZWN0aW9uLC50ZXJtaW5hbCBoMjo6c2VsZWN0aW9uLC50ZXJtaW5hbCBoMzo6c2VsZWN0aW9uLC50ZXJtaW5hbCBoNDo6c2VsZWN0aW9uLC50ZXJtaW5hbCBoNTo6c2VsZWN0aW9uLC50ZXJtaW5hbCBoNjo6c2VsZWN0aW9uLC50ZXJtaW5hbCBwcmU6OnNlbGVjdGlvbiwudGVybWluYWwgdGQ6OnNlbGVjdGlvbntiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMCwwJSw2Ni43JSwuOTkpO2NvbG9yOiMwMDB9fS5jbWQgLnN0eWxlIC50b2tlbi5zdHJpbmcsLmNtZCAudG9rZW4uZW50aXR5LC5jbWQgLnRva2VuLm9wZXJhdG9yLC5jbWQgLnRva2VuLnN0cmluZywuY21kIC50b2tlbi50b2tlbiwuY21kIC50b2tlbi51cmwsLmNtZCAudG9rZW4udmFyaWFibGUsLnRlcm1pbmFsIC5zdHlsZSAudG9rZW4uc3RyaW5nLC50ZXJtaW5hbCAudG9rZW4uZW50aXR5LC50ZXJtaW5hbCAudG9rZW4ub3BlcmF0b3IsLnRlcm1pbmFsIC50b2tlbi5zdHJpbmcsLnRlcm1pbmFsIC50b2tlbi50b2tlbiwudGVybWluYWwgLnRva2VuLnVybCwudGVybWluYWwgLnRva2VuLnZhcmlhYmxle2JhY2tncm91bmQtY29sb3I6aW5oZXJpdH0uY21kIC5jdXJzb3Itd3JhcHBlciB1bHtsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowO2Zsb2F0OmxlZnQ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjE0cHg7bGVmdDowfS5jbWQgLmN1cnNvci13cmFwcGVyIGxpe2N1cnNvcjpwb2ludGVyO3doaXRlLXNwYWNlOm5vd3JhcH0uY21kIC5jdXJzb3Itd3JhcHBlciBsaTpob3ZlcntiYWNrZ3JvdW5kOiNhYWE7Y29sb3I6IzAwMH0uY3Vyc29yLXdyYXBwZXJ7cG9zaXRpb246cmVsYXRpdmV9LnRlcm1pbmFsLW91dHB1dCBkaXZbc3R5bGUqPVxcXCIxMDAlO1xcXCJde292ZXJmbG93OmhpZGRlbn0udGVybWluYWwtb3V0cHV0IGltZ3tkaXNwbGF5OmJsb2NrfS5jbWQgaW1ne2hlaWdodDoxNHB4O2hlaWdodDpjYWxjKHZhcigtLXNpemUsIDEpKjE0cHgpO2JvcmRlcjoxcHggc29saWQgdHJhbnNwYXJlbnR9LmNtZC1jdXJzb3IgaW1ne2JvcmRlci1jb2xvcjojY2NjO2JvcmRlci1jb2xvcjp2YXIoLS1jb2xvciwjY2NjKX0udGVybWluYWwtb3V0cHV0IHN2Zy50ZXJtaW5hbC1icm9rZW4taW1hZ2V7aGVpZ2h0OmNhbGModmFyKC0tc2l6ZSwgMSkqMTRweCl9LnRlcm1pbmFsLW91dHB1dCBzdmcudGVybWluYWwtYnJva2VuLWltYWdlIHVzZXtmaWxsOnZhcigtLWNvbG9yLCNjY2MpfS50ZXJtaW5hbC1lcnJvcnstLWNvbG9yOnZhcigtLWVycm9yLWNvbG9yKX0udGVybWluYWwtZ2xvd3stLWFuaW1hdGlvbjp0ZXJtaW5hbC1nbG93fS50ZXJtaW5hbC1nbG93IC5jbWQtcHJvbXB0PnNwYW4sLnRlcm1pbmFsLWdsb3cgLnRlcm1pbmFsLW91dHB1dD5kaXYgYVtocmVmXSwudGVybWluYWwtZ2xvdyAudGVybWluYWwtb3V0cHV0PmRpdiBzcGFuLC50ZXJtaW5hbC1nbG93IFtkYXRhLXRleHRdIHNwYW4sLnRlcm1pbmFsLWdsb3cgYVtkYXRhLXRleHRdLC50ZXJtaW5hbC1nbG93IHNwYW5bZGF0YS10ZXh0XXt0ZXh0LXNoYWRvdzoxcHggMXB4IDVweCAjY2NjO3RleHQtc2hhZG93OjFweCAxcHggNXB4IHZhcigtLWNvbG9yLCNjY2MpfS50ZXJtaW5hbC1zY3JvbGwtbWFya2Vye3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoxcHg7bWFyZ2luLXRvcDotMXB4O3otaW5kZXg6MTAwfS50ZXJtaW5hbC1zY3JvbGwtbWFya2VyIGRpdntwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDtsZWZ0OjA7cmlnaHQ6MDt6LWluZGV4OjIwMH1cIiwgXCJcIl0pO1xuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./node_modules/jquery.terminal/css/jquery.terminal.min.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"@keyframes turn-on {\\r\\n    0% {\\r\\n        transform: scale(1, 0.8) translate3d(0, 0, 0);\\r\\n        -webkit-filter: brightness(30);\\r\\n        filter: brightness(30);\\r\\n        opacity: 1;\\r\\n    }\\r\\n    3.5% {\\r\\n        transform: scale(1, 0.8) translate3d(0, 100%, 0);\\r\\n    }\\r\\n    3.6% {\\r\\n        transform: scale(1, 0.8) translate3d(0, -100%, 0);\\r\\n        opacity: 1;\\r\\n    }\\r\\n    9% {\\r\\n        transform: scale(1.3, 0.6) translate3d(0, 100%, 0);\\r\\n        -webkit-filter: brightness(30);\\r\\n        filter: brightness(30);\\r\\n        opacity: 0;\\r\\n    }\\r\\n    11% {\\r\\n        transform: scale(1, 1) translate3d(0, 0, 0);\\r\\n        -webkit-filter: contrast(0) brightness(0);\\r\\n        filter: contrast(0) brightness(0);\\r\\n        opacity: 0;\\r\\n    }\\r\\n    100% {\\r\\n        transform: scale(1, 1) translate3d(0, 0, 0);\\r\\n        -webkit-filter: contrast(1) brightness(1.2) saturate(1.3);\\r\\n        filter: contrast(1) brightness(1.2) saturate(1.3);\\r\\n        opacity: 1;\\r\\n    }\\r\\n}\\r\\n\\r\\n@keyframes flicker2 {\\r\\n    0% {\\r\\n        opacity: 0.38927;\\r\\n    }\\r\\n    5% {\\r\\n        opacity: 0.62502;\\r\\n    }\\r\\n    10% {\\r\\n        opacity: 0.94529;\\r\\n    }\\r\\n    15% {\\r\\n        opacity: 0.14426;\\r\\n    }\\r\\n    20% {\\r\\n        opacity: 0.2296;\\r\\n    }\\r\\n    25% {\\r\\n        opacity: 0.58552;\\r\\n    }\\r\\n    30% {\\r\\n        opacity: 0.59122;\\r\\n    }\\r\\n    35% {\\r\\n        opacity: 0.37027;\\r\\n    }\\r\\n    40% {\\r\\n        opacity: 0.93926;\\r\\n    }\\r\\n    45% {\\r\\n        opacity: 0.53982;\\r\\n    }\\r\\n    50% {\\r\\n        opacity: 0.20993;\\r\\n    }\\r\\n    55% {\\r\\n        opacity: 0.22968;\\r\\n    }\\r\\n    60% {\\r\\n        opacity: 0.64527;\\r\\n    }\\r\\n    65% {\\r\\n        opacity: 0.46829;\\r\\n    }\\r\\n    70% {\\r\\n        opacity: 0.0417;\\r\\n    }\\r\\n    75% {\\r\\n        opacity: 0.02899;\\r\\n    }\\r\\n    80% {\\r\\n        opacity: 0.3248;\\r\\n    }\\r\\n    85% {\\r\\n        opacity: 0.71195;\\r\\n    }\\r\\n    90% {\\r\\n        opacity: 0.29669;\\r\\n    }\\r\\n    95% {\\r\\n        opacity: 0.43819;\\r\\n    }\\r\\n    100% {\\r\\n        opacity: 0.1918;\\r\\n    }\\r\\n}\\r\\n\\r\\n@keyframes turn-on {\\r\\n    0% {\\r\\n        transform: scale(1, 0.8) translate3d(0, 0, 0);\\r\\n        -webkit-filter: brightness(30);\\r\\n        filter: brightness(30);\\r\\n        opacity: 1;\\r\\n    }\\r\\n    3.5% {\\r\\n        transform: scale(1, 0.8) translate3d(0, 100%, 0);\\r\\n    }\\r\\n    3.6% {\\r\\n        transform: scale(1, 0.8) translate3d(0, -100%, 0);\\r\\n        opacity: 1;\\r\\n    }\\r\\n    9% {\\r\\n        transform: scale(1.3, 0.6) translate3d(0, 100%, 0);\\r\\n        -webkit-filter: brightness(30);\\r\\n        filter: brightness(30);\\r\\n        opacity: 0;\\r\\n    }\\r\\n    11% {\\r\\n        transform: scale(1, 1) translate3d(0, 0, 0);\\r\\n        -webkit-filter: contrast(0) brightness(0);\\r\\n        filter: contrast(0) brightness(0);\\r\\n        opacity: 0;\\r\\n    }\\r\\n    100% {\\r\\n        transform: scale(1, 1) translate3d(0, 0, 0);\\r\\n        -webkit-filter: contrast(1) brightness(1.2) saturate(1.3);\\r\\n        filter: contrast(1) brightness(1.2) saturate(1.3);\\r\\n        opacity: 1;\\r\\n    }\\r\\n}\\r\\n@keyframes overlay-anim {\\r\\n    0% {\\r\\n        visibility: hidden;\\r\\n    }\\r\\n    20% {\\r\\n        visibility: hidden;\\r\\n    }\\r\\n    21% {\\r\\n        visibility: visible;\\r\\n    }\\r\\n    100% {\\r\\n        visibility: hidden;\\r\\n    }\\r\\n}\\r\\n.overlay {\\r\\n    color: #00FF00;\\r\\n    position: absolute;\\r\\n    top: 10px;\\r\\n    left: 0px;\\r\\n    font-size: 60px;\\r\\n    visibility: hidden;\\r\\n    pointer-events: none;\\r\\n}\\r\\n\\r\\n\\r\\n#term::after{\\r\\n    animation: turn-on 4s linear;\\r\\n    animation-fill-mode: forwards;\\r\\n}\\r\\n\\r\\n\\r\\n.terminal-output div:first-child div span {\\r\\n    display: block;\\r\\n    margin: 0px;\\r\\n    font-family: 'Courier New', monospace;\\r\\n    white-space: pre;\\r\\n    background-color: rgba(0, 0, 0, 0) !important;\\r\\n    color: rgb(255, 255, 255) !important;\\r\\n    text-shadow: #0c7b46 0px 3.2px 16px;\\r\\n  }\\r\\n.topnav {\\r\\n    background-color: #cbd0cc;\\r\\n    overflow: hidden;\\r\\n}\\r\\n#exitBar{\\r\\n    background-color: #555a56;\\r\\n    height:16px;\\r\\n    width: 100vw;\\r\\n}\\r\\n/* Style the links inside the navigation bar */\\r\\n.topnav a {\\r\\n    float: left;\\r\\n    color: #2b2b2b;\\r\\n    text-align: center;\\r\\n    padding: 8px 16px;\\r\\n    text-decoration: none;\\r\\n    font-size: 16px;\\r\\n    font-weight: bolder;\\r\\n}\\r\\n\\r\\n/* Change the color of links on hover */\\r\\n.topnav a:hover {\\r\\n    background-color: #414041;\\r\\n    color: #0c7b46;\\r\\n}\\r\\n\\r\\n/* Add a color to the active/current link */\\r\\n.topnav a.active {\\r\\n    background-color: #414041;\\r\\n    color: #0c7b46;\\r\\n}\\r\\n\\r\\n\\r\\n.dropdown {\\r\\n    float: left;\\r\\n    overflow: hidden;\\r\\n    border: 1px solid #b2b7b3;\\r\\n    margin-right: 2px;\\r\\n}\\r\\n\\r\\n/* Dropdown button */\\r\\n.dropdown .dropbtn {\\r\\n    font-size: 14px;\\r\\n    border: none;\\r\\n    outline: none;\\r\\n    color: #2b2b2b;\\r\\n    font-weight: bold;\\r\\n    padding: 5px 16px;\\r\\n    background-color: inherit;\\r\\n    font-family: inherit; /* Important for vertical align on mobile phones */\\r\\n    margin: 0; /* Important for vertical align on mobile phones */\\r\\n}\\r\\n\\r\\n/* Add a red background color to navbar links on hover */\\r\\n.topnav a:hover, .dropdown:hover .dropbtn {\\r\\n    background-color: #414041;\\r\\n    color: #0c7b46;\\r\\n}\\r\\n\\r\\n/* Dropdown content (hidden by default) */\\r\\n.dropdown-content {\\r\\n    display: none;\\r\\n    position: absolute;\\r\\n    background-color: #cbd0cc;\\r\\n    min-width: 160px;\\r\\n    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);\\r\\n    z-index: 1;\\r\\n}\\r\\n\\r\\n/* Links inside the dropdown */\\r\\n.dropdown-content a {\\r\\n    float: none;\\r\\n    color: black;\\r\\n    padding: 12px 16px;\\r\\n    text-decoration: none;\\r\\n    display: block;\\r\\n    text-align: left;\\r\\n    font-size:12px;\\r\\n}\\r\\n\\r\\n/* Add a grey background color to dropdown links on hover */\\r\\n.dropdown-content a:hover {\\r\\n    background-color: #ddd;\\r\\n}\\r\\n\\r\\n/* Show the dropdown menu on hover */\\r\\n.dropdown:hover .dropdown-content {\\r\\n    display: block;\\r\\n}\\r\\n#exitBar{\\r\\n    padding-left:5px;\\r\\n    padding-top:2px;\\r\\n}\\r\\n#img1 {\\r\\n    height: 15px;\\r\\n}\\r\\n#img2 {\\r\\n    height: 15px;\\r\\n}\\r\\n#img3 {\\r\\n    height: 15px;\\r\\n}\\r\\n.img4 {\\r\\n    top: 17px;\\r\\n    height: 31px;\\r\\n    position: fixed;\\r\\n    right: 1vw;\\r\\n    cursor: pointer;\\r\\n}\\r\\n.img5{\\r\\n    top: 17px;\\r\\n    height: 31px;\\r\\n    position: fixed;\\r\\n    right: 1vw;\\r\\n    cursor: pointer;\\r\\n}\\r\\n\\r\\n.img4:hover {\\r\\n    background-color: #6e736f;\\r\\n}\\r\\n.img5:hover {\\r\\n    background-color: #6e736f;\\r\\n}\\r\\nbody {\\r\\n    margin: 0;\\r\\n    background: black;\\r\\n    overflow-y: hidden;\\r\\n}\\r\\n\\r\\n#term {\\r\\n\\r\\n    height: 95vh;\\r\\n    --background: #031e11;\\r\\n    --size: 1.5;\\r\\n    border-left: 7px solid #cbd0cc;\\r\\n}\\r\\n.old {\\r\\n    height: 95vh;\\r\\n    --background: #031e11;\\r\\n    --size: 1.5;\\r\\n    border-left: 7px solid #cbd0cc;\\r\\n}\\r\\n.old::after {\\r\\n\\r\\n}\\r\\n.runAnim {\\r\\n    content: \\\" \\\";\\r\\n    display: block;\\r\\n    position: fixed;\\r\\n    top: 0;\\r\\n    left: 0;\\r\\n    bottom: 0;\\r\\n    right: 0;\\r\\n    background: rgba(18, 16, 16, 0.2);\\r\\n    opacity: 0;\\r\\n    z-index: 2;\\r\\n    pointer-events: none;\\r\\n    animation: turn-on 8s linear;\\r\\n}\\r\\n\\r\\n/* to see yourself like in a mirror */\\r\\n.self {\\r\\n    transform: scale(-1, 1);\\r\\n}\\r\\n\\r\\n/* flicker animation taken from http://goonhub.com/secret */\\r\\n#term::after {\\r\\n    content: \\\" \\\";\\r\\n    display: block;\\r\\n    position: fixed;\\r\\n    top: 0;\\r\\n    left: 0;\\r\\n    bottom: 0;\\r\\n    right: 0;\\r\\n    background: rgba(18, 16, 16, 0.2);\\r\\n    opacity: 0;\\r\\n    z-index: 2;\\r\\n    pointer-events: none;\\r\\n    animation: flicker 0.12s infinite;\\r\\n}\\r\\n\\r\\n@keyframes flicker {\\r\\n    0% {\\r\\n        opacity: 0.552;\\r\\n    }\\r\\n\\r\\n    5% {\\r\\n        opacity: 0.48287;\\r\\n    }\\r\\n\\r\\n    10% {\\r\\n        opacity: 0.59134;\\r\\n    }\\r\\n\\r\\n    15.0% {\\r\\n        opacity: 0.79543;\\r\\n    }\\r\\n\\r\\n    20% {\\r\\n        opacity: 0.75134;\\r\\n    }\\r\\n\\r\\n    25% {\\r\\n        opacity: 0.1956;\\r\\n    }\\r\\n\\r\\n    30.0% {\\r\\n        opacity: 0.90687;\\r\\n    }\\r\\n\\r\\n    35% {\\r\\n        opacity: 0.122;\\r\\n    }\\r\\n\\r\\n    40% {\\r\\n        opacity: 0.62254;\\r\\n    }\\r\\n\\r\\n    45% {\\r\\n        opacity: 0.56977;\\r\\n    }\\r\\n\\r\\n    50% {\\r\\n        opacity: 0.9925;\\r\\n    }\\r\\n\\r\\n    55.0% {\\r\\n        opacity: 0.55487;\\r\\n    }\\r\\n\\r\\n    60.0% {\\r\\n        opacity: 0.16607;\\r\\n    }\\r\\n\\r\\n    65% {\\r\\n        opacity: 0.12353;\\r\\n    }\\r\\n\\r\\n    70% {\\r\\n        opacity: 0.2214;\\r\\n    }\\r\\n\\r\\n    75% {\\r\\n        opacity: 0.67908;\\r\\n    }\\r\\n\\r\\n    80% {\\r\\n        opacity: 0.97163;\\r\\n    }\\r\\n\\r\\n    85.0% {\\r\\n        opacity: 0.1275;\\r\\n    }\\r\\n\\r\\n    90% {\\r\\n        opacity: 0.37186;\\r\\n    }\\r\\n\\r\\n    95% {\\r\\n        opacity: 0.24475;\\r\\n    }\\r\\n\\r\\n    100% {\\r\\n        opacity: 0.37221;\\r\\n    }\\r\\n}\\r\\n\\r\\n/* glow */\\r\\n.terminal {\\r\\n    text-shadow: 0 0.2rem 1rem #0c7b46;\\r\\n}\\r\\n\\r\\n/* based on\\r\\nhttps://blog.carbonfive.com/2015/01/07/vintage-terminal-effect-in-css3/\\r\\n*/\\r\\n.scanlines {\\r\\n    top:45px;\\r\\n    left: 7px;\\r\\n    height: 100%;\\r\\n    width: 100%;\\r\\n    background: linear-gradient(to bottom,\\r\\n    rgba(255, 255, 255, 0),\\r\\n    rgba(255, 255, 255, 0) 50%,\\r\\n    rgba(0, 0, 0, .2) 70%,\\r\\n    rgba(0, 0, 0, .6));\\r\\n    background-size: 100% .3rem;\\r\\n    position: fixed;\\r\\n    pointer-events: none;\\r\\n}\\r\\n\\r\\n.scanlines:before {\\r\\n    position: absolute;\\r\\n    top: 0px;\\r\\n    width: 100%;\\r\\n    height: 5px;\\r\\n    background: #fff;\\r\\n    background: linear-gradient(to bottom,\\r\\n    rgba(255, 0, 0, 0) 0%,\\r\\n    rgba(255, 250, 250, 1) 50%,\\r\\n    rgba(255, 255, 255, 0.98) 51%,\\r\\n    rgba(255, 0, 0, 0) 100%);\\r\\n    /* W3C */\\r\\n    opacity: .1;\\r\\n}\\r\\n\\r\\n.scanlines:after {\\r\\n    box-shadow: 0 2px 6px rgba(25, 25, 25, 0.2),\\r\\n    inset 0 1px rgba(50, 50, 50, 0.1),\\r\\n    inset 0 3px rgba(50, 50, 50, 0.05),\\r\\n    inset 0 3px 8px rgba(64, 64, 64, 0.05),\\r\\n    inset 0 -5px 10px rgba(25, 25, 25, 0.1);\\r\\n}\\r\\n\\r\\n#term:focus-within+.scanlines:before {\\r\\n    content: '';\\r\\n    animation: vline calc(var(--time, 2) * 1s) linear infinite;\\r\\n}\\r\\n\\r\\n/*\\r\\n* MS Edge don't support focus-within and css vars\\r\\n* inside pseudo selector\\r\\n*/\\r\\n@supports (-ms-ime-align:auto) {\\r\\n    .scanlines:before {\\r\\n        content: '';\\r\\n        animation: vline 3s linear infinite;\\r\\n    }\\r\\n}\\r\\n\\r\\n@keyframes vline {\\r\\n    to {\\r\\n        transform: translate(0, 100vh)\\r\\n    }\\r\\n}\\r\\n\\r\\n/* turn off animation */\\r\\n.tv {\\r\\n    height: 100vh;\\r\\n    position: relative;\\r\\n}\\r\\n\\r\\n.tv.collapse {\\r\\n    animation: size 2s ease-out;\\r\\n    animation-fill-mode: forwards;\\r\\n}\\r\\n\\r\\n.tv.collapse:before {\\r\\n    content: '';\\r\\n    display: block;\\r\\n    height: 100%;\\r\\n    position: absolute;\\r\\n    left: 0;\\r\\n    right: 0;\\r\\n    bottom: 0;\\r\\n    top: 0;\\r\\n    background: white;\\r\\n    z-index: 1;\\r\\n    opacity: 0;\\r\\n    animation: opacity 2s ease-out;\\r\\n    animation-fill-mode: forwards;\\r\\n}\\r\\n\\r\\n@keyframes opacity {\\r\\n    to {\\r\\n        opacity: 1;\\r\\n    }\\r\\n}\\r\\n\\r\\n@keyframes size {\\r\\n    50% {\\r\\n        transform: scaleX(calc(1 / var(--width)));\\r\\n        opacity: 1;\\r\\n    }\\r\\n\\r\\n    98% {\\r\\n        transform: scaleX(calc(1 / var(--width))) scaleY(calc(1 / var(--height)));\\r\\n        opacity: 1;\\r\\n    }\\r\\n\\r\\n    100% {\\r\\n        transform: scaleX(calc(1 / var(--width))) scaleY(calc(1 / var(--height)));\\r\\n        opacity: 0;\\r\\n    }\\r\\n}\\r\\n\", \"\"]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzLmNzcz9lOWFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLHFHQUFnRDtBQUNuRjtBQUNBLGNBQWMsUUFBUyx1QkFBdUIsWUFBWSwwREFBMEQsMkNBQTJDLG1DQUFtQyx1QkFBdUIsU0FBUyxjQUFjLDZEQUE2RCxTQUFTLGNBQWMsOERBQThELHVCQUF1QixTQUFTLFlBQVksK0RBQStELDJDQUEyQyxtQ0FBbUMsdUJBQXVCLFNBQVMsYUFBYSx3REFBd0Qsc0RBQXNELDhDQUE4Qyx1QkFBdUIsU0FBUyxjQUFjLHdEQUF3RCxzRUFBc0UsOERBQThELHVCQUF1QixTQUFTLEtBQUssNkJBQTZCLFlBQVksNkJBQTZCLFNBQVMsWUFBWSw2QkFBNkIsU0FBUyxhQUFhLDZCQUE2QixTQUFTLGFBQWEsNkJBQTZCLFNBQVMsYUFBYSw0QkFBNEIsU0FBUyxhQUFhLDZCQUE2QixTQUFTLGFBQWEsNkJBQTZCLFNBQVMsYUFBYSw2QkFBNkIsU0FBUyxhQUFhLDZCQUE2QixTQUFTLGFBQWEsNkJBQTZCLFNBQVMsYUFBYSw2QkFBNkIsU0FBUyxhQUFhLDZCQUE2QixTQUFTLGFBQWEsNkJBQTZCLFNBQVMsYUFBYSw2QkFBNkIsU0FBUyxhQUFhLDRCQUE0QixTQUFTLGFBQWEsNkJBQTZCLFNBQVMsYUFBYSw0QkFBNEIsU0FBUyxhQUFhLDZCQUE2QixTQUFTLGFBQWEsNkJBQTZCLFNBQVMsYUFBYSw2QkFBNkIsU0FBUyxjQUFjLDRCQUE0QixTQUFTLEtBQUssNEJBQTRCLFlBQVksMERBQTBELDJDQUEyQyxtQ0FBbUMsdUJBQXVCLFNBQVMsY0FBYyw2REFBNkQsU0FBUyxjQUFjLDhEQUE4RCx1QkFBdUIsU0FBUyxZQUFZLCtEQUErRCwyQ0FBMkMsbUNBQW1DLHVCQUF1QixTQUFTLGFBQWEsd0RBQXdELHNEQUFzRCw4Q0FBOEMsdUJBQXVCLFNBQVMsY0FBYyx3REFBd0Qsc0VBQXNFLDhEQUE4RCx1QkFB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LEtBQUssOENBQThDLG9CQUFvQixtRUFBbUUsS0FBSyxxSUFBcUksMkJBQTJCLHdCQUF3QixnREFBZ0QsU0FBUyxLQUFLLDBCQUEwQixZQUFZLG1EQUFtRCxLQUFLLHlDQUF5QyxzQkFBc0IsMkJBQTJCLEtBQUssc0JBQXNCLG9DQUFvQyxzQ0FBc0MsS0FBSyw2QkFBNkIsb0JBQW9CLHVCQUF1QixxQkFBcUIsMkJBQTJCLGdCQUFnQixpQkFBaUIsa0JBQWtCLGVBQWUsMEJBQTBCLG1CQUFtQixtQkFBbUIsdUNBQXVDLHNDQUFzQyxLQUFLLDRCQUE0QixZQUFZLHVCQUF1QixTQUFTLEtBQUsseUJBQXlCLGFBQWEsc0RBQXNELHVCQUF1QixTQUFTLGlCQUFpQixzRkFBc0YsdUJBQXVCLFNBQVMsa0JBQWtCLHNGQUFzRix1QkFBdUIsU0FBUyxLQUFLIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zcmMvc3R5bGVzLmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGtleWZyYW1lcyB0dXJuLW9uIHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLCAwLjgpIHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcclxcbiAgICAgICAgLXdlYmtpdC1maWx0ZXI6IGJyaWdodG5lc3MoMzApO1xcclxcbiAgICAgICAgZmlsdGVyOiBicmlnaHRuZXNzKDMwKTtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDE7XFxyXFxuICAgIH1cXHJcXG4gICAgMy41JSB7XFxyXFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEsIDAuOCkgdHJhbnNsYXRlM2QoMCwgMTAwJSwgMCk7XFxyXFxuICAgIH1cXHJcXG4gICAgMy42JSB7XFxyXFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEsIDAuOCkgdHJhbnNsYXRlM2QoMCwgLTEwMCUsIDApO1xcclxcbiAgICAgICAgb3BhY2l0eTogMTtcXHJcXG4gICAgfVxcclxcbiAgICA5JSB7XFxyXFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMywgMC42KSB0cmFuc2xhdGUzZCgwLCAxMDAlLCAwKTtcXHJcXG4gICAgICAgIC13ZWJraXQtZmlsdGVyOiBicmlnaHRuZXNzKDMwKTtcXHJcXG4gICAgICAgIGZpbHRlcjogYnJpZ2h0bmVzcygzMCk7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwO1xcclxcbiAgICB9XFxyXFxuICAgIDExJSB7XFxyXFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEsIDEpIHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcclxcbiAgICAgICAgLXdlYmtpdC1maWx0ZXI6IGNvbnRyYXN0KDApIGJyaWdodG5lc3MoMCk7XFxyXFxuICAgICAgICBmaWx0ZXI6IGNvbnRyYXN0KDApIGJyaWdodG5lc3MoMCk7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwO1xcclxcbiAgICB9XFxyXFxuICAgIDEwMCUge1xcclxcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLCAxKSB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcXHJcXG4gICAgICAgIC13ZWJraXQtZmlsdGVyOiBjb250cmFzdCgxKSBicmlnaHRuZXNzKDEuMikgc2F0dXJhdGUoMS4zKTtcXHJcXG4gICAgICAgIGZpbHRlcjogY29udHJhc3QoMSkgYnJpZ2h0bmVzcygxLjIpIHNhdHVyYXRlKDEuMyk7XFxyXFxuICAgICAgICBvcGFjaXR5OiAxO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgZmxpY2tlcjIge1xcclxcbiAgICAwJSB7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwLjM4OTI3O1xcclxcbiAgICB9XFxyXFxuICAgIDUlIHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDAuNjI1MDI7XFxyXFxuICAgIH1cXHJcXG4gICAgMTAlIHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDAuOTQ1Mjk7XFxyXFxuICAgIH1cXHJcXG4gICAgMTUlIHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDAuMTQ0MjY7XFxyXFxuICAgIH1cXHJcXG4gICAgMjAlIHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDAuMjI5NjtcXHJcXG4gICAgfVxcclxcbiAgICAyNSUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC41ODU1MjtcXHJcXG4gICAgfVxcclxcbiAgICAzMCUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC41OTEyMjtcXHJcXG4gICAgfVxcclxcbiAgICAzNSUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC4zNzAyNztcXHJcXG4gICAgfVxcclxcbiAgICA0MCUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC45MzkyNjtcXHJcXG4gICAgfVxcclxcbiAgICA0NSUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC41Mzk4MjtcXHJcXG4gICAgfVxcclxcbiAgICA1MCUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC4yMDk5MztcXHJcXG4gICAgfVxcclxcbiAgICA1NSUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC4yMjk2ODtcXHJcXG4gICAgfVxcclxcbiAgICA2MCUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC42NDUyNztcXHJcXG4gICAgfVxcclxcbiAgICA2NSUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC40NjgyOTtcXHJcXG4gICAgfVxcclxcbiAgICA3MCUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC4wNDE3O1xcclxcbiAgICB9XFxyXFxuICAgIDc1JSB7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwLjAyODk5O1xcclxcbiAgICB9XFxyXFxuICAgIDgwJSB7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwLjMyNDg7XFxyXFxuICAgIH1cXHJcXG4gICAgODUlIHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDAuNzExOTU7XFxyXFxuICAgIH1cXHJcXG4gICAgOTAlIHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDAuMjk2Njk7XFxyXFxuICAgIH1cXHJcXG4gICAgOTUlIHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDAuNDM4MTk7XFxyXFxuICAgIH1cXHJcXG4gICAgMTAwJSB7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwLjE5MTg7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyB0dXJuLW9uIHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLCAwLjgpIHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcclxcbiAgICAgICAgLXdlYmtpdC1maWx0ZXI6IGJyaWdodG5lc3MoMzApO1xcclxcbiAgICAgICAgZmlsdGVyOiBicmlnaHRuZXNzKDMwKTtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDE7XFxyXFxuICAgIH1cXHJcXG4gICAgMy41JSB7XFxyXFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEsIDAuOCkgdHJhbnNsYXRlM2QoMCwgMTAwJSwgMCk7XFxyXFxuICAgIH1cXHJcXG4gICAgMy42JSB7XFxyXFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEsIDAuOCkgdHJhbnNsYXRlM2QoMCwgLTEwMCUsIDApO1xcclxcbiAgICAgICAgb3BhY2l0eTogMTtcXHJcXG4gICAgfVxcclxcbiAgICA5JSB7XFxyXFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMywgMC42KSB0cmFuc2xhdGUzZCgwLCAxMDAlLCAwKTtcXHJcXG4gICAgICAgIC13ZWJraXQtZmlsdGVyOiBicmlnaHRuZXNzKDMwKTtcXHJcXG4gICAgICAgIGZpbHRlcjogYnJpZ2h0bmVzcygzMCk7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwO1xcclxcbiAgICB9XFxyXFxuICAgIDExJSB7XFxyXFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEsIDEpIHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcclxcbiAgICAgICAgLXdlYmtpdC1maWx0ZXI6IGNvbnRyYXN0KDApIGJyaWdodG5lc3MoMCk7XFxyXFxuICAgICAgICBmaWx0ZXI6IGNvbnRyYXN0KDApIGJyaWdodG5lc3MoMCk7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwO1xcclxcbiAgICB9XFxyXFxuICAgIDEwMCUge1xcclxcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLCAxKSB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcXHJcXG4gICAgICAgIC13ZWJraXQtZmlsdGVyOiBjb250cmFzdCgxKSBicmlnaHRuZXNzKDEuMikgc2F0dXJhdGUoMS4zKTtcXHJcXG4gICAgICAgIGZpbHRlcjogY29udHJhc3QoMSkgYnJpZ2h0bmVzcygxLjIpIHNhdHVyYXRlKDEuMyk7XFxyXFxuICAgICAgICBvcGFjaXR5OiAxO1xcclxcbiAgICB9XFxyXFxufVxcclxcbkBrZXlmcmFtZXMgb3ZlcmxheS1hbmltIHtcXHJcXG4gICAgMCUge1xcclxcbiAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcclxcbiAgICB9XFxyXFxuICAgIDIwJSB7XFxyXFxuICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxyXFxuICAgIH1cXHJcXG4gICAgMjElIHtcXHJcXG4gICAgICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxyXFxuICAgIH1cXHJcXG4gICAgMTAwJSB7XFxyXFxuICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuLm92ZXJsYXkge1xcclxcbiAgICBjb2xvcjogIzAwRkYwMDtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICB0b3A6IDEwcHg7XFxyXFxuICAgIGxlZnQ6IDBweDtcXHJcXG4gICAgZm9udC1zaXplOiA2MHB4O1xcclxcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG4jdGVybTo6YWZ0ZXJ7XFxyXFxuICAgIGFuaW1hdGlvbjogdHVybi1vbiA0cyBsaW5lYXI7XFxyXFxuICAgIGFuaW1hdGlvbi1maWxsLW1vZGU6IGZvcndhcmRzO1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG4udGVybWluYWwtb3V0cHV0IGRpdjpmaXJzdC1jaGlsZCBkaXYgc3BhbiB7XFxyXFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgICBtYXJnaW46IDBweDtcXHJcXG4gICAgZm9udC1mYW1pbHk6ICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZTtcXHJcXG4gICAgd2hpdGUtc3BhY2U6IHByZTtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKSAhaW1wb3J0YW50O1xcclxcbiAgICBjb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpICFpbXBvcnRhbnQ7XFxyXFxuICAgIHRleHQtc2hhZG93OiAjMGM3YjQ2IDBweCAzLjJweCAxNnB4O1xcclxcbiAgfVxcclxcbi50b3BuYXYge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2JkMGNjO1xcclxcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbn1cXHJcXG4jZXhpdEJhcntcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzU1NWE1NjtcXHJcXG4gICAgaGVpZ2h0OjE2cHg7XFxyXFxuICAgIHdpZHRoOiAxMDB2dztcXHJcXG59XFxyXFxuLyogU3R5bGUgdGhlIGxpbmtzIGluc2lkZSB0aGUgbmF2aWdhdGlvbiBiYXIgKi9cXHJcXG4udG9wbmF2IGEge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG4gICAgY29sb3I6ICMyYjJiMmI7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gICAgcGFkZGluZzogOHB4IDE2cHg7XFxyXFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG4gICAgZm9udC1zaXplOiAxNnB4O1xcclxcbiAgICBmb250LXdlaWdodDogYm9sZGVyO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBDaGFuZ2UgdGhlIGNvbG9yIG9mIGxpbmtzIG9uIGhvdmVyICovXFxyXFxuLnRvcG5hdiBhOmhvdmVyIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzQxNDA0MTtcXHJcXG4gICAgY29sb3I6ICMwYzdiNDY7XFxyXFxufVxcclxcblxcclxcbi8qIEFkZCBhIGNvbG9yIHRvIHRoZSBhY3RpdmUvY3VycmVudCBsaW5rICovXFxyXFxuLnRvcG5hdiBhLmFjdGl2ZSB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM0MTQwNDE7XFxyXFxuICAgIGNvbG9yOiAjMGM3YjQ2O1xcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG4uZHJvcGRvd24ge1xcclxcbiAgICBmbG9hdDogbGVmdDtcXHJcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2IyYjdiMztcXHJcXG4gICAgbWFyZ2luLXJpZ2h0OiAycHg7XFxyXFxufVxcclxcblxcclxcbi8qIERyb3Bkb3duIGJ1dHRvbiAqL1xcclxcbi5kcm9wZG93biAuZHJvcGJ0biB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXHJcXG4gICAgYm9yZGVyOiBub25lO1xcclxcbiAgICBvdXRsaW5lOiBub25lO1xcclxcbiAgICBjb2xvcjogIzJiMmIyYjtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxuICAgIHBhZGRpbmc6IDVweCAxNnB4O1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcclxcbiAgICBmb250LWZhbWlseTogaW5oZXJpdDsgLyogSW1wb3J0YW50IGZvciB2ZXJ0aWNhbCBhbGlnbiBvbiBtb2JpbGUgcGhvbmVzICovXFxyXFxuICAgIG1hcmdpbjogMDsgLyogSW1wb3J0YW50IGZvciB2ZXJ0aWNhbCBhbGlnbiBvbiBtb2JpbGUgcGhvbmVzICovXFxyXFxufVxcclxcblxcclxcbi8qIEFkZCBhIHJlZCBiYWNrZ3JvdW5kIGNvbG9yIHRvIG5hdmJhciBsaW5rcyBvbiBob3ZlciAqL1xcclxcbi50b3BuYXYgYTpob3ZlciwgLmRyb3Bkb3duOmhvdmVyIC5kcm9wYnRuIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzQxNDA0MTtcXHJcXG4gICAgY29sb3I6ICMwYzdiNDY7XFxyXFxufVxcclxcblxcclxcbi8qIERyb3Bkb3duIGNvbnRlbnQgKGhpZGRlbiBieSBkZWZhdWx0KSAqL1xcclxcbi5kcm9wZG93bi1jb250ZW50IHtcXHJcXG4gICAgZGlzcGxheTogbm9uZTtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2JkMGNjO1xcclxcbiAgICBtaW4td2lkdGg6IDE2MHB4O1xcclxcbiAgICBib3gtc2hhZG93OiAwcHggOHB4IDE2cHggMHB4IHJnYmEoMCwwLDAsMC4yKTtcXHJcXG4gICAgei1pbmRleDogMTtcXHJcXG59XFxyXFxuXFxyXFxuLyogTGlua3MgaW5zaWRlIHRoZSBkcm9wZG93biAqL1xcclxcbi5kcm9wZG93bi1jb250ZW50IGEge1xcclxcbiAgICBmbG9hdDogbm9uZTtcXHJcXG4gICAgY29sb3I6IGJsYWNrO1xcclxcbiAgICBwYWRkaW5nOiAxMnB4IDE2cHg7XFxyXFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxyXFxuICAgIGZvbnQtc2l6ZToxMnB4O1xcclxcbn1cXHJcXG5cXHJcXG4vKiBBZGQgYSBncmV5IGJhY2tncm91bmQgY29sb3IgdG8gZHJvcGRvd24gbGlua3Mgb24gaG92ZXIgKi9cXHJcXG4uZHJvcGRvd24tY29udGVudCBhOmhvdmVyIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2RkZDtcXHJcXG59XFxyXFxuXFxyXFxuLyogU2hvdyB0aGUgZHJvcGRvd24gbWVudSBvbiBob3ZlciAqL1xcclxcbi5kcm9wZG93bjpob3ZlciAuZHJvcGRvd24tY29udGVudCB7XFxyXFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcclxcbn1cXHJcXG4jZXhpdEJhcntcXHJcXG4gICAgcGFkZGluZy1sZWZ0OjVweDtcXHJcXG4gICAgcGFkZGluZy10b3A6MnB4O1xcclxcbn1cXHJcXG4jaW1nMSB7XFxyXFxuICAgIGhlaWdodDogMTVweDtcXHJcXG59XFxyXFxuI2ltZzIge1xcclxcbiAgICBoZWlnaHQ6IDE1cHg7XFxyXFxufVxcclxcbiNpbWczIHtcXHJcXG4gICAgaGVpZ2h0OiAxNXB4O1xcclxcbn1cXHJcXG4uaW1nNCB7XFxyXFxuICAgIHRvcDogMTdweDtcXHJcXG4gICAgaGVpZ2h0OiAzMXB4O1xcclxcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxyXFxuICAgIHJpZ2h0OiAxdnc7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuLmltZzV7XFxyXFxuICAgIHRvcDogMTdweDtcXHJcXG4gICAgaGVpZ2h0OiAzMXB4O1xcclxcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxyXFxuICAgIHJpZ2h0OiAxdnc7XFxyXFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLmltZzQ6aG92ZXIge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNmU3MzZmO1xcclxcbn1cXHJcXG4uaW1nNTpob3ZlciB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM2ZTczNmY7XFxyXFxufVxcclxcbmJvZHkge1xcclxcbiAgICBtYXJnaW46IDA7XFxyXFxuICAgIGJhY2tncm91bmQ6IGJsYWNrO1xcclxcbiAgICBvdmVyZmxvdy15OiBoaWRkZW47XFxyXFxufVxcclxcblxcclxcbiN0ZXJtIHtcXHJcXG5cXHJcXG4gICAgaGVpZ2h0OiA5NXZoO1xcclxcbiAgICAtLWJhY2tncm91bmQ6ICMwMzFlMTE7XFxyXFxuICAgIC0tc2l6ZTogMS41O1xcclxcbiAgICBib3JkZXItbGVmdDogN3B4IHNvbGlkICNjYmQwY2M7XFxyXFxufVxcclxcbi5vbGQge1xcclxcbiAgICBoZWlnaHQ6IDk1dmg7XFxyXFxuICAgIC0tYmFja2dyb3VuZDogIzAzMWUxMTtcXHJcXG4gICAgLS1zaXplOiAxLjU7XFxyXFxuICAgIGJvcmRlci1sZWZ0OiA3cHggc29saWQgI2NiZDBjYztcXHJcXG59XFxyXFxuLm9sZDo6YWZ0ZXIge1xcclxcblxcclxcbn1cXHJcXG4ucnVuQW5pbSB7XFxyXFxuICAgIGNvbnRlbnQ6IFxcXCIgXFxcIjtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXHJcXG4gICAgdG9wOiAwO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbiAgICBib3R0b206IDA7XFxyXFxuICAgIHJpZ2h0OiAwO1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDE4LCAxNiwgMTYsIDAuMik7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICAgIHotaW5kZXg6IDI7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgICBhbmltYXRpb246IHR1cm4tb24gOHMgbGluZWFyO1xcclxcbn1cXHJcXG5cXHJcXG4vKiB0byBzZWUgeW91cnNlbGYgbGlrZSBpbiBhIG1pcnJvciAqL1xcclxcbi5zZWxmIHtcXHJcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgtMSwgMSk7XFxyXFxufVxcclxcblxcclxcbi8qIGZsaWNrZXIgYW5pbWF0aW9uIHRha2VuIGZyb20gaHR0cDovL2dvb25odWIuY29tL3NlY3JldCAqL1xcclxcbiN0ZXJtOjphZnRlciB7XFxyXFxuICAgIGNvbnRlbnQ6IFxcXCIgXFxcIjtcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXHJcXG4gICAgdG9wOiAwO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbiAgICBib3R0b206IDA7XFxyXFxuICAgIHJpZ2h0OiAwO1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDE4LCAxNiwgMTYsIDAuMik7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICAgIHotaW5kZXg6IDI7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbiAgICBhbmltYXRpb246IGZsaWNrZXIgMC4xMnMgaW5maW5pdGU7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgZmxpY2tlciB7XFxyXFxuICAgIDAlIHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDAuNTUyO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIDUlIHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDAuNDgyODc7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgMTAlIHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDAuNTkxMzQ7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgMTUuMCUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC43OTU0MztcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAyMCUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC43NTEzNDtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAyNSUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC4xOTU2O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIDMwLjAlIHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDAuOTA2ODc7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgMzUlIHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDAuMTIyO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIDQwJSB7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwLjYyMjU0O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIDQ1JSB7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwLjU2OTc3O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIDUwJSB7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwLjk5MjU7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgNTUuMCUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC41NTQ4NztcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICA2MC4wJSB7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwLjE2NjA3O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIDY1JSB7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwLjEyMzUzO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIDcwJSB7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwLjIyMTQ7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgNzUlIHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDAuNjc5MDg7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgODAlIHtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDAuOTcxNjM7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgODUuMCUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC4xMjc1O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIDkwJSB7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwLjM3MTg2O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIDk1JSB7XFxyXFxuICAgICAgICBvcGFjaXR5OiAwLjI0NDc1O1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIDEwMCUge1xcclxcbiAgICAgICAgb3BhY2l0eTogMC4zNzIyMTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG4vKiBnbG93ICovXFxyXFxuLnRlcm1pbmFsIHtcXHJcXG4gICAgdGV4dC1zaGFkb3c6IDAgMC4ycmVtIDFyZW0gIzBjN2I0NjtcXHJcXG59XFxyXFxuXFxyXFxuLyogYmFzZWQgb25cXHJcXG5odHRwczovL2Jsb2cuY2FyYm9uZml2ZS5jb20vMjAxNS8wMS8wNy92aW50YWdlLXRlcm1pbmFsLWVmZmVjdC1pbi1jc3MzL1xcclxcbiovXFxyXFxuLnNjYW5saW5lcyB7XFxyXFxuICAgIHRvcDo0NXB4O1xcclxcbiAgICBsZWZ0OiA3cHg7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sXFxyXFxuICAgIHJnYmEoMjU1LCAyNTUsIDI1NSwgMCksXFxyXFxuICAgIHJnYmEoMjU1LCAyNTUsIDI1NSwgMCkgNTAlLFxcclxcbiAgICByZ2JhKDAsIDAsIDAsIC4yKSA3MCUsXFxyXFxuICAgIHJnYmEoMCwgMCwgMCwgLjYpKTtcXHJcXG4gICAgYmFja2dyb3VuZC1zaXplOiAxMDAlIC4zcmVtO1xcclxcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxyXFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4uc2NhbmxpbmVzOmJlZm9yZSB7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgdG9wOiAwcHg7XFxyXFxuICAgIHdpZHRoOiAxMDAlO1xcclxcbiAgICBoZWlnaHQ6IDVweDtcXHJcXG4gICAgYmFja2dyb3VuZDogI2ZmZjtcXHJcXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSxcXHJcXG4gICAgcmdiYSgyNTUsIDAsIDAsIDApIDAlLFxcclxcbiAgICByZ2JhKDI1NSwgMjUwLCAyNTAsIDEpIDUwJSxcXHJcXG4gICAgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk4KSA1MSUsXFxyXFxuICAgIHJnYmEoMjU1LCAwLCAwLCAwKSAxMDAlKTtcXHJcXG4gICAgLyogVzNDICovXFxyXFxuICAgIG9wYWNpdHk6IC4xO1xcclxcbn1cXHJcXG5cXHJcXG4uc2NhbmxpbmVzOmFmdGVyIHtcXHJcXG4gICAgYm94LXNoYWRvdzogMCAycHggNnB4IHJnYmEoMjUsIDI1LCAyNSwgMC4yKSxcXHJcXG4gICAgaW5zZXQgMCAxcHggcmdiYSg1MCwgNTAsIDUwLCAwLjEpLFxcclxcbiAgICBpbnNldCAwIDNweCByZ2JhKDUwLCA1MCwgNTAsIDAuMDUpLFxcclxcbiAgICBpbnNldCAwIDNweCA4cHggcmdiYSg2NCwgNjQsIDY0LCAwLjA1KSxcXHJcXG4gICAgaW5zZXQgMCAtNXB4IDEwcHggcmdiYSgyNSwgMjUsIDI1LCAwLjEpO1xcclxcbn1cXHJcXG5cXHJcXG4jdGVybTpmb2N1cy13aXRoaW4rLnNjYW5saW5lczpiZWZvcmUge1xcclxcbiAgICBjb250ZW50OiAnJztcXHJcXG4gICAgYW5pbWF0aW9uOiB2bGluZSBjYWxjKHZhcigtLXRpbWUsIDIpICogMXMpIGxpbmVhciBpbmZpbml0ZTtcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG4qIE1TIEVkZ2UgZG9uJ3Qgc3VwcG9ydCBmb2N1cy13aXRoaW4gYW5kIGNzcyB2YXJzXFxyXFxuKiBpbnNpZGUgcHNldWRvIHNlbGVjdG9yXFxyXFxuKi9cXHJcXG5Ac3VwcG9ydHMgKC1tcy1pbWUtYWxpZ246YXV0bykge1xcclxcbiAgICAuc2NhbmxpbmVzOmJlZm9yZSB7XFxyXFxuICAgICAgICBjb250ZW50OiAnJztcXHJcXG4gICAgICAgIGFuaW1hdGlvbjogdmxpbmUgM3MgbGluZWFyIGluZmluaXRlO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgdmxpbmUge1xcclxcbiAgICB0byB7XFxyXFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAxMDB2aClcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG4vKiB0dXJuIG9mZiBhbmltYXRpb24gKi9cXHJcXG4udHYge1xcclxcbiAgICBoZWlnaHQ6IDEwMHZoO1xcclxcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxufVxcclxcblxcclxcbi50di5jb2xsYXBzZSB7XFxyXFxuICAgIGFuaW1hdGlvbjogc2l6ZSAycyBlYXNlLW91dDtcXHJcXG4gICAgYW5pbWF0aW9uLWZpbGwtbW9kZTogZm9yd2FyZHM7XFxyXFxufVxcclxcblxcclxcbi50di5jb2xsYXBzZTpiZWZvcmUge1xcclxcbiAgICBjb250ZW50OiAnJztcXHJcXG4gICAgZGlzcGxheTogYmxvY2s7XFxyXFxuICAgIGhlaWdodDogMTAwJTtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbiAgICByaWdodDogMDtcXHJcXG4gICAgYm90dG9tOiAwO1xcclxcbiAgICB0b3A6IDA7XFxyXFxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcclxcbiAgICB6LWluZGV4OiAxO1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgICBhbmltYXRpb246IG9wYWNpdHkgMnMgZWFzZS1vdXQ7XFxyXFxuICAgIGFuaW1hdGlvbi1maWxsLW1vZGU6IGZvcndhcmRzO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIG9wYWNpdHkge1xcclxcbiAgICB0byB7XFxyXFxuICAgICAgICBvcGFjaXR5OiAxO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgc2l6ZSB7XFxyXFxuICAgIDUwJSB7XFxyXFxuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlWChjYWxjKDEgLyB2YXIoLS13aWR0aCkpKTtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDE7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgOTglIHtcXHJcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGVYKGNhbGMoMSAvIHZhcigtLXdpZHRoKSkpIHNjYWxlWShjYWxjKDEgLyB2YXIoLS1oZWlnaHQpKSk7XFxyXFxuICAgICAgICBvcGFjaXR5OiAxO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIDEwMCUge1xcclxcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZVgoY2FsYygxIC8gdmFyKC0td2lkdGgpKSkgc2NhbGVZKGNhbGMoMSAvIHZhcigtLWhlaWdodCkpKTtcXHJcXG4gICAgICAgIG9wYWNpdHk6IDA7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXCIsIFwiXCJdKTtcblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./src/styles.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return '@media ' + item[2] + '{' + content + '}';\n      } else {\n        return content;\n      }\n    }).join('');\n  }; // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || '';\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n  return '/*# ' + data + ' */';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZELE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxvQkFBb0I7QUFDbkMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuICdAbWVkaWEgJyArIGl0ZW1bMl0gKyAneycgKyBjb250ZW50ICsgJ30nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IG1vZHVsZXNbaV07IC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcbiAgICAgIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG4gICAgICAvLyB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG4gICAgICAvLyBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cbiAgICAgIGlmIChpdGVtWzBdID09IG51bGwgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgaWYgKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgICAgaXRlbVsyXSA9ICcoJyArIGl0ZW1bMl0gKyAnKSBhbmQgKCcgKyBtZWRpYVF1ZXJ5ICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuICByZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/defaults/index.js":
/*!****************************************!*\
  !*** ./node_modules/defaults/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var clone = __webpack_require__(/*! clone */ \"./node_modules/clone/clone.js\");\n\nmodule.exports = function(options, defaults) {\n  options = options || {};\n\n  Object.keys(defaults).forEach(function(key) {\n    if (typeof options[key] === 'undefined') {\n      options[key] = clone(defaults[key]);\n    }\n  });\n\n  return options;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVmYXVsdHMvaW5kZXguanM/YzM5ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsNENBQU87O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVmYXVsdHMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY2xvbmUgPSByZXF1aXJlKCdjbG9uZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIE9iamVjdC5rZXlzKGRlZmF1bHRzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9uc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9uc1trZXldID0gY2xvbmUoZGVmYXVsdHNba2V5XSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3B0aW9ucztcbn07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/defaults/index.js\n");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz85MTUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLFFBQVEsVUFBVTs7QUFFbEI7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ieee754/index.js\n");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcz9lM2RiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/isarray/index.js\n");

/***/ }),

/***/ "./node_modules/jquery.terminal/css/jquery.terminal.min.css":
/*!******************************************************************!*\
  !*** ./node_modules/jquery.terminal/css/jquery.terminal.min.css ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../css-loader/dist/cjs.js!./jquery.terminal.min.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/jquery.terminal/css/jquery.terminal.min.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LnRlcm1pbmFsL2Nzcy9qcXVlcnkudGVybWluYWwubWluLmNzcz82NmJmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSxjQUFjLG1CQUFPLENBQUMsaUtBQTBEOztBQUVoRiw0Q0FBNEMsUUFBUzs7QUFFckQ7QUFDQTs7OztBQUlBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMseUZBQXNDOztBQUUzRDs7QUFFQSxHQUFHLEtBQVUsRUFBRSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9qcXVlcnkudGVybWluYWwvY3NzL2pxdWVyeS50ZXJtaW5hbC5taW4uY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9qcXVlcnkudGVybWluYWwubWluLmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vanF1ZXJ5LnRlcm1pbmFsLm1pbi5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vanF1ZXJ5LnRlcm1pbmFsLm1pbi5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jquery.terminal/css/jquery.terminal.min.css\n");

/***/ }),

/***/ "./node_modules/jquery.terminal/js/jquery.terminal.js":
/*!************************************************************!*\
  !*** ./node_modules/jquery.terminal/js/jquery.terminal.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**@license\n *       __ _____                     ________                              __\n *      / // _  /__ __ _____ ___ __ _/__  ___/__ ___ ______ __ __  __ ___  / /\n *  __ / // // // // // _  // _// // / / // _  // _//     // //  \\/ // _ \\/ /\n * /  / // // // // // ___// / / // / / // ___// / / / / // // /\\  // // / /__\n * \\___//____ \\\\___//____//_/ _\\_  / /_//____//_/ /_/ /_//_//_/ /_/ \\__\\_\\___/\n *           \\/              /____/                              version 2.12.0\n *\n * This file is part of jQuery Terminal. https://terminal.jcubic.pl\n *\n * Copyright (c) 2010-2019 Jakub T. Jankiewicz <https://jcubic.pl/m>e\n * Released under the MIT license\n *\n * Contains:\n *\n * Storage plugin Distributed under the MIT License\n * modified to work from Data URIs that block storage and cookies in Chrome\n * Copyright (c) 2010 Dave Schindler\n *\n * jQuery Timers licenced with the WTFPL\n * <http://jquery.offput.ca/timers/>\n *\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n *\n * jQuery Caret\n * Copyright (c) 2009, Gideon Sireling\n * 3 clause BSD License\n *\n * sprintf.js\n * Copyright (c) 2007-2013 Alexandru Marasteanu <hello at alexei dot ro>\n * licensed under 3 clause BSD license\n *\n * debounce function from Lodash\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * The MIT License\n *\n * emoji regex v7.0.1 by Mathias Bynens\n * MIT license\n *\n * broken image by Sophia Bai from the Noun Project (CC-BY)\n *\n * Date: Wed, 01 Jan 2020 17:03:16 +0000\n */\n/* global location, setTimeout, window, global, sprintf, setImmediate,\n          IntersectionObserver,  ResizeObserver, module, require, define,\n          setInterval, clearInterval, clearTimeout, Blob, Map, Image */\n/* eslint-disable */\n/* istanbul ignore next */\n(function(ctx) {\n    var sprintf = function() {\n        if (!sprintf.cache.hasOwnProperty(arguments[0])) {\n            sprintf.cache[arguments[0]] = sprintf.parse(arguments[0]);\n        }\n        return sprintf.format.call(null, sprintf.cache[arguments[0]], arguments);\n    };\n    sprintf.format = function(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;\n        for (i = 0; i < tree_length; i++) {\n            node_type = get_type(parse_tree[i]);\n            if (node_type === 'string') {\n                output.push(parse_tree[i]);\n            }\n            else if (node_type === 'array') {\n                match = parse_tree[i]; // convenience purposes only\n                if (match[2]) { // keyword argument\n                    arg = argv[cursor];\n                    for (k = 0; k < match[2].length; k++) {\n                        if (!arg.hasOwnProperty(match[2][k])) {\n                            throw(sprintf('[sprintf] property \"%s\" does not exist', match[2][k]));\n                        }\n                        arg = arg[match[2][k]];\n                    }\n                }\n                else if (match[1]) { // positional argument (explicit)\n                    arg = argv[match[1]];\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++];\n                }\n\n                if (/[^s]/.test(match[8]) && (get_type(arg) !== 'number')) {\n                    throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));\n                }\n                switch (match[8]) {\n                    case 'b': arg = arg.toString(2); break;\n                    case 'c': arg = String.fromCharCode(arg); break;\n                    case 'd': arg = parseInt(arg, 10); break;\n                    case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;\n                    case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;\n                    case 'o': arg = arg.toString(8); break;\n                    case 's': arg = ((arg = String(arg)) && match[7] ? arg.slice(0, match[7]) : arg); break;\n                    case 'u': arg = arg >>> 0; break;\n                    case 'x': arg = arg.toString(16); break;\n                    case 'X': arg = arg.toString(16).toUpperCase(); break;\n                }\n                arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? ' +' + arg : arg);\n                pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' ';\n                pad_length = match[6] - String(arg).length;\n                pad = match[6] ? str_repeat(pad_character, pad_length) : '';\n                output.push(match[5] ? arg + pad : pad + arg);\n            }\n        }\n        return output.join('');\n    };\n\n    sprintf.cache = {};\n\n    sprintf.parse = function(fmt) {\n        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;\n        while (_fmt) {\n            if ((match = /^[^\\x25]+/.exec(_fmt)) !== null) {\n                parse_tree.push(match[0]);\n            }\n            else if ((match = /^\\x25{2}/.exec(_fmt)) !== null) {\n                parse_tree.push('%');\n            }\n            else if ((match = /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1;\n                    var field_list = [], replacement_field = match[2], field_match = [];\n                    if ((field_match = /^([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n                        field_list.push(field_match[1]);\n                        while ((replacement_field = replacement_field.slice(field_match[0].length)) !== '') {\n                            if ((field_match = /^\\.([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1]);\n                            }\n                            else if ((field_match = /^\\[(\\d+)\\]/.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1]);\n                            }\n                            else {\n                                throw('[sprintf] huh?');\n                            }\n                        }\n                    }\n                    else {\n                        throw('[sprintf] huh?');\n                    }\n                    match[2] = field_list;\n                }\n                else {\n                    arg_names |= 2;\n                }\n                if (arg_names === 3) {\n                    throw('[sprintf] mixing positional and named placeholders is not (yet) supported');\n                }\n                parse_tree.push(match);\n            }\n            else {\n                throw('[sprintf] huh?');\n            }\n            _fmt = _fmt.slice(match[0].length);\n        }\n        return parse_tree;\n    };\n\n    var vsprintf = function(fmt, argv, _argv) {\n        _argv = argv.slice(0);\n        _argv.splice(0, 0, fmt);\n        return sprintf.apply(null, _argv);\n    };\n\n    /**\n     * helpers\n     */\n    function get_type(variable) {\n        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n    }\n\n    function str_repeat(input, multiplier) {\n        for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}\n        return output.join('');\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    ctx.sprintf = sprintf;\n    ctx.vsprintf = vsprintf;\n})(typeof global !== \"undefined\" ? global : window);\n// -----------------------------------------------------------------------\n/* eslint-enable */\n// UMD taken from https://github.com/umdjs/umd\n(function(factory, undefined) {\n    var root = typeof window !== 'undefined' ? window : global;\n    if (true) {\n        // AMD. Register as an anonymous module.\n        // istanbul ignore next\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! wcwidth */ \"./node_modules/wcwidth/index.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(jquery, wcwidth) {\n            factory(jquery, wcwidth, root);\n            return jquery;\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(function($, wcwidth, root, undefined) {\n    'use strict';\n    // -----------------------------------------------------------------------\n    // :: debug functions\n    // -----------------------------------------------------------------------\n    /* eslint-disable */\n    /* istanbul ignore next */\n    function debug(str) {\n        if (false) {}\n    }\n    /* eslint-enable */\n    // -----------------------------------------------------------------------\n    // :: Replacemenet for jQuery 2 deferred objects\n    // -----------------------------------------------------------------------\n    function DelayQueue() {\n        var callbacks = $.Callbacks();\n        var resolved = false;\n        this.resolve = function() {\n            callbacks.fire();\n            resolved = true;\n        };\n        this.add = function(fn) {\n            if (resolved) {\n                fn();\n            } else {\n                callbacks.add(fn);\n            }\n        };\n    }\n    // -----------------------------------------------------------------------\n    // :: map object to object\n    // -----------------------------------------------------------------------\n    $.omap = function(o, fn) {\n        var result = {};\n        $.each(o, function(k, v) {\n            result[k] = fn.call(o, k, v);\n        });\n        return result;\n    };\n    $.fn.text_length = function() {\n        return this.map(function() {\n            return $(this).text().length;\n        }).get().reduce(function(a, b) {\n            return a + b;\n        }, 0);\n    };\n    // -----------------------------------------------------------------------\n    // :: Deep clone of objects and arrays\n    // -----------------------------------------------------------------------\n    var Clone = {\n        clone_object: function(object) {\n            var tmp = {};\n            if (typeof object === 'object') {\n                if ($.isArray(object)) {\n                    return this.clone_array(object);\n                } else if (object === null) {\n                    return object;\n                } else {\n                    for (var key in object) {\n                        if ($.isArray(object[key])) {\n                            tmp[key] = this.clone_array(object[key]);\n                        } else if (typeof object[key] === 'object') {\n                            tmp[key] = this.clone_object(object[key]);\n                        } else {\n                            tmp[key] = object[key];\n                        }\n                    }\n                }\n            }\n            return tmp;\n        },\n        clone_array: function(array) {\n            if (!is_function(Array.prototype.map)) {\n                throw new Error(\"Your browser don't support ES5 array map \" +\n                                'use es5-shim');\n            }\n            return array.slice(0).map(function(item) {\n                if (typeof item === 'object') {\n                    return this.clone_object(item);\n                } else {\n                    return item;\n                }\n            }.bind(this));\n        }\n    };\n    var clone = function(object) {\n        return Clone.clone_object(object);\n    };\n\n    /* eslint-disable */\n    // -----------------------------------------------------------------------\n    // :: Storage plugin\n    // -----------------------------------------------------------------------\n    var localStorage;\n    /* istanbul ignore next */\n    (function() {\n        var hasLS = function() {\n            try {\n                var testKey = 'test', storage = window.localStorage;\n                storage.setItem(testKey, '1');\n                storage.removeItem(testKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        };\n        var hasCookies = function() {\n            try {\n                document.cookie.split(';');\n                return true;\n            } catch (e) {\n                return false;\n            }\n        };\n        // Private data\n        var isLS = hasLS();\n        // Private functions\n        function wls(n, v) {\n            var c;\n            if (typeof n === 'string' && typeof v === 'string') {\n                localStorage[n] = v;\n                return true;\n            } else if (typeof n === 'object' && typeof v === 'undefined') {\n                for (c in n) {\n                    if (n.hasOwnProperty(c)) {\n                        localStorage[c] = n[c];\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        function wc(n, v) {\n            var dt, e, c;\n            dt = new Date();\n            dt.setTime(dt.getTime() + 31536000000);\n            e = '; expires=' + dt.toGMTString();\n            if (typeof n === 'string' && typeof v === 'string') {\n                document.cookie = n + '=' + v + e + '; path=/';\n                return true;\n            } else if (typeof n === 'object' && typeof v === 'undefined') {\n                for (c in n) {\n                    if (n.hasOwnProperty(c)) {\n                        document.cookie = c + '=' + n[c] + e + '; path=/';\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        function rls(n) {\n            return localStorage[n];\n        }\n        function rc(n) {\n            var nn, ca, i, c;\n            nn = n + '=';\n            ca = document.cookie.split(';');\n            for (i = 0; i < ca.length; i++) {\n                c = ca[i];\n                while (c.charAt(0) === ' ') {\n                    c = c.slice(1, c.length);\n                }\n                if (c.indexOf(nn) === 0) {\n                    return c.slice(nn.length, c.length);\n                }\n            }\n            return null;\n        }\n        function dls(n) {\n            return delete localStorage[n];\n        }\n        function dc(n) {\n            return wc(n, '', -1);\n        }\n        /**\n         * Public API\n         * $.Storage.set(\"name\", \"value\")\n         * $.Storage.set({\"name1\":\"value1\", \"name2\":\"value2\", etc})\n         * $.Storage.get(\"name\")\n         * $.Storage.remove(\"name\")\n         */\n        if (!hasCookies() && !isLS) {\n            localStorage = {};\n            $.extend({\n                Storage: {\n                    set: wls,\n                    get: rls,\n                    remove: dls\n                }\n            });\n        } else {\n            if (isLS) {\n                localStorage = window.localStorage;\n            }\n            $.extend({\n                Storage: {\n                    set: isLS ? wls : wc,\n                    get: isLS ? rls : rc,\n                    remove: isLS ? dls : dc\n                }\n            });\n        }\n    })();\n    // -----------------------------------------------------------------------\n    // :: Debounce from Lodash\n    // -----------------------------------------------------------------------\n    /* istanbul ignore next */\n    var debounce = (function() {\n        var FUNC_ERROR_TEXT = 'Expected a function';\n        function isObject(value) {\n            var type = typeof value;\n            return value != null && (type == 'object' || type == 'function');\n        }\n        function now() {\n            return Date.now();\n        }\n        return function debounce(func, wait, options) {\n            var nativeMax = Math.max,\n                nativeMin = Math.min;\n\n            var lastArgs,\n                lastThis,\n                maxWait,\n                result,\n                timerId,\n                lastCallTime,\n                lastInvokeTime = 0,\n                leading = false,\n                maxing = false,\n                trailing = true;\n\n            if (typeof func != 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            wait = wait || 0;\n            if (isObject(options)) {\n                leading = !!options.leading;\n                maxing = 'maxWait' in options;\n                maxWait = maxing ? nativeMax(options.maxWait || 0, wait) : maxWait;\n                trailing = 'trailing' in options ? !!options.trailing : trailing;\n            }\n\n            function invokeFunc(time) {\n                var args = lastArgs,\n                    thisArg = lastThis;\n\n                lastArgs = lastThis = undefined;\n                lastInvokeTime = time;\n                result = func.apply(thisArg, args);\n                return result;\n            }\n\n            function leadingEdge(time) {\n                // Reset any `maxWait` timer.\n                lastInvokeTime = time;\n                // Start the timer for the trailing edge.\n                timerId = setTimeout(timerExpired, wait);\n                // Invoke the leading edge.\n                return leading ? invokeFunc(time) : result;\n            }\n\n            function remainingWait(time) {\n                var timeSinceLastCall = time - lastCallTime,\n                    timeSinceLastInvoke = time - lastInvokeTime,\n                    timeWaiting = wait - timeSinceLastCall;\n\n                return maxing\n                    ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n                    : timeWaiting;\n            }\n\n            function shouldInvoke(time) {\n                var timeSinceLastCall = time - lastCallTime,\n                    timeSinceLastInvoke = time - lastInvokeTime;\n\n                // Either this is the first call, activity has stopped and we're at the\n                // trailing edge, the system time has gone backwards and we're treating\n                // it as the trailing edge, or we've hit the `maxWait` limit.\n                return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n                        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n            }\n\n            function timerExpired() {\n                var time = now();\n                if (shouldInvoke(time)) {\n                    return trailingEdge(time);\n                }\n                // Restart the timer.\n                timerId = setTimeout(timerExpired, remainingWait(time));\n            }\n\n            function trailingEdge(time) {\n                timerId = undefined;\n\n                // Only invoke if we have `lastArgs` which means `func` has been\n                // debounced at least once.\n                if (trailing && lastArgs) {\n                    return invokeFunc(time);\n                }\n                lastArgs = lastThis = undefined;\n                return result;\n            }\n\n            function cancel() {\n                if (timerId !== undefined) {\n                    clearTimeout(timerId);\n                }\n                lastInvokeTime = 0;\n                lastArgs = lastCallTime = lastThis = timerId = undefined;\n            }\n\n            function flush() {\n                return timerId === undefined ? result : trailingEdge(now());\n            }\n\n            function debounced() {\n                var time = now(),\n                    isInvoking = shouldInvoke(time);\n\n                lastArgs = arguments;\n                lastThis = this;\n                lastCallTime = time;\n\n                if (isInvoking) {\n                    if (timerId === undefined) {\n                        return leadingEdge(lastCallTime);\n                    }\n                    if (maxing) {\n                        // Handle invocations in a tight loop.\n                        timerId = setTimeout(timerExpired, wait);\n                        return invokeFunc(lastCallTime);\n                    }\n                }\n                if (timerId === undefined) {\n                    timerId = setTimeout(timerExpired, wait);\n                }\n                return result;\n            }\n            debounced.cancel = cancel;\n            debounced.flush = flush;\n            return debounced;\n        };\n    })();\n    // -----------------------------------------------------------------------\n    // :: jQuery Timers\n    // -----------------------------------------------------------------------\n    var jQuery = $;\n    /* istanbul ignore next */\n    (function($) {\n        jQuery.fn.extend({\n            everyTime: function(interval, label, fn, times, belay) {\n                return this.each(function() {\n                    jQuery.timer.add(this, interval, label, fn, times, belay);\n                });\n            },\n            oneTime: function(interval, label, fn) {\n                return this.each(function() {\n                    jQuery.timer.add(this, interval, label, fn, 1);\n                });\n            },\n            stopTime: function(label, fn) {\n                return this.each(function() {\n                    jQuery.timer.remove(this, label, fn);\n                });\n            }\n        });\n\n        jQuery.extend({\n            timer: {\n                guid: 1,\n                global: {},\n                regex: /^([0-9]+)\\s*(.*s)?$/,\n                powers: {\n                    // Yeah this is major overkill...\n                    'ms': 1,\n                    'cs': 10,\n                    'ds': 100,\n                    's': 1000,\n                    'das': 10000,\n                    'hs': 100000,\n                    'ks': 1000000\n                },\n                timeParse: function(value) {\n                    if (value === undefined || value === null) {\n                        return null;\n                    }\n                    var result = this.regex.exec(jQuery.trim(value.toString()));\n                    if (result[2]) {\n                        var num = parseInt(result[1], 10);\n                        var mult = this.powers[result[2]] || 1;\n                        return num * mult;\n                    } else {\n                        return value;\n                    }\n                },\n                add: function(element, interval, label, fn, times, belay) {\n                    var counter = 0;\n\n                    if (jQuery.isFunction(label)) {\n                        if (!times) {\n                            times = fn;\n                        }\n                        fn = label;\n                        label = interval;\n                    }\n\n                    interval = jQuery.timer.timeParse(interval);\n\n                    if (typeof interval !== 'number' ||\n                        isNaN(interval) ||\n                        interval <= 0) {\n                        return;\n                    }\n                    if (times && times.constructor !== Number) {\n                        belay = !!times;\n                        times = 0;\n                    }\n\n                    times = times || 0;\n                    belay = belay || false;\n\n                    if (!element.$timers) {\n                        element.$timers = {};\n                    }\n                    if (!element.$timers[label]) {\n                        element.$timers[label] = {};\n                    }\n                    fn.$timerID = fn.$timerID || this.guid++;\n\n                    var handler = function() {\n                        if (belay && handler.inProgress) {\n                            return;\n                        }\n                        handler.inProgress = true;\n                        if ((++counter > times && times !== 0) ||\n                            fn.call(element, counter) === false) {\n                            jQuery.timer.remove(element, label, fn);\n                        }\n                        handler.inProgress = false;\n                    };\n\n                    handler.$timerID = fn.$timerID;\n\n                    if (!element.$timers[label][fn.$timerID]) {\n                        element.$timers[label][fn.$timerID] = window.setInterval(handler, interval);\n                    }\n\n                    if (!this.global[label]) {\n                        this.global[label] = [];\n                    }\n                    this.global[label].push(element);\n\n                },\n                remove: function(element, label, fn) {\n                    var timers = element.$timers, ret;\n\n                    if (timers) {\n\n                        if (!label) {\n                            for (var lab in timers) {\n                                if (timers.hasOwnProperty(lab)) {\n                                    this.remove(element, lab, fn);\n                                }\n                            }\n                        } else if (timers[label]) {\n                            if (fn) {\n                                if (fn.$timerID) {\n                                    window.clearInterval(timers[label][fn.$timerID]);\n                                    delete timers[label][fn.$timerID];\n                                }\n                            } else {\n                                for (var _fn in timers[label]) {\n                                    if (timers[label].hasOwnProperty(_fn)) {\n                                        window.clearInterval(timers[label][_fn]);\n                                        delete timers[label][_fn];\n                                    }\n                                }\n                            }\n\n                            for (ret in timers[label]) {\n                                if (timers[label].hasOwnProperty(ret)) {\n                                    break;\n                                }\n                            }\n                            if (!ret) {\n                                ret = null;\n                                delete timers[label];\n                            }\n                        }\n\n                        for (ret in timers) {\n                            if (timers.hasOwnProperty(ret)) {\n                                break;\n                            }\n                        }\n                        if (!ret) {\n                            element.$timers = null;\n                        }\n                    }\n                }\n            }\n        });\n        if (/(msie) ([\\w.]+)/.exec(navigator.userAgent.toLowerCase())) {\n            $(window).one('unload', function() {\n                var global = jQuery.timer.global;\n                for (var label in global) {\n                    if (global.hasOwnProperty(label)) {\n                        var els = global[label], i = els.length;\n                        while (--i) {\n                            jQuery.timer.remove(els[i], label);\n                        }\n                    }\n                }\n            });\n        }\n    })(jQuery);\n    // -----------------------------------------------------------------------\n    // :: CROSS BROWSER SPLIT\n    // -----------------------------------------------------------------------\n    /* istanbul ignore next */\n    (function(undef) {\n        // prevent double include\n\n        if (!String.prototype.split.toString().match(/\\[native/)) {\n            return;\n        }\n\n        var nativeSplit = String.prototype.split,\n        compliantExecNpcg = /()??/.exec(\"\")[1] === undef, // NPCG: nonparticipating capturing group\n        self;\n\n        self = function(str, separator, limit) {\n            // If `separator` is not a regex, use `nativeSplit`\n            if (Object.prototype.toString.call(separator) !== \"[object RegExp]\") {\n                return nativeSplit.call(str, separator, limit);\n            }\n            var output = [],\n            flags = (separator.ignoreCase ? \"i\" : \"\") +\n                (separator.multiline  ? \"m\" : \"\") +\n                (separator.extended   ? \"x\" : \"\") + // Proposed for ES6\n                (separator.sticky     ? \"y\" : \"\"), // Firefox 3+\n                lastLastIndex = 0,\n            // Make `global` and avoid `lastIndex` issues by working with a copy\n            separator2, match, lastIndex, lastLength;\n            separator = new RegExp(separator.source, flags + \"g\");\n            str += \"\"; // Type-convert\n            if (!compliantExecNpcg) {\n                // Doesn't need flags gy, but they don't hurt\n                separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n            }\n            /* Values for `limit`, per the spec:\n             * If undefined: 4294967295 // Math.pow(2, 32) - 1\n             * If 0, Infinity, or NaN: 0\n             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n             * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n             * If other: Type-convert, then use the above rules\n             */\n            // ? Math.pow(2, 32) - 1 : ToUint32(limit)\n            limit = limit === undef ? -1 >>> 0 : limit >>> 0;\n            while (match = separator.exec(str)) {\n                    // `separator.lastIndex` is not reliable cross-browser\n                    lastIndex = match.index + match[0].length;\n                    if (lastIndex > lastLastIndex) {\n                        output.push(str.slice(lastLastIndex, match.index));\n                        // Fix browsers whose `exec` methods don't consistently return `undefined` for\n                        // nonparticipating capturing groups\n                        if (!compliantExecNpcg && match.length > 1) {\n                            match[0].replace(separator2, function() {\n                                for (var i = 1; i < arguments.length - 2; i++) {\n                                    if (arguments[i] === undef) {\n                                        match[i] = undef;\n                                    }\n                                }\n                            });\n                        }\n                        if (match.length > 1 && match.index < str.length) {\n                            Array.prototype.push.apply(output, match.slice(1));\n                        }\n                        lastLength = match[0].length;\n                        lastLastIndex = lastIndex;\n                        if (output.length >= limit) {\n                            break;\n                        }\n                    }\n                    if (separator.lastIndex === match.index) {\n                        separator.lastIndex++; // Avoid an infinite loop\n                    }\n                }\n            if (lastLastIndex === str.length) {\n                if (lastLength || !separator.test(\"\")) {\n                    output.push(\"\");\n                }\n            } else {\n                output.push(str.slice(lastLastIndex));\n            }\n            return output.length > limit ? output.slice(0, limit) : output;\n        };\n\n        // For convenience\n        String.prototype.split = function(separator, limit) {\n            return self(this, separator, limit);\n        };\n\n        return self;\n\n    })();\n    // -----------------------------------------------------------------------\n    // :: jQuery Caret\n    // -----------------------------------------------------------------------\n    /* istanbul ignore next */\n    $.fn.caret = function(pos) {\n        var target = this[0];\n        var isContentEditable = target.contentEditable === 'true';\n        //get\n        if (arguments.length === 0) {\n            //HTML5\n            if (window.getSelection) {\n                //contenteditable\n                if (isContentEditable) {\n                    target.focus();\n                    var range1 = window.getSelection().getRangeAt(0),\n                    range2 = range1.cloneRange();\n                    range2.selectNodeContents(target);\n                    range2.setEnd(range1.endContainer, range1.endOffset);\n                    return range2.toString().length;\n                }\n                //textarea\n                return target.selectionStart;\n            }\n            //IE<9\n            if (document.selection) {\n                target.focus();\n                //contenteditable\n                if (isContentEditable) {\n                    var range1 = document.selection.createRange(),\n                    range2 = document.body.createTextRange();\n                    range2.moveToElementText(target);\n                    range2.setEndPoint('EndToEnd', range1);\n                    return range2.text.length;\n                }\n                //textarea\n                var pos = 0,\n                range = target.createTextRange(),\n                range2 = document.selection.createRange().duplicate(),\n                bookmark = range2.getBookmark();\n                range.moveToBookmark(bookmark);\n                while (range.moveStart('character', -1) !== 0) pos++;\n                return pos;\n            }\n            //not supported\n            return 0;\n        }\n        //set\n        if (pos === -1)\n            pos = this[isContentEditable? 'text' : 'val']().length;\n        //HTML5\n        if (window.getSelection) {\n            //contenteditable\n            if (isContentEditable) {\n                target.focus();\n                window.getSelection().collapse(target.firstChild, pos);\n            }\n            //textarea\n            else\n                target.setSelectionRange(pos, pos);\n        }\n        //IE<9\n        else if (document.body.createTextRange) {\n            var range = document.body.createTextRange();\n            range.moveToElementText(target);\n            range.moveStart('character', pos);\n            range.collapse(true);\n            range.select();\n        }\n        if (!isContentEditable && !this.is(':focus')) {\n            target.focus();\n        }\n        return pos;\n    };\n    /* eslint-enable */\n    // -----------------------------------------------------------------------\n    // :: Cross-browser resize element plugin using sentinel iframe or\n    // :: resizeObserver\n    // -----------------------------------------------------------------------\n    $.fn.resizer = function(callback, options) {\n        var settings = $.extend({}, {\n            prefix: ''\n        }, options);\n        var trigger = arguments.length === 0;\n        var unbind = arguments[0] === \"unbind\";\n        if (!trigger && !unbind && !is_function(callback)) {\n            throw new Error('Invalid argument, it need to a function or string ' +\n                            '\"unbind\" or no arguments.');\n        }\n        if (unbind) {\n            callback = is_function(arguments[1]) ? arguments[1] : null;\n        }\n        return this.each(function() {\n            var $this = $(this);\n            var iframe;\n            var callbacks;\n            function resize_handler() {\n                callbacks.fire();\n            }\n            if (trigger || unbind) {\n                callbacks = $this.data('callbacks');\n                if (trigger) {\n                    callbacks && callbacks.fire();\n                } else {\n                    if (callback && callbacks) {\n                        callbacks.remove(callback);\n                        if (!callbacks.has()) {\n                            callbacks = null;\n                        }\n                    } else {\n                        callbacks = null;\n                    }\n                    if (!callbacks) {\n                        $this.removeData('callbacks');\n                        if (window.ResizeObserver) {\n                            var observer = $this.data('observer');\n                            if (observer) {\n                                observer.unobserve(this);\n                                $this.removeData('observer');\n                            }\n                        } else {\n                            iframe = $this.find('> iframe');\n                            if (iframe.length) {\n                                // just in case of memory leaks in IE\n                                $(iframe[0].contentWindow).off('resize').remove();\n                                iframe.remove();\n                            } else if ($this.is('body')) {\n                                $(window).off('resize.resizer');\n                            }\n                        }\n                    }\n                }\n            } else if ($this.data('callbacks')) {\n                $(this).data('callbacks').add(callback);\n            } else {\n                callbacks = $.Callbacks();\n                callbacks.add(callback);\n                $this.data('callbacks', callbacks);\n                var resizer;\n                var first = true;\n                if (window.ResizeObserver) {\n                    resizer = new ResizeObserver(function() {\n                        if (!first) {\n                            resize_handler();\n                        }\n                        first = false;\n                    });\n                    resizer.observe(this);\n                    $this.data('observer', resizer);\n                } else if ($this.is('body')) {\n                    $(window).on('resize.resizer', resize_handler);\n                } else {\n                    iframe = $('<iframe/>').addClass(settings.prefix + 'resizer')\n                        .appendTo(this)[0];\n\n                    $(iframe.contentWindow).on('resize', resize_handler);\n                }\n            }\n        });\n    };\n    // -----------------------------------------------------------------------\n    function jquery_resolve(value) {\n        var defer = jQuery.Deferred();\n        defer.resolve(value);\n        return defer.promise();\n    }\n    // -----------------------------------------------------------------------\n    function unpromise(value, callback, error) {\n        if (value) {\n            if (is_function(value.catch)) {\n                value.catch(error);\n            }\n            if (is_function(value.done)) {\n                return value.done(callback);\n            } else if (is_function(value.then)) {\n                return value.then(callback);\n            } else {\n                return callback(value);\n            }\n        }\n    }\n    // -----------------------------------------------------------------------\n    // :: based on https://github.com/zeusdeux/isInViewport\n    // :: work only vertically and on dom elements\n    // -----------------------------------------------------------------------\n    $.fn.is_fully_in_viewport = (function() {\n        function is_visible(node, container) {\n            var box = node.getBoundingClientRect();\n            var viewport = container[0].getBoundingClientRect();\n            var top = box.top - viewport.top;\n            var bottom = box.bottom - viewport.top;\n            var height = container.height();\n            return bottom > 0 && top <= height;\n        }\n        if (window.IntersectionObserver) {\n            return function(container) {\n                var node = this[0];\n                var defer = jQuery.Deferred();\n                var item_observer = new window.IntersectionObserver(function(entries) {\n                    defer.resolve(entries[0].isIntersecting && entries[0].ratio === 1);\n                    item_observer.unobserve(node);\n                }, {\n                    root: container[0]\n                });\n                item_observer.observe(node);\n                return defer.promise();\n            };\n        } else {\n            return function(container) {\n                return jquery_resolve(is_visible(this[0], container));\n            };\n        }\n    })();\n    // -------------------------------------------------------------------------\n    /* eslint-disable */\n    var entity_re = /(&(?:[a-z\\d]+|#\\d+|#x[a-f\\d]+);)/i;\n    // regex that match single character at begining and folowing combine character\n    // https://en.wikipedia.org/wiki/Combining_character\n    var combine_chr_re = /(.(?:[\\u0300-\\u036F]|[\\u1AB0-\\u1abE]|[\\u1DC0-\\u1DF9]|[\\u1DFB-\\u1DFF]|[\\u20D0-\\u20F0]|[\\uFE20-\\uFE2F])+)/;\n    // source: https://mathiasbynens.be/notes/javascript-unicode\n    var astral_symbols_re = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF])/;\n    // source: https://github.com/mathiasbynens/emoji-regex\n    var emoji_re = /(\\uD83C\\uDFF4(?:\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74)\\uDB40\\uDC7F|\\u200D\\u2620\\uFE0F)|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC68(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDB0-\\uDDB3])|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDB0-\\uDDB3]))|\\uD83D\\uDC69\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDB0-\\uDDB3])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC68(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|(?:(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)\\uFE0F|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDD6-\\uDDDD])(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\u200D[\\u2640\\u2642])|\\uD83D\\uDC69\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC68(?:\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDB0-\\uDDB3])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDB5\\uDDB6\\uDDD1-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDEEB\\uDEEC\\uDEF4-\\uDEF9]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD70\\uDD73-\\uDD76\\uDD7A\\uDD7C-\\uDDA2\\uDDB0-\\uDDB9\\uDDC0-\\uDDC2\\uDDD0-\\uDDFF])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEF9]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD70\\uDD73-\\uDD76\\uDD7A\\uDD7C-\\uDDA2\\uDDB0-\\uDDB9\\uDDC0-\\uDDC2\\uDDD0-\\uDDFF])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC69\\uDC6E\\uDC70-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3D\\uDD3E\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDD1-\\uDDDD]))/;\n    // https://stackoverflow.com/questions/11381673/detecting-a-mobile-browser\n    var mobile_re = /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i;\n    var tablet_re = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i;\n    var format_split_re = /(\\[\\[(?:-?[@!gbiuso])*;[^;]*;[^\\]]*\\](?:[^\\]\\\\]*(?:\\\\\\\\)*\\\\\\][^\\]]*|[^\\]]*|[^[]*\\[[^\\]]*)\\]?)/i;\n    var format_parts_re = /\\[\\[((?:-?[@!gbiuso])*);([^;]*);([^;\\]]*);?([^;\\]]*);?([^\\]]*)\\]([^\\]\\\\]*\\\\\\][^\\]]*|[^\\]]*|[^[]*\\[[^\\]]+)\\]?/gi;\n    var format_re = /\\[\\[((?:-?[@!gbiuso])*;[^;\\]]*;[^;\\]]*(?:;|[^\\]()]*);?[^\\]]*)\\]([^\\]]*\\\\\\][^\\]]*|[^\\]]*|[^[]*\\[[^\\]]*)\\]?/gi;\n    var format_exist_re = /\\[\\[((?:-?[@!gbiuso])*;[^;\\]]*;[^;\\]]*(?:;|[^\\]()]*);?[^\\]]*)\\]([^\\]]*\\\\\\][^\\]]*|[^\\]]*|[^[]*\\[[^\\]]*)\\]/gi;\n    var format_full_re = /^(\\[\\[(?:(?:-?[@!gbiuso])*;[^;\\]]*;[^;\\]]*(?:;|[^\\]()]*);?[^\\]]*)\\])([^\\]]*\\\\\\][^\\]]*|[^\\]]*|[^[]*\\[[^\\]]*)(\\])$/i;\n    var format_begin_re = /(\\[\\[(?:-?[@!gbiuso])*;[^;]*;[^\\]]*\\])/i;\n    var format_start_re = /^(\\[\\[(?:-?[@!gbiuso])*;[^;]*;[^\\]]*\\])/i;\n    var format_end_re = /\\[\\[(?:-?[@!gbiuso])*;[^;]*;[^\\]]*\\]?$/i;\n    var self_closing_re = /^(?:\\[\\[)?[^;]*@[^;]*;/;\n    var color_hex_re = /^#([0-9a-f]{3}|[0-9a-f]{6})$/i;\n    var url_re = /(\\bhttps?:\\/\\/(?:(?:(?!&[^;]+;)|(?=&amp;))[^\\s\"'<>\\][)])+)/gi;\n    var url_nf_re = /\\b(?![^\\s[\\]]*])(https?:\\/\\/(?:(?:(?!&[^;]+;)|(?=&amp;))[^\\s\"'<>\\][)])+)/gi;\n    var email_re = /((([^<>('\")[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,})))/g;\n    var url_full_re = /^(https?:\\/\\/(?:(?:(?!&[^;]+;)|(?=&amp;))[^\\s\"'<>\\][)])+)$/gi;\n    var email_full_re = /^((([^<>('\")[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,})))$/g;\n    var command_re = /((?:\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|\\/[^\\/\\\\]*(?:\\\\[\\S\\s][^\\/\\\\]*)*\\/[gimsuy]*(?=\\s|$)|(?:\\\\\\s|\\S))+)(?=\\s|$)/gi;\n    var extended_command_re = /^\\s*((terminal|cmd)::([a-z_]+)\\(([\\s\\S]*)\\))\\s*$/;\n    var format_exec_re = /(\\[\\[(?:[^\\][]|\\\\\\])+\\]\\])/;\n    var float_re = /^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$/;\n    var re_re = /^\\/((?:\\\\\\/|[^/]|\\[[^\\]]*\\/[^\\]]*\\])+)\\/([gimsuy]*)$/;\n    var string_re = /(\"(?:[^\"\\\\]|\\\\(?:\\\\\\\\)*\"|\\\\\\\\)*\"|'(?:[^'\\\\]|\\\\(?:\\\\\\\\)*'|\\\\\\\\)*')/;\n    var unclosed_strings_re = /^(?=((?:[^\"']+|\"[^\"\\\\]*(?:\\\\[^][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[^][^'\\\\]*)*')*))\\1./;\n    var broken_image = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 14\"><title id=\"title2\">rounded</title><path id=\"terminal-broken-image\" d=\"m 14,10 h 2 v 1 a 3,3 0 0 1 -3,3 H 3 A 3,3 0 0 1 0,11 H 4.5 A 1.00012,1.00012 0 0 0 5.207,10.707 L 6.5,9.414 7.793,10.707 a 0.99963,0.99963 0 0 0 1.41406,0 l 2.36719,-2.36719 1.80127,1.44092 A 0.99807,0.99807 0 0 0 14,10 Z M 16,3 V 8 H 14.35059 L 12.12451,6.21924 A 0.99846,0.99846 0 0 0 10.793,6.293 L 8.5,8.586 7.207,7.293 a 0.99962,0.99962 0 0 0 -1.41406,0 L 4.08594,9 H 0 V 3 A 3,3 0 0 1 3,0 h 10 a 3,3 0 0 1 3,3 z M 6,4.5 A 1.5,1.5 0 1 0 4.5,6 1.5,1.5 0 0 0 6,4.5 Z\" /></svg>';\n    var use_broken_image = '<svg class=\"terminal-broken-image\" role=\"presentation\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 14\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><use xlink:href=\"#terminal-broken-image\"/></svg>';\n    /* eslint-enable */\n    // -------------------------------------------------------------------------\n    // :: features flags\n    // -------------------------------------------------------------------------\n    // taken from https://hacks.mozilla.org/2011/09/detecting-and-generating-\n    // css-animations-in-javascript/\n    var animation_supported = (function() {\n        var animation = false,\n            domPrefixes = 'Webkit Moz O ms Khtml'.split(' '),\n            elm = document.createElement('div');\n        if (elm.style.animationName) {\n            animation = true;\n        }\n        if (animation === false) {\n            for (var i = 0; i < domPrefixes.length; i++) {\n                var name = domPrefixes[i] + 'AnimationName';\n                if (elm.style[name] !== undefined) {\n                    animation = true;\n                    break;\n                }\n            }\n        }\n        elm = null;\n        return animation;\n    })();\n    // -------------------------------------------------------------------------\n    var agent = window.navigator.userAgent;\n    var is_IE = /MSIE|Trident/.test(agent) || /rv:11.0/i.test(agent);\n    var is_IEMobile = /IEMobile/.test(agent);\n    // -------------------------------------------------------------------------\n    var is_ch_unit_supported = (function() {\n        if (is_IE && !is_IEMobile) {\n            return false;\n        }\n        var div = document.createElement('div');\n        div.style.width = '1ch';\n        return div.style.width === '1ch';\n    })();\n    // -------------------------------------------------------------------------\n    var is_css_variables_supported = window.CSS && window.CSS.supports &&\n            window.CSS.supports('--fake-var', 0);\n    // -------------------------------------------------------------------------\n    var is_android = navigator.userAgent.toLowerCase().indexOf('android') !== -1;\n    // -------------------------------------------------------------------------\n    var is_key_native = (function is_key_native() {\n        if (!('KeyboardEvent' in window && 'key' in window.KeyboardEvent.prototype)) {\n            return false;\n        }\n        var proto = window.KeyboardEvent.prototype;\n        var get = Object.getOwnPropertyDescriptor(proto, 'key').get;\n        return !!get.toString().match(/\\[native code\\]/);\n    })();\n    // -------------------------------------------------------------------------\n    var is_mobile = (function(a) {\n        var check = false;\n        if (mobile_re.test(a) || tablet_re.test(a.substr(0, 4))) {\n            check = true;\n        }\n        return check;\n    })(navigator.userAgent || navigator.vendor || window.opera);\n\n    // -------------------------------------------------------------------------\n    // IE ch unit bug detection - better that UserAgent that can be changed\n    // -------------------------------------------------------------------------\n    var ch_unit_bug = false;\n    $(function() {\n        function width(e) {\n            return e[0].getBoundingClientRect().width;\n        }\n        var base = '<span style=\"font-family: monospace;visibility:hidden;';\n        var ch = $(base + 'width:1ch;overflow: hidden\">&nbsp;</span>').appendTo('body');\n        var space = $(base + '\">&nbsp;</span>').appendTo('body');\n        ch_unit_bug = width(ch) !== width(space);\n        ch.remove();\n        space.remove();\n    });\n    // -----------------------------------------------------------------------\n    // :: hide elements from screen readers\n    // -----------------------------------------------------------------------\n    function a11y_hide(element) {\n        element.attr({\n            role: 'presentation',\n            'aria-hidden': 'true'\n        });\n    }\n    // ---------------------------------------------------------------------\n    // :: alert only first exception of type\n    // ---------------------------------------------------------------------\n    var excepctions = [];\n    function alert_exception(label, e) {\n        if (arguments[0] instanceof $.terminal.Exception) {\n            label = arguments[0].type;\n            e = arguments[0];\n        }\n        var message = (label ? label + ': ' : '') + exception_message(e);\n        if (excepctions.indexOf(message) === -1) {\n            excepctions.push(message);\n            setTimeout(function() {\n                throw e;\n            }, 0);\n            //alert(message + (e.stack ? '\\n' + e.stack : ''));\n        }\n    }\n    // ---------------------------------------------------------------------\n    // :; detect if mouse event happen on scrollbar\n    // ---------------------------------------------------------------------\n    function scrollbar_event(e, node) {\n        var left = node.offset().left;\n        return node.outerWidth() <= e.clientX - left;\n    }\n    // ---------------------------------------------------------------------\n    // :: Return exception message as string\n    // ---------------------------------------------------------------------\n    function exception_message(e) {\n        if (typeof e === 'string') {\n            return e;\n        } else if (typeof e.fileName === 'string') {\n            return e.fileName + ': ' + e.message;\n        } else {\n            return e.message;\n        }\n    }\n    // -----------------------------------------------------------------------\n    // :: CYCLE DATA STRUCTURE\n    // -----------------------------------------------------------------------\n    function Cycle() {\n        var data = [].slice.call(arguments);\n        var pos = 0;\n        $.extend(this, {\n            get: function() {\n                return data;\n            },\n            index: function() {\n                return pos;\n            },\n            rotate: function(skip, init) {\n                if (init === undefined) {\n                    init = pos;\n                } else if (init === pos) {\n                    return;\n                }\n                if (!skip) {\n                    var defined = data.filter(function(item) {\n                        return typeof item !== 'undefined';\n                    });\n                    if (!defined.length) {\n                        return;\n                    }\n                }\n                if (!data.length) {\n                    return;\n                }\n                if (data.length === 1) {\n                    return data[0];\n                } else {\n                    if (pos === data.length - 1) {\n                        pos = 0;\n                    } else {\n                        ++pos;\n                    }\n                    if (typeof data[pos] !== 'undefined') {\n                        return data[pos];\n                    } else {\n                        return this.rotate(true, init);\n                    }\n                }\n            },\n            length: function() {\n                return data.length;\n            },\n            remove: function(index) {\n                delete data[index];\n            },\n            set: function(item) {\n                for (var i = data.length; i--;) {\n                    if (data[i] === item) {\n                        pos = i;\n                        return;\n                    }\n                }\n                this.append(item);\n                pos = data.length - 1;\n            },\n            front: function() {\n                if (data.length) {\n                    var index = pos;\n                    var restart = false;\n                    while (!data[index]) {\n                        index++;\n                        if (index > data.length) {\n                            if (restart) {\n                                break;\n                            }\n                            index = 0;\n                            restart = true;\n                        }\n                    }\n                    return data[index];\n                }\n            },\n            map: function(fn) {\n                return data.map(function(item, i) {\n                    if (typeof item !== 'undefined') {\n                        return fn(item, i);\n                    }\n                    return null;\n                }).filter(Boolean);\n            },\n            forEach: function(fn) {\n                return data.forEach(function(item, i) {\n                    if (typeof item !== 'undefined') {\n                        fn(item, i);\n                    }\n                });\n            },\n            append: function(item) {\n                data.push(item);\n            }\n        });\n    }\n    /*\n    function time() {\n        // performance.now almost equal Date.now()- performance.timing.navigationStart\n        // the difference check should be almost the same\n        return performance ? performance.now() : Date.now();\n    }\n    */\n    // -----------------------------------------------------------------------\n    // :: STACK DATA STRUCTURE\n    // -----------------------------------------------------------------------\n    function Stack(init) {\n        var data = is_array(init) ? init : init ? [init] : [];\n        $.extend(this, {\n            data: function() {\n                return data;\n            },\n            map: function(fn) {\n                return $.map(data, fn);\n            },\n            size: function() {\n                return data.length;\n            },\n            pop: function() {\n                if (data.length === 0) {\n                    return null;\n                } else {\n                    var value = data[data.length - 1];\n                    data = data.slice(0, data.length - 1);\n                    return value;\n                }\n            },\n            push: function(value) {\n                data = data.concat([value]);\n                return value;\n            },\n            top: function() {\n                return data.length > 0 ? data[data.length - 1] : null;\n            },\n            clone: function() {\n                return new Stack(data.slice(0));\n            }\n        });\n    }\n    // -------------------------------------------------------------------------\n    // :: Class for Worker that do some computation when needed\n    // :: if validation function return false it mean that condition changed\n    // :: and cache need to be cleared. If value was not prcessed it will run\n    // :: the action\n    // -------------------------------------------------------------------------\n    function WorkerCache(options) {\n        var settings = $.extend({\n            validation: $.noop,\n            action: $.noop,\n            onCache: $.noop\n        }, options);\n        this._onCache = settings.onCache;\n        this._action = settings.action;\n        this._validation = settings.validation;\n        this._cache = new Map();\n    }\n    // -------------------------------------------------------------------------\n    WorkerCache.prototype.validate = function() {\n        var valid = this._validation();\n        var test = valid === undefined || valid === true;\n        if (!test) {\n            this._cache.clear();\n        }\n        return test;\n    };\n    // -------------------------------------------------------------------------\n    WorkerCache.prototype.get = function(key) {\n        var value;\n        if (this.validate() && this._cache.has(key)) {\n            value = this._cache.get(key);\n            this._onCache({cahce: value});\n            return value;\n        }\n        value = this._action(key);\n        this._cache.set(key, value);\n        return value;\n    };\n    // -------------------------------------------------------------------------\n    // :: HISTORY CLASS\n    // -------------------------------------------------------------------------\n    function History(name, size, memory) {\n        var enabled = true;\n        var storage_key = '';\n        if (typeof name === 'string' && name !== '') {\n            storage_key = name + '_';\n        }\n        storage_key += 'commands';\n        var data;\n        if (memory) {\n            data = [];\n        } else {\n            data = $.Storage.get(storage_key);\n            data = data ? JSON.parse(data) : [];\n        }\n        var pos = data.length - 1;\n        $.extend(this, {\n            append: function(item) {\n                if (enabled) {\n                    if (data[data.length - 1] !== item) {\n                        data.push(item);\n                        if (size && data.length > size) {\n                            data = data.slice(-size);\n                        }\n                        pos = data.length - 1;\n                        if (!memory) {\n                            $.Storage.set(storage_key, JSON.stringify(data));\n                        }\n                    }\n                }\n            },\n            set: function(new_data) {\n                if (is_array(new_data)) {\n                    data = new_data;\n                    if (!memory) {\n                        $.Storage.set(storage_key, JSON.stringify(data));\n                    }\n                }\n            },\n            data: function() {\n                return data;\n            },\n            reset: function() {\n                pos = data.length - 1;\n            },\n            last: function() {\n                return data[data.length - 1];\n            },\n            end: function() {\n                return pos === data.length - 1;\n            },\n            position: function() {\n                return pos;\n            },\n            current: function() {\n                return data[pos];\n            },\n            next: function() {\n                var old = pos;\n                if (pos < data.length - 1) {\n                    ++pos;\n                }\n                if (old !== pos) {\n                    return data[pos];\n                }\n            },\n            previous: function() {\n                var old = pos;\n                if (pos > 0) {\n                    --pos;\n                }\n                if (old !== pos) {\n                    return data[pos];\n                }\n            },\n            clear: function() {\n                data = [];\n                this.purge();\n            },\n            enabled: function() {\n                return enabled;\n            },\n            enable: function() {\n                enabled = true;\n            },\n            purge: function() {\n                if (!memory) {\n                    $.Storage.remove(storage_key);\n                }\n            },\n            disable: function() {\n                enabled = false;\n            },\n            toggle: function(value) {\n                if (typeof value === 'undefined') {\n                    enabled = !enabled;\n                } else {\n                    enabled = value;\n                }\n            }\n        });\n    }\n    // -------------------------------------------------------------------------\n    // :: COMMAND LINE PLUGIN\n    // -------------------------------------------------------------------------\n    var cmd_index = 0;\n    $.cmd = {\n        defaults: {\n            mask: false,\n            caseSensitiveSearch: true,\n            historySize: 60,\n            prompt: '> ',\n            enabled: true,\n            history: true,\n            onPositionChange: $.noop,\n            onCommandChange: $.noop,\n            inputStyle: 'textarea',\n            mobileDelete: is_mobile,\n            onPaste: $.noop,\n            clickTimeout: 200,\n            holdTimeout: 400,\n            holdRepeatTimeout: 200,\n            mobileIngoreAutoSpace: [],\n            repeatTimeoutKeys: [],\n            tabindex: 1,\n            tabs: 4\n        }\n    };\n    $.fn.cmd = function(options) {\n        var settings = $.extend({}, $.cmd.defaults, options);\n        function mobile_ignore_key(key) {\n            return settings.mobileIngoreAutoSpace.length &&\n                settings.mobileIngoreAutoSpace.indexOf(key) !== -1 && is_android;\n        }\n        var self = this;\n        var maybe_data = self.data('cmd');\n        if (maybe_data) {\n            return maybe_data;\n        }\n        var id = cmd_index++;\n        self.addClass('cmd');\n        var wrapper = $('<div class=\"cmd-wrapper\"/>').appendTo(self);\n        wrapper.append('<span class=\"cmd-prompt\"></span>');\n        wrapper.append('<div class=\"cmd-cursor-line\">' +\n                       '<span></span>' +\n                       '<span class=\"cmd-cursor\"><span>' +\n                       '<span>&nbsp;</span></span></span>' +\n                       '<span></span>' +\n                       '</div>');\n        // a11y: don't read command it's in textarea that's in focus\n        a11y_hide(wrapper.find('.cmd-cursor-line'));\n        // on mobile the only way to hide textarea on desktop it's needed because\n        // textarea show up after focus\n        //self.append('<span class=\"mask\"></mask>');\n        var clip = $('<textarea>').attr({\n            autocapitalize: 'off',\n            spellcheck: 'false',\n            tabindex: settings.tabindex\n        }).addClass('cmd-clipboard').appendTo(self);\n        if (!is_mobile) {\n            clip.val(' ');\n        }\n        if (settings.width) {\n            self.width(settings.width);\n        }\n        var num_chars; // calculated by resize\n        var char_width;\n        var last_rendered_prompt;\n        var prompt_last_line;\n        var prompt_len;\n        var prompt_node = self.find('.cmd-prompt');\n        var reverse_search = false;\n        var rev_search_str = '';\n        var reverse_search_position = null;\n        var backup_prompt;\n        // TODO: try to use workerCache with data that don't change like bare_text\n        // or format function.\n        // TODO: remove workerCache for formatters they require dynamic\n        // value of position so data change when you move cursor\n        /*\n        var formatter = new WorkerCache({\n            validation: function() {\n                if (this._formatters instanceof Array) {\n                    var test = this._formatters.every(function(e, i) {\n                        return $.terminal.defaults.formatters[i] === e;\n                    });\n                    if (!test) {\n                        this._formatters = $.terminal.defaults.formatters;\n                    }\n                    return test;\n                }\n                return true;\n            },\n            onCache: function(value) {\n                this._counter = this._counter || 0;\n                this._counter++;\n            },\n            action: function(string) {\n                this._times = this._times || [];\n                var t0 = time();\n                // some optimization - don't change object shape and ref\n                format_options.position = position;\n                string = $.terminal.escape_formatting(string);\n                var value = $.terminal.apply_formatters(string, format_options);\n                var t1 = time();\n                this._times.push(t1 - t0);\n                return value;\n            }\n        });\n        */\n        var command = '';\n        var last_command;\n        // text from selection using CTRL+SHIFT+C (as in Xterm)\n        var kill_text = ''; // text from command that kill part of the command\n        var position = 0;\n        var prompt;\n        var enabled;\n        var formatted_position = 0;\n        var name, history;\n        var cursor = self.find('.cmd-cursor');\n        var animation;\n        var restart_animation;\n        var paste_count = 0;\n        // use \\uFFFF to mark newline extra character\n        // so we can hide it by css when using text selection\n        var line_marker = '\\uFFFF';\n        var line_marker_re = /\\uFFFF$/;\n        function get_char_pos(e) {\n            var node = $(e.target);\n            if (node.is('span,img,a')) {\n                node = node.closest('[data-text]');\n                return node.index() +\n                    node.parent('span').prevAll().find('[data-text]').length +\n                    node.closest('[role=\"presentation\"]')\n                        .prevUntil('.cmd-prompt').find('[data-text]').length;\n            } else if (node.is('div[role=\"presentation\"]')) {\n                var last = !node.next().length;\n                return node.find('[data-text]').length +\n                    node.prevUntil('.cmd-prompt').find('[data-text]').length -\n                    (last ? 0 : 1);\n            }\n        }\n        // IE mapping\n        var key_mapping = {\n            'SPACEBAR': ' ',\n            'UP': 'ArrowUP',\n            'DOWN': 'ArrowDown',\n            'LEFT': 'ArrowLeft',\n            'RIGHT': 'ArrowRight',\n            'DEL': 'Delete',\n            'MULTIPLY': '*',\n            'DIVIDE': '/',\n            'SUBTRACT': '-',\n            'ADD': '+'\n        };\n        function ie_key_fix(e) {\n            var key = e.key.toUpperCase();\n            if (key_mapping[key]) {\n                return key_mapping[key];\n            }\n            return key;\n        }\n        function get_key(e) {\n            if (e.key) {\n                var key = ie_key_fix(e).toUpperCase();\n                if (key === 'CONTROL') {\n                    return 'CTRL';\n                } else {\n                    var combo = [];\n                    if (e.ctrlKey) {\n                        combo.push('CTRL');\n                    }\n                    if (e.metaKey && key !== 'META') {\n                        combo.push('META');\n                    }\n                    if (e.shiftKey && key !== 'SHIFT') {\n                        combo.push('SHIFT');\n                    }\n                    if (e.altKey && key !== 'ALT') {\n                        combo.push('ALT');\n                    }\n                    if (combo.length && key === ' ') {\n                        key = 'SPACEBAR';\n                    }\n                    if (e.key) {\n                        combo.push(key);\n                    }\n                    return combo.join('+');\n                }\n            }\n        }\n        // -----------------------------------------------------------------\n        // for invoking shortcuts using terminal::keydown\n        // taken from https://github.com/cvan/keyboardevent-key-polyfill/\n        var keycodes = {\n            3: 'Cancel',\n            6: 'Help',\n            8: 'Backspace',\n            9: 'Tab',\n            12: 'Clear',\n            13: 'Enter',\n            16: 'Shift',\n            17: 'Control',\n            18: 'Alt',\n            19: 'Pause',\n            20: 'CapsLock',\n            27: 'Escape',\n            28: 'Convert',\n            29: 'NonConvert',\n            30: 'Accept',\n            31: 'ModeChange',\n            32: ' ',\n            33: 'PageUp',\n            34: 'PageDown',\n            35: 'End',\n            36: 'Home',\n            37: 'ArrowLeft',\n            38: 'ArrowUp',\n            39: 'ArrowRight',\n            40: 'ArrowDown',\n            41: 'Select',\n            42: 'Print',\n            43: 'Execute',\n            44: 'PrintScreen',\n            45: 'Insert',\n            46: 'Delete',\n            48: ['0', ')'],\n            49: ['1', '!'],\n            50: ['2', '@'],\n            51: ['3', '#'],\n            52: ['4', '$'],\n            53: ['5', '%'],\n            54: ['6', '^'],\n            55: ['7', '&'],\n            56: ['8', '*'],\n            57: ['9', '('],\n            91: 'OS',\n            93: 'ContextMenu',\n            144: 'NumLock',\n            145: 'ScrollLock',\n            181: 'VolumeMute',\n            182: 'VolumeDown',\n            183: 'VolumeUp',\n            186: [';', ':'],\n            187: ['=', '+'],\n            188: [',', '<'],\n            189: ['-', '_'],\n            190: ['.', '>'],\n            191: ['/', '?'],\n            192: ['`', '~'],\n            219: ['[', '{'],\n            220: ['\\\\', '|'],\n            221: [']', '}'],\n            222: [\"'\", '\"'],\n            224: 'Meta',\n            225: 'AltGraph',\n            246: 'Attn',\n            247: 'CrSel',\n            248: 'ExSel',\n            249: 'EraseEof',\n            250: 'Play',\n            251: 'ZoomOut'\n        };\n        var i;\n        // Function keys (F1-24).\n        for (i = 1; i < 25; i++) {\n            keycodes[111 + i] = 'F' + i;\n        }\n        // Printable ASCII characters.\n        var letter = '';\n        for (i = 65; i < 91; i++) {\n            letter = String.fromCharCode(i);\n            keycodes[i] = [letter.toLowerCase(), letter.toUpperCase()];\n        }\n        var reversed_keycodes = {};\n        Object.keys(keycodes).forEach(function(which) {\n            if (is_array(keycodes[which])) {\n                keycodes[which].forEach(function(key) {\n                    reversed_keycodes[key.toUpperCase()] = which;\n                });\n            } else {\n                reversed_keycodes[keycodes[which].toUpperCase()] = which;\n            }\n        });\n        // -----------------------------------------------------------------\n        var keymap;\n        var default_keymap = {\n            'ALT+D': delete_forward({clipboard: true}),\n            'HOLD+ALT+D': delete_forward({clipboard: true, hold: true}),\n            'HOLD+DELETE': delete_forward({clipboard: false, hold: true}),\n            'HOLD+SHIFT+DELETE': delete_forward({clipboard: false, hold: true}),\n            'ENTER': function() {\n                if (history && command && !settings.mask &&\n                    ((is_function(settings.historyFilter) &&\n                      settings.historyFilter(command)) ||\n                     (settings.historyFilter instanceof RegExp &&\n                      command.match(settings.historyFilter)) ||\n                     !settings.historyFilter)) {\n                    history.append(command);\n                }\n                var tmp = command;\n                history.reset();\n\n                // for next input event on firefox/android with google keyboard\n                prev_command = '';\n                no_keydown = true;\n\n                self.set('');\n                var promise;\n                if (settings.commands) {\n                    promise = settings.commands.call(self, tmp);\n                }\n                if (is_function(prompt)) {\n                    if (promise && is_function(promise.then)) {\n                        promise.then(draw_prompt);\n                    } else {\n                        draw_prompt();\n                    }\n                }\n                clip.val('');\n                return false;\n            },\n            'SHIFT+ENTER': function() {\n                self.insert('\\n');\n                return true;\n            },\n            'BACKSPACE': backspace_key,\n            'SHIFT+BACKSPACE': backspace_key,\n            'TAB': function() {\n                self.insert('\\t');\n            },\n            'CTRL+D': function() {\n                self['delete'](1);\n                return false;\n            },\n            'DELETE': function() {\n                self['delete'](1);\n                return true;\n            },\n            'HOLD+ARROWUP': up_arrow,\n            'ARROWUP': up_arrow,\n            'CTRL+P': prev_history,\n            'ARROWDOWN': down_arrow,\n            'HOLD+ARROWDOWN': down_arrow,\n            'CTRL+N': next_history,\n            'ARROWLEFT': left,\n            'HOLD+ARROWLEFT': debounce(left, 10),\n            'CTRL+B': left,\n            'CTRL+ARROWLEFT': function() {\n                // jump to one character after last space before prevoius word\n                var len = position - 1;\n                var pos = 0;\n                if (command[len] === ' ') {\n                    --len;\n                }\n                for (var i = len; i > 0; --i) {\n                    if (command[i] === ' ' && command[i + 1] !== ' ') {\n                        pos = i + 1;\n                        break;\n                    } else if (command[i] === '\\n' &&\n                               command[i + 1] !== '\\n') {\n                        pos = i;\n                        break;\n                    }\n                }\n                self.position(pos);\n            },\n            'CTRL+R': function() {\n                if (reverse_search) {\n                    reverse_history_search(true);\n                } else {\n                    backup_prompt = prompt;\n                    draw_reverse_prompt();\n                    last_command = command;\n                    self.set('');\n                    redraw();\n                    reverse_search = true;\n                }\n                return false;\n            },\n            'CTRL+G': function() {\n                if (reverse_search) {\n                    prompt = backup_prompt;\n                    draw_prompt();\n                    self.set(last_command);\n                    redraw();\n                    reverse_search = false;\n                    rev_search_str = '';\n                    return false;\n                }\n            },\n            'ARROWRIGHT': right,\n            'HOLD+ARROWRIGHT': debounce(right, 10),\n            'CTRL+F': right,\n            'CTRL+ARROWRIGHT': function() {\n                // jump to beginning or end of the word\n                if (command[position] === ' ') {\n                    ++position;\n                }\n                var re = /\\S[\\n\\s]{2,}|[\\n\\s]+\\S?/;\n                var match = command.slice(position).match(re);\n                if (!match || match[0].match(/^\\s+$/)) {\n                    self.position(text(command).length);\n                } else if (match[0][0] !== ' ') {\n                    position += match.index + 1;\n                } else {\n                    position += match.index + match[0].length - 1;\n                    if (match[0][match[0].length - 1] !== ' ') {\n                        --position;\n                    }\n                }\n                redraw();\n            },\n            'F12': return_true, // Allow Firebug\n            'END': end(true),\n            'CTRL+END': end(),\n            'CTRL+E': end(),\n            'HOME': home(true),\n            'CTRL+HOME': home(),\n            'CTRL+A': home(),\n            'SHIFT+INSERT': paste_event,\n            'CTRL+SHIFT+T': return_true, // open closed tab\n            'CTRL+W': delete_backward({clipboard: true, hold: false}),\n            'HOLD+BACKSPACE': delete_backward({clipboard: false, hold: true}),\n            'HOLD+SHIFT+BACKSPACE': delete_backward({clipboard: false, hold: true}),\n            'CTRL+H': function() {\n                if (command !== '' && position > 0) {\n                    self['delete'](-1);\n                }\n                return false;\n            },\n            'CTRL+X': return_true,\n            'CTRL+C': return_true,\n            'CTRL+T': return_true,\n            'CTRL+Y': function() {\n                if (kill_text !== '') {\n                    self.insert(kill_text);\n                }\n            },\n            'CTRL+V': paste_event,\n            'META+V': paste_event,\n            'CTRL+K': function() {\n                var len = text(command).length;\n                if (len > position) {\n                    kill_text = self['delete'](len - position);\n                    text_to_clipboard(clip, kill_text);\n                }\n                return false;\n            },\n            'CTRL+U': function() {\n                if (command !== '' && position !== 0) {\n                    kill_text = self['delete'](-position);\n                    text_to_clipboard(clip, kill_text);\n                }\n                return false;\n            },\n            'CTRL+TAB': function() {\n                return false;\n            },\n            'META+`': return_true, // CMD+` switch browser window on Mac\n            'META+R': return_true, // CMD+R page reload in Chrome Mac\n            'META+L': return_true // CLD+L jump into Ominbox on Chrome Mac\n        };\n        // -------------------------------------------------------------------------------\n        function delete_forward(options) {\n            options = options || {};\n            if (options.hold && !settings.mobileDelete) {\n                return function delete_character_forward() {\n                    self['delete'](1);\n                    return false;\n                };\n            }\n            return function delete_word_forward() {\n                var re = / *[^ ]+ *(?= )|[^ ]+$/;\n                var substring = command.slice(position);\n                var m = substring.match(re);\n                if (m) {\n                    kill_text = m[0];\n                    if (options.clipboard) {\n                        text_to_clipboard(clip, kill_text);\n                    }\n                }\n                self.set(\n                    command.slice(0, position) +\n                        command.slice(position).replace(re, ''),\n                    true\n                );\n                // chrome jump to address bar\n                return false;\n            };\n        }\n        // -------------------------------------------------------------------------------\n        function delete_backward(options) {\n            options = options || {};\n            if (options.hold && !settings.mobileDelete) {\n                return function delete_character_backward() {\n                    self['delete'](-1);\n                };\n            }\n            return function delete_word_backward() {\n                // don't work in Chromium (can't prevent close tab)\n                if (command !== '' && position !== 0) {\n                    var m = command.slice(0, position).match(/([^ ]* *$)/);\n                    if (m[0].length) {\n                        kill_text = self['delete'](-m[0].length);\n                        if (options.clipboard) {\n                            text_to_clipboard(clip, kill_text);\n                        }\n                    }\n                }\n                return false;\n            };\n        }\n        // -------------------------------------------------------------------------------\n        function return_true() {\n            return true;\n        }\n        // -------------------------------------------------------------------------------\n        function paste_event() {\n            clip.val('');\n            paste_count = 0;\n            if (self.isenabled() && !clip.is(':focus')) {\n                clip.trigger('focus', [true]);\n            }\n            clip.one('input', paste);\n            return true;\n        }\n        // ---------------------------------------------------------------------\n        // :: Paste content to terminal using hidden textarea\n        // ---------------------------------------------------------------------\n        function paste() {\n            if (paste_count++ > 0) {\n                return;\n            }\n            function set() {\n                clip.val(command);\n                fix_textarea();\n            }\n            function insert(text) {\n                self.insert(text);\n                set();\n            }\n            if (self.isenabled()) {\n                //wait until Browser insert text to textarea\n                self.oneTime(100, function() {\n                    var value = clip.val();\n                    if (is_function(settings.onPaste)) {\n                        var ret = settings.onPaste.call(self, {\n                            target: self,\n                            text: value\n                        });\n                        if (ret !== undefined) {\n                            if (ret && is_function(ret.then || ret.done)) {\n                                (ret.then || ret.done).call(ret, insert);\n                            } else if (typeof ret === 'string') {\n                                insert(ret);\n                            } else if (ret === false) {\n                                set();\n                            }\n                            return;\n                        }\n                    }\n                    insert(value);\n                });\n            }\n        }\n        // -------------------------------------------------------------------------------\n        function prev_history() {\n            if (first_up_history) {\n                last_command = command;\n                self.set(history.current());\n            } else {\n                self.set(history.previous());\n            }\n            first_up_history = false;\n            return false;\n        }\n        // -------------------------------------------------------------------------------\n        function next_history() {\n            self.set(history.end() ? last_command : history.next());\n            return false;\n        }\n        // -------------------------------------------------------------------------------\n        function have_newlines(string) {\n            return string.match(/\\n/);\n        }\n        // -------------------------------------------------------------------------------\n        function match_column(re, string, col) {\n            var match = string.match(re);\n            if (have_newlines(string)) {\n                return match && match[1].length <= col;\n            } else {\n                return match && match[1].length <= col - prompt_len;\n            }\n        }\n        // -------------------------------------------------------------------------------\n        function up_arrow() {\n            var before = command.substring(0, position);\n            var re = /\\n?([^\\n]+)$/;\n            var col = self.column();\n            if (have_newlines(before)) {\n                for (var i = before.length - col - 1; i--;) {\n                    if (before[i] === '\\n') {\n                        break;\n                    }\n                    var str = before.substring(0, i);\n                    if (match_column(re, str, col)) {\n                        break;\n                    }\n                }\n                self.position(i);\n                return false;\n            } else {\n                return prev_history();\n            }\n        }\n        // -------------------------------------------------------------------------------\n        function down_arrow() {\n            var after = command.substring(position);\n            var col = self.column();\n            if (have_newlines(after)) {\n                var before = command.substring(0, position);\n                var match = after.match(/^[^\\n]*\\n/);\n                if (match) {\n                    var new_pos = col + match[0].length;\n                    if (!have_newlines(before)) {\n                        new_pos += prompt_len;\n                    }\n                    self.position(new_pos, true);\n                }\n                return false;\n            } else {\n                return next_history();\n            }\n        }\n        // -------------------------------------------------------------------------------\n        function backspace_key() {\n            if (reverse_search) {\n                rev_search_str = rev_search_str.slice(0, -1);\n                draw_reverse_prompt();\n            } else if (command !== '' && position > 0) {\n                self['delete'](-1);\n            }\n            // for next input after naitve backspace\n            // we need timeout because we don't want it to trigger\n            // for current input but next one\n            self.oneTime(1, function() {\n                no_keydown = true;\n            });\n        }\n        // -------------------------------------------------------------------------------\n        function left() {\n            if (position > 0) {\n                self.position(-1, true);\n            }\n        }\n        // -------------------------------------------------------------------------------\n        function right() {\n            if (position < bare_text(command).length) {\n                self.position(1, true);\n            }\n            return false;\n        }\n        // -------------------------------------------------------------------------------\n        function home(line) {\n            function home() {\n                self.position(0);\n            }\n            if (line) {\n                return function() {\n                    if (command.match(/\\n/)) {\n                        var string = command.substring(0, self.position());\n                        self.position(string.lastIndexOf('\\n') + 1);\n                    } else {\n                        home();\n                    }\n                };\n            } else {\n                return home;\n            }\n        }\n        // -------------------------------------------------------------------------------\n        function end(line) {\n            function end() {\n                self.position(text(command).length);\n            }\n            if (line) {\n                return function() {\n                    if (command.match(/\\n/)) {\n                        var lines = command.split('\\n');\n                        var pos = self.position();\n                        var sum = 0;\n                        for (var i = 0; i < lines.length; ++i) {\n                            sum += lines[i].length;\n                            if (sum > pos) {\n                                self.position(sum + i);\n                                return;\n                            }\n                        }\n                    }\n                    end();\n                };\n            } else {\n                return end;\n            }\n        }\n        // -------------------------------------------------------------------------------\n        function mobile_focus() {\n            //if (is_touch) {\n            var focus = clip.is(':focus');\n            if (enabled) {\n                if (!focus) {\n                    //clip.trigger('focus', [true]);\n                }\n                self.oneTime(10, function() {\n                    if (!clip.is(':focus') && enabled) {\n                        clip.trigger('focus', [true]);\n                    }\n                });\n            } else if (focus && (is_mobile || !enabled)) {\n                clip.trigger('blur', [true]);\n            }\n        }\n        // -------------------------------------------------------------------------------\n        // fix for .cursor span animation that should only be applied when\n        // animation is equal to terminal-blink\n        // -------------------------------------------------------------------------------\n        function fix_cursor() {\n            if (animation_supported) {\n                var style = window.getComputedStyle(cursor[0]);\n                var animationName = style.getPropertyValue('--animation');\n                animationName = animationName.replace(/^\\s*|\\s*$/g, '');\n                var _class = self.attr('class');\n                if (_class.match(/-animation/)) {\n                    _class = _class.replace(/[a-z]+-animation/g, '');\n                }\n                if (animationName && !animationName.match(/blink/)) {\n                    var className = animationName.replace(/terminal-/, '') + '-animation';\n                    if (!_class.match(className)) {\n                        _class += ' ' + className;\n                    }\n                }\n                _class = _class.replace(/\\s+/g, ' ');\n                if (_class !== self.attr('class').replace(/\\s+/g, ' ')) {\n                    self.attr('class', _class);\n                }\n            }\n        }\n        // -------------------------------------------------------------------------------\n        // on mobile you can't delete character if input is empty (event\n        // will not fire) so we fake text entry, we could just put dummy\n        // data but we put real command and position\n        // -------------------------------------------------------------------------------\n        function fix_textarea(position_only) {\n            if (!self.isenabled()) {\n                return;\n            }\n            // delay worked while experimenting\n            self.oneTime(10, function() {\n                // we use space before command to show select all context menu\n                // idea taken from CodeMirror\n                if (!is_mobile && clip.val() !== command && !position_only) {\n                    clip.val(' ' + command);\n                }\n                if (enabled) {\n                    self.oneTime(10, function() {\n                        try {\n                            // we check first to improve performance\n                            if (!is_mobile && clip.caret() !== position + 1) {\n                                clip.caret(position + 1);\n                            }\n                        } catch (e) {\n                            // firefox throw NS_ERROR_FAILURE ignore\n                        }\n                    });\n                }\n            });\n        }\n        // -------------------------------------------------------------------------------\n        // terminal animation don't work on android because they animate\n        // 2 properties\n        // -------------------------------------------------------------------------------\n        if (animation_supported && !is_android) {\n            animation = function(toggle) {\n                if (toggle) {\n                    cursor.addClass('cmd-blink');\n                } else {\n                    cursor.removeClass('cmd-blink');\n                }\n            };\n            restart_animation = function() {\n                var new_cursor = cursor.clone();\n                new_cursor.insertBefore(cursor);\n                cursor.remove();\n                cursor = new_cursor;\n            };\n        } else {\n            var animating = false;\n            animation = function(toggle) {\n                if (toggle && !animating) {\n                    animating = true;\n                    cursor.addClass('cmd-inverted cmd-blink');\n                    self.everyTime(500, 'blink', blink);\n                } else if (animating && !toggle) {\n                    animating = false;\n                    self.stopTime('blink', blink);\n                    cursor.removeClass('cmd-inverted cmd-blink');\n                }\n            };\n            restart_animation = function() {\n                animation(false);\n                animation(true);\n            };\n        }\n        // ---------------------------------------------------------------------\n        // :: Blinking cursor function\n        // ---------------------------------------------------------------------\n        function blink() {\n            cursor.toggleClass('cmd-inverted');\n        }\n        // ---------------------------------------------------------------------\n        // :: Set prompt for reverse search\n        // ---------------------------------------------------------------------\n        function draw_reverse_prompt() {\n            prompt = '(reverse-i-search)`' + rev_search_str + \"': \";\n            draw_prompt();\n        }\n        // ---------------------------------------------------------------------\n        // :: Disable reverse search\n        // ---------------------------------------------------------------------\n        function clear_reverse_state() {\n            prompt = backup_prompt;\n            reverse_search = false;\n            reverse_search_position = null;\n            rev_search_str = '';\n        }\n        // ---------------------------------------------------------------------\n        // :: Search through command line history. If next is not defined or\n        // :: false it searches for the first item from the end. If true it\n        // :: search for the next item\n        // ---------------------------------------------------------------------\n        function reverse_history_search(next) {\n            var history_data = history.data();\n            var regex, save_string;\n            var len = history_data.length;\n            if (next && reverse_search_position > 0) {\n                len -= reverse_search_position;\n            }\n            if (rev_search_str.length > 0) {\n                for (var j = rev_search_str.length; j > 0; j--) {\n                    save_string = $.terminal.escape_regex(rev_search_str.slice(0, j));\n                    if (settings.caseSensitiveSearch) {\n                        regex = new RegExp(save_string);\n                    } else {\n                        regex = new RegExp(save_string, 'i');\n                    }\n                    for (var i = len; i--;) {\n                        if (regex.test(history_data[i])) {\n                            reverse_search_position = history_data.length - i;\n                            self.position(history_data[i].indexOf(save_string));\n                            self.set(history_data[i], true);\n                            redraw();\n                            if (rev_search_str.length !== j) {\n                                rev_search_str = rev_search_str.slice(0, j);\n                                draw_reverse_prompt();\n                            }\n                            return;\n                        }\n                    }\n                }\n            }\n            rev_search_str = ''; // clear if not found any\n        }\n        // ---------------------------------------------------------------------\n        // :: calculate width of hte character\n        // ---------------------------------------------------------------------\n        function get_char_width() {\n            var $prompt = self.find('.cmd-prompt');\n            var html = $prompt.html();\n            $prompt.html('<span>&nbsp;</span>');\n            var width = $prompt.find('span')[0].getBoundingClientRect().width;\n            $prompt.html(html);\n            return width;\n        }\n        // ---------------------------------------------------------------------\n        // :: return number of characters in command line\n        // ---------------------------------------------------------------------\n        function get_num_chars(char_width) {\n            var width = self.width();\n            return Math.floor(width / char_width);\n        }\n        // ---------------------------------------------------------------------\n        // :: Split String that fit into command line where first line need to\n        // :: fit next to prompt (need to have less characters)\n        // ---------------------------------------------------------------------\n        function get_splitted_command_line(string) {\n            function split(string) {\n                return $.terminal.split_equal(string, num_chars);\n            }\n            function skip_empty(array) {\n                // we remove lines that are leftovers after adding space at the end\n                return array.filter(function(line) {\n                    return !$.terminal.strip(line).match(/^ $/);\n                });\n            }\n            var line = prompt_node.find('.cmd-line');\n            var prompt;\n            if (line.length) {\n                prompt = line.nextUntil('.cmd-line').text();\n            } else {\n                prompt = prompt_node.text();\n            }\n            prompt = $.terminal.escape_brackets(prompt);\n            var re = new RegExp('^' + $.terminal.escape_regex(prompt));\n            var array;\n            if (string.match(/\\n/)) {\n                var tmp = string.split('\\n');\n                var first_len = num_chars - prompt_len - 1;\n                for (var i = 0; i < tmp.length - 1; ++i) {\n                    tmp[i] += line_marker;\n                }\n                // split first line\n                if (strlen(tmp[0]) > first_len) {\n                    array = split(prompt + tmp[0]);\n                    array[0] = array[0].replace(re, '');\n                    array = skip_empty(array);\n                } else {\n                    array = [tmp[0]];\n                }\n                // process rest of the lines\n                for (i = 1; i < tmp.length; ++i) {\n                    if (strlen(tmp[i]) > num_chars) {\n                        var splitted = split(tmp[i]);\n                        if (i < tmp.length - 1) {\n                            splitted = skip_empty(splitted);\n                        }\n                        array = array.concat(splitted);\n                    } else {\n                        array.push(tmp[i]);\n                    }\n                }\n            } else {\n                array = split(prompt + string, num_chars);\n                array[0] = array[0].replace(re, '');\n            }\n            // fix issue with cursor that was cut off #379\n            if (array.length > 1 && array[array.length - 1].length === num_chars) {\n                array.push('');\n            }\n            return array;\n        }\n        // ---------------------------------------------------------------------\n        // :: use custom formatting\n        // ---------------------------------------------------------------------\n        function formatting(string, skip_formatted_position) {\n            // we don't want to format command when user type formatting in\n            try {\n                string = $.terminal.escape_formatting(string);\n                var format_options = $.extend({}, settings, {\n                    unixFormattingEscapeBrackets: true,\n                    position: position\n                });\n                var formatted = $.terminal.apply_formatters(string, format_options);\n                var output = $.terminal.normalize(formatted[0]);\n                var max = $.terminal.length(output);\n                if (!skip_formatted_position) {\n                    formatted_position = formatted[1];\n                    // fix issue with nested formatting where max length\n                    // is checked before nested_formatting flatten formatting\n                    if (formatted_position > max) {\n                        formatted_position = max;\n                    }\n                }\n                output = $.terminal.normalize(output);\n                return output;\n            } catch (e) {\n                alert_exception('[Formatting]', e.stack);\n                return string;\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: format and encode the string\n        // ---------------------------------------------------------------------\n        function format(string, before) {\n            //string = $.terminal.normalize(string);\n            var encoded = $.terminal.encode(wrap(string), {\n                tabs: settings.tabs,\n                before: before\n            });\n            string = $.terminal.format(encoded, {\n                char_width: settings.char_width,\n                allowedAttributes: settings.allowedAttributes || []\n            });\n            var re = /(<span[^>]+data-text[^>]+>)(.*?)(<\\/span>)/g;\n            return string.replace(re, '$1<span>$2</span>$3');\n        }\n        // ---------------------------------------------------------------------\n        // :: function create new string with all characters in it's own\n        // :: formatting - it will only have style if the input is formatting\n        // :: this function is not very usefull so it's not in $.terminal\n        // ---------------------------------------------------------------------\n        function wrap(string) {\n            return $.terminal.partition(string).join('');\n        }\n        // ---------------------------------------------------------------------\n        // :: shortcut helpers\n        // ---------------------------------------------------------------------\n        function length(str, raw) {\n            return $.terminal.length(str, raw);\n        }\n        // ---------------------------------------------------------------------\n        function substring(str, start, end) {\n            return $.terminal.substring(str, start, end);\n        }\n        // ---------------------------------------------------------------------\n        // :: Function that displays the command line. Split long lines and\n        // :: place cursor in the right place\n        // ---------------------------------------------------------------------\n        var redraw = (function() {\n            var before = cursor.prev();\n            var after = cursor.next();\n            var cursor_line = cursor.parent();\n            // -----------------------------------------------------------------\n            // :: Draw line with the cursor\n            // -----------------------------------------------------------------\n            function draw_cursor_line(string, options) {\n                var end_line = string.match(line_marker_re);\n                if (end_line) {\n                    string = string.replace(line_marker_re, ' ');\n                }\n                var cursor_end_line = false;\n                var settings = $.extend({\n                    prompt: '',\n                    last: false\n                }, options);\n                var position = settings.position;\n                var len = length(string);\n                var prompt = settings.prompt;\n                if (ch_unit_bug) {\n                    cursor.width(char_width);\n                }\n                var c;\n                if (position === len) {\n                    before.html(format(string));\n                    cursor.html('<span><span>&nbsp;</span></span>');\n                    after.html('');\n                } else if (position === 0) {\n                    before.html('');\n                    c = substring(string, 0, 1);\n                    cursor.html(format(c));\n                    after.html(format(substring(string, 1), prompt + c));\n                } else {\n                    var before_str = $.terminal.substring(string, 0, position);\n                    before.html(format(before_str, prompt));\n                    c = substring(string, position, position + 1);\n                    var c_before = (prompt + before_str).replace(/^.*\\t/, '');\n                    cursor.html(format(c, c_before));\n                    if (position === len - 1) {\n                        cursor_end_line = true;\n                        after.html('');\n                    } else {\n                        if (c.match(/\\t/)) {\n                            c_before = '';\n                        } else {\n                            c_before += c;\n                        }\n                        after.html(format(substring(string, position + 1), c_before));\n                    }\n                }\n                cursor.toggleClass('cmd-end-line', cursor_end_line);\n                // fix for animation when changing --animation dynamically\n                fix_cursor();\n                var cursor_len = $.terminal.length(cursor.text());\n                if (cursor_len > 1) {\n                    var node = cursor.find('[data-text]')[0];\n                    node.style.setProperty('--length', cursor_len);\n                }\n                // synchronize css animations (it's not that important because if user\n                // will change animation she should disable animation on span, but it\n                // looks nicer until she disable that inner animation)\n                restart_animation();\n            }\n            function div(string, before) {\n                var end_line = string.match(line_marker_re);\n                var result = '<div role=\"presentation\" aria-hidden=\"true\"';\n                if (end_line) {\n                    string = string.replace(line_marker_re, ' ');\n                    result += ' class=\"cmd-end-line\"';\n                }\n                result += '>' + format(string, before || '') + '</div>';\n                return result;\n            }\n            // -----------------------------------------------------------------\n            // :: Display lines after the cursor\n            // -----------------------------------------------------------------\n            function lines_after(lines) {\n                var last_ins = cursor_line;\n                $.each(lines, function(i, line) {\n                    last_ins = $(div(line)).insertAfter(last_ins);\n                });\n            }\n            // -----------------------------------------------------------------\n            // :: Display lines before the cursor\n            // -----------------------------------------------------------------\n            function lines_before(lines) {\n                $.each(lines, function(i, line) {\n                    cursor_line.before(div(line, i === 0 ? prompt_last_line : ''));\n                });\n            }\n            // -----------------------------------------------------------------\n            // :: Redraw function\n            // -----------------------------------------------------------------\n            return function() {\n                var string;\n                switch (typeof settings.mask) {\n                    case 'boolean':\n                        string = settings.mask ? command.replace(/./g, '*') : command;\n                        break;\n                    case 'string':\n                        string = command.replace(/./g, settings.mask);\n                        break;\n                }\n                var formatted = formatting(string);\n                var pos;\n                if (length(formatted) === text(string).length) {\n                    pos = position;\n                } else {\n                    pos = formatted_position;\n                }\n                var i;\n                wrapper.css('visibility', 'hidden');\n                wrapper.find('div:not(.cmd-cursor-line)').remove();\n                before.html('');\n                // long line\n                if (strlen(text(formatted)) > num_chars - prompt_len - 1 ||\n                    formatted.match(/\\n/)) {\n                    var tabs = formatted.match(/\\t/g);\n                    var original_string = formatted;\n                    //quick tabulation hack\n                    if (tabs) {\n                        formatted = formatted.replace(/\\t/g, '\\x00\\x00\\x00\\x00');\n                    }\n                    var array = get_splitted_command_line(formatted);\n                    if (tabs) {\n                        array = $.map(array, function(line) {\n                            return line.replace(/\\x00\\x00\\x00\\x00/g, '\\t');\n                        });\n                    }\n                    var first_len = length(array[0]);\n                    //cursor in first line\n                    if (first_len === 0 && array.length === 1) {\n                        // skip empty line\n                    } else if (pos < first_len) {\n                        draw_cursor_line(array[0], {\n                            length: array.length,\n                            position: pos,\n                            prompt: prompt_last_line\n                        });\n                        lines_after(array.slice(1));\n                    } else if (pos === first_len) {\n                        // first char acter of second line\n                        cursor_line.before(div(array[0], prompt_last_line));\n                        draw_cursor_line(array[1] || '', {\n                            length: array.length,\n                            position: 0,\n                            last: array.length <= 2\n                        });\n                        if (array.length > 2) {\n                            lines_after(array.slice(2));\n                        }\n                    } else {\n                        var last = array.slice(-1)[0];\n                        var len = length(original_string);\n                        var from_last = len - pos;\n                        var last_len = length(last);\n                        var new_pos = 0;\n                        if (from_last === -1) {\n                            from_last = 0;\n                        }\n                        if (from_last <= last_len) { // in last line\n                            lines_before(array.slice(0, -1));\n                            if (last_len === from_last) {\n                                new_pos = 0;\n                            } else {\n                                new_pos = last_len - from_last;\n                            }\n                            draw_cursor_line(last, {\n                                length: array.length,\n                                position: new_pos,\n                                last: true\n                            });\n                        } else {\n                            // more lines, cursor in the middle\n                            var line_index;\n                            var current;\n                            new_pos = pos;\n                            for (i = 0; i < array.length; ++i) {\n                                var current_len = $.terminal.length(array[i]);\n                                if (new_pos > current_len) {\n                                    new_pos -= current_len;\n                                } else {\n                                    break;\n                                }\n                            }\n                            current = array[i];\n                            line_index = i;\n                            // cursor on first character in line\n                            if (new_pos === length(current)) {\n                                new_pos = 0;\n                                current = array[++line_index];\n                                if (current === undefined) {\n                                    //should never happen\n                                    var msg = $.terminal.defaults.strings.redrawError;\n                                    throw new Error(msg);\n                                }\n                            }\n                            draw_cursor_line(current, {\n                                length: array.length,\n                                position: new_pos\n                            });\n                            lines_before(array.slice(0, line_index));\n                            lines_after(array.slice(line_index + 1));\n                        }\n                    }\n                    self.find('.cmd-cursor-line ~ div:last-of-type')\n                        .append('<span></span>');\n                } else if (formatted === '') {\n                    before.html('');\n                    cursor.html('<span><span>&nbsp;</span></span>');\n                    after.html('');\n                } else {\n                    draw_cursor_line(formatted, {\n                        length: 1,\n                        position: pos\n                    });\n                }\n                var in_line = cursor_line.prevUntil('.cmd-prompt').length;\n                if (is_css_variables_supported) {\n                    self[0].style.setProperty('--cursor-line', in_line);\n                } else {\n                    clip.css('top', in_line * 14 + 'px');\n                }\n                wrapper.css('visibility', '');\n            };\n        })();\n        // ---------------------------------------------------------------------\n        // :: find position that match display position for commands that\n        // :: change length by formatters\n        // ---------------------------------------------------------------------\n        var find_position = (function() {\n            function make_guess(string, position) {\n                var opts = $.extend({}, settings, {\n                    position: position\n                });\n                return $.terminal.apply_formatters(string, opts)[1];\n            }\n            function cmp(search_pos, pos, string) {\n                var guess = make_guess(string, pos);\n                if (guess === search_pos) {\n                    var next_guess = make_guess(string, pos + 1);\n                    if (next_guess > search_pos) {\n                        return 0;\n                    }\n                    return 1;\n                } else if (guess < search_pos) {\n                    return 1;\n                } else {\n                    return -1;\n                }\n            }\n            return function(string, formatted_position) {\n                if (formatted_position === 0) {\n                    return 0;\n                }\n                string = bare_text(string);\n                var codepoint_len = string.length;\n                var str = $.terminal.escape_brackets(command);\n                var pos = binary_search(0, codepoint_len, formatted_position, cmp, [str]);\n                var chars = $.terminal.split_characters(string);\n                if (codepoint_len > chars.length) {\n                    var len = 0;\n                    for (var i = 0; i < chars.length; ++i) {\n                        len += chars[i].length;\n                        if (len >= pos) {\n                            return len;\n                        }\n                    }\n                }\n                return pos;\n            };\n        })();\n        // ---------------------------------------------------------------------\n        // :: Draw prompt that can be a function or a string\n        // ---------------------------------------------------------------------\n        var prev_prompt_data;\n        var draw_prompt = (function() {\n            function set(prompt) {\n                prompt = $.terminal.apply_formatters(prompt, {});\n                prompt = $.terminal.normalize(prompt);\n                prompt = crlf(prompt);\n                last_rendered_prompt = prompt;\n                var lines = $.terminal.split_equal(prompt, num_chars).map(function(line) {\n                    if (!$.terminal.have_formatting(line)) {\n                        return '[[;;]' + line + ']';\n                    }\n                    return line;\n                });\n                var options = {\n                    char_width: settings.char_width\n                };\n                prompt_last_line = lines[lines.length - 1];\n                var encoded_last_line = $.terminal.encode(lines[lines.length - 1], {\n                    tabs: settings.tabs\n                });\n                var last_line = $.terminal.format(encoded_last_line, options);\n                var formatted = lines.slice(0, -1).map(function(line) {\n                    line = $.terminal.encode(line, {\n                        tabs: settings.tabs\n                    });\n                    return '<span class=\"cmd-line\">' +\n                        $.terminal.format(line, options) +\n                        '</span>';\n                }).concat([last_line]).join('\\n');\n                // update prompt if changed\n                if (prompt_node.html() !== formatted) {\n                    prompt_node.html(formatted);\n                    prompt_len = strlen(text(encoded_last_line));\n                }\n            }\n            return function() {\n                // the data is used as cancelable reference because we have ref\n                // data object that is hold in closure and we remove `set` function\n                // so previous call to function prompt will be ignored\n                if (prev_prompt_data && prev_prompt_data.set) {\n                    prev_prompt_data.set = $.noop;\n                    // remove reference for garbage collector\n                    prev_prompt_data = null;\n                }\n                switch (typeof prompt) {\n                    case 'string':\n                        set(prompt);\n                        break;\n                    case 'function':\n                        var data = prev_prompt_data = {\n                            set: set\n                        };\n                        var ret = prompt.call(self, function(string) {\n                            data.set(string);\n                        });\n                        if (ret && ret.then) {\n                            ret.then(data.set).catch(function(e) {\n                                var prompt = $.terminal.escape_brackets('[ERR]> ');\n                                data.set('[[;red;]' + prompt + ']');\n                                alert_exception('Prompt', e);\n                            });\n                        }\n                        break;\n                }\n            };\n        })();\n        // ---------------------------------------------------------------------\n        function fire_change_command() {\n            if (is_function(settings.onCommandChange)) {\n                settings.onCommandChange.call(self, command);\n            }\n        }\n        // ---------------------------------------------------------------------\n        function clean(string) {\n            return string.replace(/((?!\\\\).)\\\\(?:&#93;|])/g, '$1&#93;');\n        }\n        // ---------------------------------------------------------------------\n        // :: Command Line Methods\n        // ---------------------------------------------------------------------\n        $.extend(self, {\n            option: function(name, value) {\n                if (typeof value === 'undefined') {\n                    return settings[name];\n                } else {\n                    settings[name] = value;\n                }\n                return self;\n            },\n            name: function(string) {\n                if (string !== undefined) {\n                    name = string;\n                    var enabled = history && history.enabled() || !history;\n                    history = new History(\n                        name,\n                        settings.historySize,\n                        settings.history === 'memory'\n                    );\n                    // disable new history if old was disabled\n                    if (!enabled) {\n                        history.disable();\n                    }\n                    return self;\n                } else {\n                    return name;\n                }\n            },\n            purge: function() {\n                history.clear();\n                return self;\n            },\n            history: function() {\n                return history;\n            },\n            'delete': function(n, stay) {\n                var removed, string;\n                if (n === 0) {\n                    return \"\";\n                } else if (n < 0) {\n                    if (position > 0) {\n                        // this may look weird but if n is negative we need\n                        // to use +\n                        removed = command.slice(0, position).slice(n);\n                        string = bare_text(command);\n                        string = string.slice(0, position + n) +\n                            string.slice(position, string.length);\n                        if (!stay) {\n                            self.position(position + n);\n                        }\n                    }\n                } else if (command !== '') {\n                    string = text(command);\n                    if (position < string.length) {\n                        removed = string.slice(position).slice(0, n);\n                        string = string.slice(0, position) +\n                            string.slice(position + n, string.length);\n                    }\n                }\n                if (removed) {\n                    command = clean(string);\n                }\n                redraw();\n                fix_textarea();\n                fire_change_command();\n                return removed;\n            },\n            set: function(string, stay, silent) {\n                if (string !== undefined) {\n                    command = clean(string);\n                    if (!stay) {\n                        self.position(bare_text(command).length);\n                    }\n                    redraw();\n                    fix_textarea();\n                    if (!silent) {\n                        fire_change_command();\n                    }\n                }\n                return self;\n            },\n            keymap: function(new_keymap, value) {\n                function wrap(key, fn) {\n                    var original = default_keymap[key];\n                    if (is_function(original)) {\n                        original = original.bind(self);\n                    }\n                    return function(e) {\n                        // new keymap function will get default as 2nd argument\n                        return fn.call(self, e, original);\n                    };\n                }\n                if (typeof new_keymap === 'undefined') {\n                    return keymap;\n                } else if (typeof new_keymap === 'string') {\n                    if (typeof value === 'undefined') {\n                        if (keymap[new_keymap]) {\n                            return keymap[new_keymap];\n                        } else if (default_keymap[new_keymap]) {\n                            return default_keymap[new_keymap];\n                        }\n                    } else {\n                        keymap[new_keymap] = wrap(new_keymap, value);\n                    }\n                } else {\n                    keymap = $.extend(\n                        {},\n                        keymap ? keymap : default_keymap,\n                        $.omap(new_keymap || {}, wrap)\n                    );\n                    return self;\n                }\n            },\n            insert: function(string, stay) {\n                var bare_command = bare_text(command);\n                var len = bare_text(string).length;\n                if (position === bare_command.length) {\n                    string = bare_command + string;\n                } else if (position === 0) {\n                    string = string + bare_command;\n                } else {\n                    string = bare_command.slice(0, position) +\n                        string + bare_command.slice(position);\n                }\n                command = clean(string);\n                if (!stay) {\n                    self.position(len, true, true);\n                }\n                fix_textarea();\n                redraw();\n                fire_change_command();\n                return self;\n            },\n            get: function() {\n                return command;\n            },\n            commands: function(commands) {\n                if (commands) {\n                    settings.commands = commands;\n                    return self;\n                } else {\n                    return commands;\n                }\n            },\n            destroy: function() {\n                doc.unbind('keypress.cmd', keypress_event);\n                doc.unbind('keydown.cmd', keydown_event);\n                doc.unbind('input.cmd', input_event);\n                self.stopTime('blink', blink);\n                self.find('.cmd-wrapper').remove();\n                self.find('.cmd-prompt, .cmd-clipboard').remove();\n                self.removeClass('cmd').removeData('cmd').off('.cmd');\n                return self;\n            },\n            column: function(include_prompt) {\n                var before = command.substring(0, position);\n                if (position === 0 || !command.length) {\n                    return 0;\n                }\n                var re = /\\n?([^\\n]*)$/;\n                var match = before.match(re);\n                var col = match[1].length;\n                if (!have_newlines(before) && include_prompt) {\n                    col += prompt_len;\n                }\n                return col;\n            },\n            prompt: function(user_prompt) {\n                if (user_prompt === true) {\n                    return last_rendered_prompt;\n                } else if (user_prompt === undefined) {\n                    return prompt;\n                } else {\n                    var should_redraw = user_prompt !== prompt;\n                    if (typeof user_prompt === 'string' ||\n                        typeof user_prompt === 'function') {\n                        prompt = user_prompt;\n                    } else {\n                        throw new Error('prompt must be a function or string');\n                    }\n                    if (should_redraw) {\n                        draw_prompt();\n                        // we could check if command is longer then numchars-new\n                        // prompt\n                        redraw();\n                    }\n                    return self;\n                }\n            },\n            kill_text: function() {\n                return kill_text;\n            },\n            position: function(n, relative, silent) {\n                if (typeof n === 'number') {\n                    var pos = position;\n                    var len = bare_text(command).length;\n                    if (relative) {\n                        position += n;\n                    } else if (n < 0) {\n                        position = 0;\n                    } else if (n > len) {\n                        position = len;\n                    } else {\n                        position = n;\n                    }\n                    if (pos !== position && !silent) {\n                        redraw();\n                        if (is_function(settings.onPositionChange)) {\n                            settings.onPositionChange(position, formatted_position);\n                        }\n                        fix_textarea(true);\n                    }\n                    return self;\n                } else {\n                    return position;\n                }\n            },\n            refresh: function() {\n                draw_prompt();\n                redraw();\n                fix_textarea(true);\n                return self;\n            },\n            // if formatter change length of the strings (like emoji demo) we need to keep\n            // track of two different positions one for command and one for display\n            display_position: function(n, relative) {\n                if (n === undefined) {\n                    return formatted_position;\n                } else {\n                    // double escape\n                    var string = formatting($.terminal.escape_formatting(command), true);\n                    var len = length(string);\n                    var command_len = bare_text(command).length;\n                    var new_formatted_pos;\n                    if (relative) {\n                        new_formatted_pos = formatted_position + n;\n                    } else if (n > len) {\n                        new_formatted_pos = len;\n                    } else {\n                        new_formatted_pos = n;\n                    }\n                    if (text(string).length === length(command, true)) {\n                        formatted_position = new_formatted_pos;\n                        return self.position(new_formatted_pos);\n                    }\n                    if (len === new_formatted_pos) {\n                        formatted_position = new_formatted_pos;\n                        return self.position(command_len);\n                    }\n                    var pos = find_position(command, new_formatted_pos);\n                    if (pos !== -1) {\n                        formatted_position = new_formatted_pos;\n                        self.position(pos);\n                    }\n                    return self;\n                }\n            },\n            visible: (function() {\n                var visible = self.visible;\n                return function() {\n                    visible.apply(self, []);\n                    redraw();\n                    draw_prompt();\n                    return self;\n                };\n            })(),\n            show: (function() {\n                var show = self.show;\n                return function() {\n                    show.apply(self, []);\n                    redraw();\n                    draw_prompt();\n                    return self;\n                };\n            })(),\n            resize: function(num) {\n                char_width = get_char_width();\n                var new_num_chars;\n                if (typeof num === 'number') {\n                    new_num_chars = num;\n                } else {\n                    new_num_chars = get_num_chars(char_width);\n                }\n                if (num_chars !== new_num_chars || arguments[0] === true) {\n                    num_chars = new_num_chars;\n                    redraw();\n                    draw_prompt();\n                }\n                return self;\n            },\n            invoke_key: function(shortcut) {\n                var keys = shortcut.toUpperCase().split('+');\n                var key = keys.pop();\n                var ctrl = keys.indexOf('CTRL') !== -1;\n                var shift = keys.indexOf('SHIFT') !== -1;\n                var alt = keys.indexOf('ALT') !== -1;\n                var meta = keys.indexOf('META') !== -1;\n                var e = $.Event(\"keydown\", {\n                    ctrlKey: ctrl,\n                    shiftKey: shift,\n                    altKey: alt,\n                    metaKey: meta,\n                    which: reversed_keycodes[key],\n                    key: key\n                });\n                var doc = $(document.documentElement || window);\n                doc.trigger(e);\n                e = $.Event(\"keypress\");\n                e.key = key;\n                e.which = e.keyCode = 0;\n                doc.trigger(e);\n                return self;\n            },\n            enable: function(silent) {\n                if (!enabled) {\n                    enabled = true;\n                    self.addClass('enabled');\n                    try {\n                        if (clip.is(':not(:focus)')) {\n                            clip.focus();\n                        }\n                        clip.caret(position);\n                    } catch (e) {\n                        // firefox throw NS_ERROR_FAILURE - ignore\n                    }\n                    animation(true);\n                    if (!silent && is_function(prompt)) {\n                        draw_prompt();\n                    }\n                    fix_cursor();\n                    fix_textarea();\n                }\n                mobile_focus();\n                return self;\n            },\n            isenabled: function() {\n                return enabled;\n            },\n            disable: function(focus) {\n                enabled = false;\n                self.removeClass('enabled');\n                animation(false);\n                if (!focus) {\n                    mobile_focus();\n                }\n                return self;\n            },\n            mask: function(new_mask) {\n                if (typeof new_mask === 'undefined') {\n                    return settings.mask;\n                } else {\n                    settings.mask = new_mask;\n                    redraw();\n                    return self;\n                }\n            }\n        });\n        // ---------------------------------------------------------------------\n        // :: INIT\n        // ---------------------------------------------------------------------\n        self.name(settings.name || settings.prompt || '');\n        if (settings.prompt !== false) {\n            prompt = settings.prompt;\n            draw_prompt();\n        }\n        if (settings.enabled === true) {\n            self.enable();\n        }\n        char_width = get_char_width();\n        num_chars = get_num_chars(char_width);\n        if (!settings.history) {\n            history.disable();\n        }\n        var first_up_history = true;\n        // skip_keypress - hack for Android that was inserting characters on\n        // backspace\n        var skip_keypress = false;\n        var dead_key = false;\n        var single_key = false;\n        var no_keypress = false;\n        var no_key = false;\n        var no_keydown = true;\n        var backspace = false;\n        var process = false;\n        var hold = false;\n        var hold_pause = false;\n        var skip_insert;\n        // we hold text before keydown to fix backspace for Android/Chrome/SwiftKey\n        // keyboard that generate keycode 229 for all keys #296\n        var prev_command = '';\n        var prev_key;\n        // ---------------------------------------------------------------------\n        // :: Keydown Event Handler\n        // ---------------------------------------------------------------------\n        function is_backspace(e) {\n            return e.key.toUpperCase() === 'BACKSPACE' || e.which === 8;\n        }\n        // ---------------------------------------------------------------------\n        function is_single(e) {\n            return e.key && e.key.length === 1 && !e.ctrlKey;\n        }\n        // ---------------------------------------------------------------------\n        function is_delay_key(key) {\n            var specials = ['HOLD+SHIFT+BACKSPACE', 'HOLD+BACKSPACE'];\n            return specials.indexOf(key) !== -1 && settings.mobileDelete ||\n                settings.repeatTimeoutKeys.indexOf(key) !== -1;\n        }\n        // ---------------------------------------------------------------------\n        function clear_reverse_search_key(e) {\n            // arrows / Home / End / ENTER\n            return e.which === 35 || e.which === 36 ||\n                e.which === 37 || e.which === 38 ||\n                e.which === 39 || e.which === 40 ||\n                e.which === 13 || e.which === 27;\n        }\n        var skip_keydown = false;\n        // ---------------------------------------------------------------------\n        // function complexicity is 35 when adding this exception\n        // eslint-disable-next-line complexity\n        function keydown_event(e) {\n            debug('keydown \"' + e.key + '\" ' + e.fake + ' ' + e.which);\n            var result;\n            process = (e.key || '').toLowerCase() === 'process' || e.which === 0;\n            dead_key = no_keypress && single_key && !is_backspace(e);\n            // special keys don't trigger keypress fix #293\n            try {\n                if (!e.fake) {\n                    single_key = is_single(e);\n                    // chrome on android support key property but it's \"Unidentified\"\n                    no_key = String(e.key).toLowerCase() === 'unidentified';\n                    backspace = is_backspace(e);\n                }\n            } catch (exception) {}\n            // keydown created in input will have text already inserted and we\n            // want text before input\n            if (e.key === \"Unidentified\") {\n                no_keydown = true;\n                // android swift keyboard have always which == 229 we will triger proper\n                // event in input with e.fake == true\n                return;\n            }\n            if (!e.fake) {\n                no_keydown = false;\n            }\n            no_keypress = true;\n            // Meta+V did bind input but it didin't happen because terminal paste\n            // prevent native insert action\n            clip.off('input', paste);\n            var key = get_key(e);\n            if (is_function(settings.keydown)) {\n                e.key = ie_key_fix(e);\n                result = settings.keydown.call(self, e);\n                if (result !== undefined) {\n                    //skip_keypress = true;\n                    if (!result) {\n                        skip_insert = true;\n                    }\n                    return result;\n                }\n            }\n            if (key !== prev_key) {\n                clear_hold();\n            }\n            // CTRL+C hanlding is only exception of cmd aware terminal logic\n            // cmd need to call CTRL+C keymap when terminal is not enabled\n            if (enabled || (key === 'CTRL+C' && is_terminal_selected(self))) {\n                if (hold) {\n                    prev_key = key;\n                    key = 'HOLD+' + key;\n                    if (hold_pause) {\n                        return;\n                    }\n                    if (settings.holdRepeatTimeout > 0 && is_delay_key(key)) {\n                        hold_pause = true;\n                        self.oneTime(settings.holdRepeatTimeout, 'delay', function() {\n                            hold_pause = false;\n                        });\n                    }\n                } else {\n                    self.oneTime(settings.holdTimeout, 'hold', function() {\n                        hold = true;\n                    });\n                    prev_key = key;\n                }\n                // if e.fake ignore of space is handled in input and next keydown\n                // is not triggered this is just in case code since on Android\n                // keydown is not triggered only input so event is always fake on Android\n                if (!e.fake && is_android) {\n                    if (skip_keydown) {\n                        clear_hold();\n                        skip_keydown = false;\n                        return false;\n                    }\n                    if (mobile_ignore_key(key)) {\n                        skip_keydown = true;\n                    } else if (mobile_ignore_key(prev_key)) {\n                        // just in case next key is different then space\n                        skip_keydown = false;\n                    }\n                }\n                restart_animation();\n                // CTRL+V don't fire keypress in IE11\n                skip_insert = ['CTRL+V', 'META+V'].indexOf(key) !== -1;\n                if (e.which !== 38 && !(e.which === 80 && e.ctrlKey)) {\n                    first_up_history = true;\n                }\n                if (reverse_search && clear_reverse_search_key(e)) {\n                    clear_reverse_state();\n                    draw_prompt();\n                    if (e.which === 27) { // ESC\n                        self.set('');\n                    }\n                    redraw();\n                    if (e.which === 13) {\n                        keydown_event.call(this, e);\n                    }\n                } else if (is_function(keymap[key])) {\n                    result = keymap[key](e);\n                    if (result === true) {\n                        return;\n                    }\n                    if (result !== undefined) {\n                        return result;\n                    }\n                } else if (e.altKey) {\n                    return;\n                } else {\n                    skip_keypress = false;\n                    return;\n                }\n                // this will prevent for instance backspace to go back one page\n                //skip_keypress = true;\n                //e.preventDefault();\n            }\n        }\n        function clear_hold() {\n            self.stopTime('hold');\n            self.stopTime('delay');\n            hold_pause = hold = false;\n        }\n        var doc = $(document.documentElement || window);\n        self.keymap(settings.keymap || {});\n        function keypress_event(e) {\n            debug('keypress \"' + e.key + '\" ' + e.fake);\n            clear_hold();\n            var result;\n            if (!e.fake) {\n                no_keypress = false;\n            }\n            if ((e.ctrlKey || e.metaKey) && !e.altKey) {\n                return;\n            }\n            if (skip_keypress) {\n                return;\n            }\n            if (is_function(settings.keypress)) {\n                result = settings.keypress.call(self, e);\n                if (result !== undefined) {\n                    if (!result) {\n                        skip_insert = true;\n                    }\n                    return result;\n                }\n            }\n            if (enabled) {\n                if (e.fake) {\n                    // event created in input, we prevent inserting text\n                    // in different interpreter when keydown called pop\n                    return;\n                }\n                // key polyfill is not correct for keypress\n                // https://github.com/cvan/keyboardevent-key-polyfill/issues/15\n                var key;\n                if (is_key_native) {\n                    key = e.key;\n                    // fixing IE inconsistency #362\n                    var normalized = key.toUpperCase();\n                    if (key_mapping[normalized]) {\n                        key = key_mapping[normalized];\n                    }\n                }\n                if (!key || no_key) {\n                    key = String.fromCharCode(e.which);\n                }\n                if ($.inArray(e.which, [13, 0, 8]) > -1) {\n                    if (e.keyCode === 123) { // for F12 which === 0\n                        return;\n                    }\n                    return false;\n                    // which === 100 - d\n                } else if (key && (!e.ctrlKey || (e.ctrlKey && e.ctrlKey)) &&\n                           (!(e.altKey && e.which === 100) || e.altKey) &&\n                           !dead_key) {\n                    // dead_key are handled by input event\n                    if (reverse_search) {\n                        rev_search_str += key;\n                        reverse_history_search();\n                        draw_reverse_prompt();\n                    } else if (key.length === 1) {\n                        self.insert(key);\n                    }\n                }\n            }\n        }\n        function event(type, chr, which) {\n            var event = $.Event(type);\n            event.which = which;\n            event.key = chr;\n            event.fake = true;\n            doc.trigger(event);\n        }\n        var skip_input = false;\n        function input_event() {\n            debug('input ' + no_keydown + ' || ' + process + ' ((' + no_keypress +\n                  ' || ' + dead_key + ') && !' + skip_insert + ' && (' + single_key +\n                  ' || ' + no_key + ') && !' + backspace + ')');\n            // correct for fake space used for select all context menu hack\n            var val = clip.val();\n            if (!is_mobile) {\n                val = val.replace(/^ /, '');\n            }\n            // Some Androids don't fire keypress - #39\n            // if there is dead_key we also need to grab real character #158\n            // Firefox/Android with google keyboard don't fire keydown and keyup #319\n            if ((no_keydown || process || ((no_keypress || dead_key) && !skip_insert &&\n                                          (single_key || no_key) && !backspace)) &&\n                val !== command) {\n                var pos = position;\n                // backspace is set in keydown if no keydown we need to get new one\n                if (no_keydown) {\n                    var cmd = prev_command;\n                    backspace = cmd.slice(0, cmd.length - 1).length === val.length;\n                }\n                if (skip_input) {\n                    skip_input = false;\n                    clip.val(command);\n                    return;\n                }\n                if (reverse_search) {\n                    rev_search_str = val;\n                    reverse_history_search();\n                    draw_reverse_prompt();\n                } else {\n                    var str = val.slice(position);\n                    if (str.length === 1 || backspace) {\n                        // original not optimized function called once\n                        var chr = get_next_character(str);\n                        if (mobile_ignore_key(chr)) {\n                            skip_input = true;\n                        }\n                        // we trigger events so keypress and keydown callback work\n                        if (no_keydown) {\n                            var keycode;\n                            if (backspace) {\n                                keycode = 8;\n                            } else {\n                                keycode = str.toUpperCase().charCodeAt(0);\n                            }\n                            event('keydown', backspace ? 'Backspace' : str, keycode);\n                        }\n                        if (no_keypress && !backspace) {\n                            event('keypress', chr, str.charCodeAt(0));\n                        }\n                    }\n                    if (backspace) {\n                        prev_command = command;\n                        return;\n                    }\n                    // if user return false in keydown we don't want to insert text\n                    if (skip_insert) {\n                        skip_insert = false;\n                        return;\n                    }\n                    self.set(val);\n                }\n                if (backspace) {\n                    self.position(pos - 1);\n                } else {\n                    // user enter more then one character if click on complete word\n                    // on android\n                    self.position(pos + Math.abs(val.length - prev_command.length));\n                }\n            }\n            prev_command = command;\n            skip_insert = false;\n            no_keydown = true;\n        }\n        doc.bind('keypress.cmd', keypress_event);\n        doc.bind('keydown.cmd', keydown_event);\n        doc.bind('keyup.cmd', clear_hold);\n        doc.bind('input.cmd', input_event);\n        (function() {\n            var was_down = false;\n            var count = 0;\n            self.on('mousedown.cmd', function() {\n                was_down = true;\n            }).on('mouseup.cmd', function(e) {\n                function trigger() {\n                    var $target = $(e.target);\n                    var is_prompt = $target.is('.cmd-prompt');\n                    if (!is_prompt && down && get_selected_html() === '') {\n                        if (enabled) {\n                            if ($target.is('.cmd')) {\n                                self.position(text(command).length);\n                            } else {\n                                self.display_position(get_char_pos(e));\n                            }\n                        }\n                    }\n                    count = 0;\n                }\n                // we get button from event for testing normally it's on originalEvent\n                var button;\n                if (e.originalEvent === undefined) {\n                    button = e.button;\n                } else {\n                    button = e.originalEvent.button;\n                }\n                if (button === 0 && get_selected_html() === '') {\n                    var name = 'click_' + id;\n                    if (++count === 1) {\n                        var down = was_down;\n                        if (enabled) {\n                            if (settings.clickTimeout === 0) {\n                                trigger();\n                            } else {\n                                self.oneTime(settings.clickTimeout, name, trigger);\n                            }\n                        } else {\n                            count = 0;\n                        }\n                    } else {\n                        self.stopTime(name);\n                        count = 0;\n                    }\n                }\n                was_down = false;\n            });\n        })();\n        self.data('cmd', self);\n        if (!('KeyboardEvent' in window && 'key' in window.KeyboardEvent.prototype)) {\n            setTimeout(function() {\n                throw new Error('key event property not supported try https://github.' +\n                                'com/inexorabletash/polyfill/blob/master/keyboard.js');\n            }, 0);\n        }\n        return self;\n    }; // cmd plugin\n    // -------------------------------------------------------------------------\n    var strlen = (function() {\n        if (typeof wcwidth === 'undefined') {\n            return function(string) {\n                return $.terminal.length(string);\n            };\n        } else {\n            return wcwidth;\n        }\n    })();\n    // -------------------------------------------------------------------------\n    function count_selfclosing_formatting(string) {\n        var count = 0;\n        if ($.terminal.have_formatting(string)) {\n            var re = new RegExp(format_parts_re, 'i');\n            $.terminal.format_split(string).forEach(function(str) {\n                if ($.terminal.is_formatting(str)) {\n                    var m = str.match(re);\n                    if (m && m[1].match(/@/) && m[6] === '') {\n                        count++;\n                    }\n                }\n            });\n        }\n        return count;\n    }\n    // -------------------------------------------------------------------------\n    function bare_text(string) {\n        if (!string.match(/&/)) {\n            return string;\n        }\n        return $('<span>' + safe(string) + '</span>').text();\n    }\n    // -------------------------------------------------------------------------\n    function text(string) {\n        return bare_text($.terminal.strip(string));\n    }\n    // -------------------------------------------------------------------------\n    function safe(string) {\n        if (!string.match(/[<>&]/)) {\n            return string;\n        }\n        return string.replace(/&(?![^;]+;)/g, '&amp;')\n            .replace(/>/g, '&gt;').replace(/</g, '&lt;');\n    }\n    // -------------------------------------------------------------------------\n    function crlf(string) {\n        return string.replace(/\\r/g, '');\n    }\n    // -------------------------------------------------------------------------\n    function char_len(chr) {\n        return entity_re.test(chr) ? 1 : chr.length;\n    }\n    // -------------------------------------------------------------------------\n    function make_re_fn(re) {\n        return function(string) {\n            var m = string.match(re);\n            if (starts_with(m)) {\n                return m[1];\n            }\n        };\n    }\n    // -------------------------------------------------------------------------\n    function starts_with(match) {\n        return match && match.index === 0;\n    }\n    // -------------------------------------------------------------------------\n    // :: optimized higher order function that it check complex regexes\n    // :: only when bigger string match those regexes, function is always\n    // :: used in loop when you process whole string, it's used to create local\n    // :: get_next_character function only cmd in input use original\n    // :: not optimized function\n    // -------------------------------------------------------------------------\n    function make_next_char_fun(string) {\n        var tests = [];\n        [\n            entity_re,\n            emoji_re,\n            combine_chr_re\n        ].forEach(function(re) {\n            if (string.match(re)) {\n                tests.push(make_re_fn(re));\n            }\n        });\n        if (string.match(astral_symbols_re)) {\n            tests.push(function(string) {\n                var m1 = string.match(astral_symbols_re);\n                if (starts_with(m1)) {\n                    var m2 = string.match(combine_chr_re);\n                    if (m2 && m2.index === 1) {\n                        return string.slice(0, 3);\n                    }\n                    return m1[1];\n                }\n            });\n        }\n        return function(string) {\n            for (var i = 0; i < tests.length; ++i) {\n                var test = tests[i];\n                var ret = test(string);\n                if (ret) {\n                    return ret;\n                }\n            }\n            return string[0];\n        };\n    }\n    // -------------------------------------------------------------------------\n    // :: function that return character from beginning of the string\n    // :: counting emoji, suroggate pairs and combine characters\n    // -------------------------------------------------------------------------\n    function get_next_character(string) {\n        var match_entity = string.match(entity_re);\n        if (starts_with(match_entity)) {\n            return match_entity[1];\n        }\n        var match_combo = string.match(combine_chr_re);\n        if (starts_with(match_combo)) {\n            return match_combo[1];\n        }\n        var match_emoji = string.match(emoji_re);\n        if (starts_with(match_emoji)) {\n            return match_emoji[1];\n        } else if (string.charCodeAt(0) < 255) {\n            return string[0];\n        } else {\n            var astral_match = string.match(astral_symbols_re);\n            if (starts_with(astral_match)) {\n                match_combo = string.match(combine_chr_re);\n                if (match_combo && match_combo.index === 1) {\n                    return string.slice(0, 3);\n                }\n                return string.slice(0, 2);\n            } else {\n                return string[0];\n            }\n        }\n    }\n    // -------------------------------------------------------------------------\n    // normalize position for counting emoji and extra chars\n    // -------------------------------------------------------------------------\n    function normalize_position(string, position) {\n        if (position === 0) {\n            return position;\n        }\n        string = $.terminal.strip(string);\n        var result = $.terminal.split_characters(string).reduce(function(acc, chr) {\n            if (typeof acc === 'number') {\n                return acc;\n            }\n            var length = acc.length + char_len(chr);\n            if (length >= position) {\n                return acc.position + 1;\n            }\n            return {\n                position: acc.position + 1,\n                length: length\n            };\n        }, {position: 0, length: 0});\n        if (typeof result === 'number') {\n            return result;\n        } else {\n            return result.position;\n        }\n    }\n    // -------------------------------------------------------------------------\n    function char_width_prop(len, options) {\n        if (is_ch_unit_supported) {\n            return 'width: ' + len + 'ch';\n        } else if (!is_css_variables_supported) {\n            if (options.char_width) {\n                return 'width: ' + (options.char_width * len) + 'px';\n            }\n        } else {\n            return '--length: ' + len;\n        }\n        return '';\n    }\n    // -------------------------------------------------------------------------\n    // options {char_width}\n    function extra_css(text, options) {\n        if (typeof wcwidth !== 'undefined') {\n            var bare = bare_text(text);\n            var len = strlen(bare);\n            if (len !== $.terminal.length(bare)) {\n                return char_width_prop(len, options);\n            }\n        }\n        return '';\n    }\n    // -------------------------------------------------------------------------\n    function wide_characters(text, options) {\n        if (typeof wcwidth !== 'undefined') {\n            var bare = bare_text(text);\n            var chars = $.terminal.split_characters(bare);\n            if (chars.length === 1) {\n                return text;\n            }\n            var specs = chars.map(function(chr) {\n                return {\n                    len: strlen(chr),\n                    chr: chr\n                };\n            }).reduce(function(arr, spec) {\n                var last = arr[arr.length - 1];\n                if (last) {\n                    if (last.len !== spec.len) {\n                        return arr.concat([{\n                            sum: spec.len,\n                            len: spec.len,\n                            specs: [spec]\n                        }]);\n                    } else {\n                        arr.pop();\n                        return arr.concat([{\n                            sum: last.sum + spec.len,\n                            len: last.len,\n                            specs: last.specs.concat(spec)\n                        }]);\n                    }\n                }\n                return [{\n                    sum: spec.len,\n                    specs: [spec],\n                    len: spec.len\n                }];\n            }, []);\n            return specs.map(function(spec) {\n                if (spec.len === 1) {\n                    return spec.chr;\n                }\n                var style = char_width_prop(spec.sum, options);\n                if (spec.sum === chars.length || !style.length) {\n                    return '<span>' + make_string(spec) + '</span>';\n                } else if (spec.specs.length > 1) {\n                    return wrap(style, spec.specs.map(function(spec) {\n                        return wrap(char_width_prop(spec.len), spec.chr);\n                    }).join(''));\n                } else {\n                    return wrap(style, make_string(spec));\n                }\n            }).join('');\n        }\n        function make_string(spec) {\n            return spec.specs.map(function(spec) {\n                return spec.chr;\n            }).join('');\n        }\n        function wrap(style, str) {\n            return '<span style=\"' + style + '\">' + str + '</span>';\n        }\n        return text;\n    }\n    // ---------------------------------------------------------------------\n    // :: Binary search utility\n    // ---------------------------------------------------------------------\n    function binary_search(start, end, search_pos, compare_fn, more_args) {\n        var len = end - start;\n        var mid = start + Math.floor(len / 2);\n        var args = [search_pos, mid].concat(more_args);\n        var cmp = compare_fn.apply(null, args);\n        if (cmp === 0) {\n            return mid;\n        } else if (cmp > 0 && len > 1) {\n            return binary_search(\n                mid,\n                end,\n                search_pos,\n                compare_fn,\n                more_args\n            );\n        } else if (cmp < 0 && len > 1) {\n            return binary_search(\n                start,\n                mid,\n                search_pos,\n                compare_fn,\n                more_args\n            );\n        } else {\n            return -1;\n        }\n    }\n    // -----------------------------------------------------------------\n    // :: selection utilities - should work in modern browser including IE9\n    // -----------------------------------------------------------------\n    function is_terminal_selected(cmd) {\n        if (is_function(window.getSelection)) {\n            var selection = window.getSelection();\n            if (selection.toString()) {\n                var node = selection.getRangeAt(0).startContainer.parentNode;\n                var term = $(node).closest('.terminal');\n                return term.length && (cmd && term.find('.cmd').is(cmd) || !cmd);\n            }\n        }\n    }\n    // -----------------------------------------------------------------\n    function get_selected_html() {\n        var html = '';\n        if (is_function(window.getSelection)) {\n            var sel = window.getSelection();\n            if (sel.rangeCount) {\n                var container = document.createElement('div');\n                for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n                    container.appendChild(sel.getRangeAt(i).cloneContents());\n                }\n                html = container.innerHTML;\n            }\n        }\n        return html;\n    }\n    // -----------------------------------------------------------------\n    function with_selection(fn) {\n        var html = '';\n        var ranges = [];\n        if (is_function(window.getSelection)) {\n            var selection = window.getSelection();\n            if (selection.rangeCount) {\n                var container = document.createElement(\"div\");\n                for (var i = 0, len = selection.rangeCount; i < len; ++i) {\n                    var range = selection.getRangeAt(i).cloneRange();\n                    ranges.push(range);\n                    container.appendChild(range.cloneContents());\n                }\n                html = container.innerHTML;\n            }\n        }\n        fn(html);\n        if (ranges.length) {\n            selection.removeAllRanges();\n            ranges.forEach(function(range) {\n                selection.addRange(range);\n            });\n        }\n        return html !== '';\n    }\n    // -----------------------------------------------------------------\n    function process_selected_line() {\n        var $self = $(this);\n        var result = $self.text();\n        if ($self.hasClass('cmd-end-line')) {\n            result += '\\n';\n        }\n        return result;\n    }\n    // -----------------------------------------------------------------\n    function process_div(element) {\n        // span is empty line, div is default case with text\n        return $(element).find('> div, > span')\n            .map(process_selected_line).get().join('\\n').replace(/\\n$/, '');\n    }\n    // -----------------------------------------------------------------\n    function process_selected_html(html) {\n        var stdout;\n        var text = '';\n        var $html = $('<div>' + html + '</div>');\n        if (html.match(/<\\/div>/)) {\n            // match multiple echo output\n            stdout = $html.find('div[data-index]').map(function() {\n                return process_div(this);\n            }).get().join('\\n');\n            // match inside single echo output\n            if (!stdout && html.match(/style=\"width: 100%;?\"/)) {\n                stdout = process_div($html);\n            }\n            text = stdout;\n        }\n        var $prompt = $html.find('.cmd-prompt');\n        if ($prompt.length) {\n            if (text.length) {\n                text += '\\n';\n            }\n            text += $prompt.text();\n        }\n        var $cmd_lines = $html.find('[role=\"presentation\"]');\n        if ($cmd_lines.length) {\n            text += $cmd_lines.map(process_selected_line).get().join('');\n        }\n        if (!text.length && html) {\n            text = $html.text();\n        }\n        return text.replace(/\\xA0/g, ' '); // fix &nbsp; space\n    }\n    // ---------------------------------------------------------------------\n    // :: copy given DOM element text to clipboard\n    // ---------------------------------------------------------------------\n    var text_to_clipboard;\n    if (is_function(document.queryCommandSupported) &&\n        document.queryCommandSupported('copy')) {\n        text_to_clipboard = function text_to_clipboard($textarea, text) {\n            var val = $textarea.val();\n            var had_focus = $textarea.is(':focus');\n            var pos = $textarea.caret();\n            $textarea.val(text).focus();\n            $textarea[0].select();\n            document.execCommand('copy');\n            $textarea.val(val);\n            if (had_focus) {\n                $textarea.caret(pos);\n            }\n            return true;\n        };\n    } else {\n        text_to_clipboard = $.noop;\n    }\n    // ---------------------------------------------------------------------\n    var get_textarea_selection = (function() {\n        var textarea = document.createElement('textarea');\n        var selectionStart = 'selectionStart' in textarea;\n        textarea = null;\n        if (selectionStart) {\n            return function(textarea) {\n                var length = textarea.selectionEnd - textarea.selectionStart;\n                return textarea.value.substr(textarea.selectionStart, length);\n            };\n        } else if (document.selection) {\n            return function() {\n                var range = document.selection.createRange();\n                return range.text();\n            };\n        } else {\n            return function() {\n                return '';\n            };\n        }\n    })();\n    // ---------------------------------------------------------------------\n    function clear_textarea_selection(textarea) {\n        textarea.selectionStart = textarea.selectionEnd = 0;\n    }\n    // ---------------------------------------------------------------------\n    // :: return string that are common in all elements of the array\n    // ---------------------------------------------------------------------\n    function common_string(string, array, matchCase) {\n        if (!array.length) {\n            return '';\n        }\n        var type = string_case(string);\n        var result = [];\n        for (var j = string.length; j < array[0].length; ++j) {\n            var push = false;\n            var candidate = array[0].charAt(j),\n                candidateLower = candidate.toLowerCase();\n            for (var i = 1; i < array.length; ++i) {\n                push = true;\n                var current = array[i].charAt(j),\n                    currentLower = current.toLowerCase();\n                if (candidate !== current) {\n                    if (matchCase || type === 'mixed') {\n                        push = false;\n                        break;\n                    } else if (candidateLower === currentLower) {\n                        if (type === 'lower') {\n                            candidate = candidate.toLowerCase();\n                        } else if (type === 'upper') {\n                            candidate = candidate.toUpperCase();\n                        } else {\n                            push = false;\n                            break;\n                        }\n                    } else {\n                        push = false;\n                        break;\n                    }\n                }\n            }\n            if (push) {\n                result.push(candidate);\n            } else {\n                break;\n            }\n        }\n        return string + result.join('');\n    }\n    // ---------------------------------------------------------------------\n    function trigger_terminal_change(next) {\n        terminals.forEach(function(term) {\n            term.settings().onTerminalChange.call(term, next);\n        });\n    }\n    // ---------------------------------------------------------------------\n    var select = (function() {\n        if (window.getSelection) {\n            var selection = window.getSelection();\n            if (selection.setBaseAndExtent) {\n                return function(start, end) {\n                    var selection = window.getSelection();\n                    selection.setBaseAndExtent(start, 0, end, 1);\n                };\n            } else {\n                return function(start, end) {\n                    var selection = window.getSelection();\n                    var range = document.createRange();\n                    range.setStart(start, 0);\n                    range.setEnd(end, end.childNodes.length);\n                    selection.removeAllRanges();\n                    selection.addRange(range);\n                };\n            }\n        } else {\n            return $.noop;\n        }\n    })();\n    // -------------------------------------------------------------------------\n    function process_command(string, fn) {\n        var array = string.match(command_re) || [];\n        if (array.length) {\n            var name = array.shift();\n            var args = $.map(array, function(arg) {\n                if (arg.match(/^[\"']/)) {\n                    arg = arg.replace(/\\n/g, '\\\\u0000\\\\u0000\\\\u0000\\\\u0000');\n                    arg = fn(arg);\n                    return arg.replace(/\\x00\\x00\\x00\\x00/g, '\\n');\n                }\n                return fn(arg);\n            });\n            var quotes = $.map(array, function(arg) {\n                var m = arg.match(/^(['\"]).*\\1$/);\n                return m && m[1] || '';\n            });\n            var rest = string.slice(name.length).trim();\n            return {\n                command: string,\n                name: name,\n                args: args,\n                args_quotes: quotes,\n                rest: rest\n            };\n        } else {\n            return {\n                command: string,\n                name: '',\n                args: [],\n                args_quotes: quotes,\n                rest: ''\n            };\n        }\n    }\n    // -------------------------------------------------------------------------\n    $.terminal = {\n        version: '2.12.0',\n        date: 'Wed, 01 Jan 2020 17:03:16 +0000',\n        // colors from https://www.w3.org/wiki/CSS/Properties/color/keywords\n        color_names: [\n            'transparent', 'currentcolor', 'black', 'silver', 'gray', 'white',\n            'maroon', 'red', 'purple', 'fuchsia', 'green', 'lime', 'olive',\n            'yellow', 'navy', 'blue', 'teal', 'aqua', 'aliceblue',\n            'antiquewhite', 'aqua', 'aquamarine', 'azure', 'beige', 'bisque',\n            'black', 'blanchedalmond', 'blue', 'blueviolet', 'brown',\n            'burlywood', 'cadetblue', 'chartreuse', 'chocolate', 'coral',\n            'cornflowerblue', 'cornsilk', 'crimson', 'cyan', 'darkblue',\n            'darkcyan', 'darkgoldenrod', 'darkgray', 'darkgreen', 'darkgrey',\n            'darkkhaki', 'darkmagenta', 'darkolivegreen', 'darkorange',\n            'darkorchid', 'darkred', 'darksalmon', 'darkseagreen',\n            'darkslateblue', 'darkslategray', 'darkslategrey', 'darkturquoise',\n            'darkviolet', 'deeppink', 'deepskyblue', 'dimgray', 'dimgrey',\n            'dodgerblue', 'firebrick', 'floralwhite', 'forestgreen', 'fuchsia',\n            'gainsboro', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'green',\n            'greenyellow', 'grey', 'honeydew', 'hotpink', 'indianred', 'indigo',\n            'ivory', 'khaki', 'lavender', 'lavenderblush', 'lawngreen',\n            'lemonchiffon', 'lightblue', 'lightcoral', 'lightcyan',\n            'lightgoldenrodyellow', 'lightgray', 'lightgreen', 'lightgrey',\n            'lightpink', 'lightsalmon', 'lightseagreen', 'lightskyblue',\n            'lightslategray', 'lightslategrey', 'lightsteelblue', 'lightyellow',\n            'lime', 'limegreen', 'linen', 'magenta', 'maroon',\n            'mediumaquamarine', 'mediumblue', 'mediumorchid', 'mediumpurple',\n            'mediumseagreen', 'mediumslateblue', 'mediumspringgreen',\n            'mediumturquoise', 'mediumvioletred', 'midnightblue', 'mintcream',\n            'mistyrose', 'moccasin', 'navajowhite', 'navy', 'oldlace', 'olive',\n            'olivedrab', 'orange', 'orangered', 'orchid', 'palegoldenrod',\n            'palegreen', 'paleturquoise', 'palevioletred', 'papayawhip',\n            'peachpuff', 'peru', 'pink', 'plum', 'powderblue', 'purple', 'red',\n            'rosybrown', 'royalblue', 'saddlebrown', 'salmon', 'sandybrown',\n            'seagreen', 'seashell', 'sienna', 'silver', 'skyblue', 'slateblue',\n            'slategray', 'slategrey', 'snow', 'springgreen', 'steelblue', 'tan',\n            'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'wheat',\n            'white', 'whitesmoke', 'yellow', 'yellowgreen', 'rebeccapurple'],\n        // for unit tests\n        Cycle: Cycle,\n        History: History,\n        Stack: Stack,\n        // ---------------------------------------------------------------------\n        // :: Validate html color (it can be name or hex)\n        // ---------------------------------------------------------------------\n        valid_color: function valid_color(color) {\n            if (color.match(color_hex_re)) {\n                return true;\n            } else {\n                return $.inArray(color.toLowerCase(), $.terminal.color_names) !== -1;\n            }\n        },\n        // ---------------------------------------------------------------------\n        // :: function check if given string contain invalid strings\n        // ---------------------------------------------------------------------\n        unclosed_strings: function unclosed_strings(string) {\n            return !!string.match(unclosed_strings_re);\n        },\n        // ---------------------------------------------------------------------\n        // :: Escape all special regex characters, so it can be use as regex to\n        // :: match exact string that contain those characters\n        // ---------------------------------------------------------------------\n        escape_regex: function escape_regex(str) {\n            if (typeof str === 'string') {\n                var special = /([-\\\\^$[\\]()+{}?*.|])/g;\n                return str.replace(special, '\\\\$1');\n            }\n        },\n        // ---------------------------------------------------------------------\n        // :: test if string contain formatting\n        // ---------------------------------------------------------------------\n        have_formatting: function have_formatting(str) {\n            return typeof str === 'string' && !!str.match(format_exist_re);\n        },\n        is_formatting: function is_formatting(str) {\n            return typeof str === 'string' && !!str.match(format_full_re);\n        },\n        // ---------------------------------------------------------------------\n        // :: return array of formatting and text between them\n        // ---------------------------------------------------------------------\n        format_split: function format_split(str) {\n            return str.split(format_split_re).filter(Boolean);\n        },\n        // ---------------------------------------------------------------------\n        // :: replace that return position after replace for working with\n        // :: replacement that change length of the string\n        // :: source https://stackoverflow.com/a/46756077/387194\n        // ---------------------------------------------------------------------\n        tracking_replace: function tracking_replace(string, rex, replacement, position) {\n            if (!(rex instanceof RegExp)) {\n                throw new Error('tracking_replace: Second argument need to be RegExp');\n            }\n            function substring(string, start, end) {\n                return string.slice(start, end);\n            }\n            function length(string) {\n                return $.terminal.strip(string).length;\n            }\n            var new_string = \"\";\n            var match;\n            var index = 0;\n            var rep_string;\n            var new_position = position;\n            var start;\n            rex.lastIndex = 0; // Just to be sure\n            while ((match = rex.exec(string))) {\n                // if regex don't have g flag lastIndex will not work\n                if (rex.global) {\n                    // Add any of the original string we just skipped\n                    var last_index = length(substring(string, 0, rex.lastIndex));\n                    start = last_index - length(match[0]);\n                } else {\n                    start = match.index;\n                    last_index = start + length(match[0]);\n                }\n                if (index < start) {\n                    new_string += substring(string, index, start);\n                }\n                index = last_index;\n                // Build the replacement string. This just handles $$ and $n,\n                // you may want to add handling for $`, $', and $&.\n                if (typeof replacement === 'function') {\n                    rep_string = replacement.apply(null, match);\n                } else {\n                    rep_string = replacement.replace(/\\$(\\$|\\d)/g, function(m, c0) {\n                        if (c0 === \"$\") {\n                            return \"$\";\n                        }\n                        return match[c0];\n                    });\n                }\n                // Add on the replacement\n                new_string += rep_string;\n                // If the position is affected...\n                if (start < position) {\n                    // ... update it:\n                    var rep_len = length(rep_string);\n                    rep_len += count_selfclosing_formatting(rep_string);\n                    if (last_index < position) {\n                        // It's after the replacement, move it\n                        new_position = Math.max(\n                            0,\n                            new_position +\n                            rep_len -\n                            length(match[0])\n                        );\n                    } else {\n                        // It's *in* the replacement, put it just after\n                        new_position += rep_len - (position - start);\n                    }\n                }\n                // If the regular expression doesn't have the g flag, break here so\n                // we do just one replacement (and so we don't have an endless loop!)\n                if (!rex.global) {\n                    break;\n                }\n            }\n            // Add on any trailing text in the string\n            if (index < length(string)) {\n                new_string += substring(string, index);\n            }\n            // Return the string and the updated position\n            if (string === new_string) {\n                return [string, position];\n            }\n            return [new_string, new_position];\n        },\n        // ---------------------------------------------------------------------\n        // :: helper function used by substring and split_equal it loop over\n        // :: string and execute callback with text count and other data\n        // ---------------------------------------------------------------------\n        iterate_formatting: function iterate_formatting(string, callback) {\n            function is_space(i) {\n                return string.slice(i - 6, i) === '&nbsp;' ||\n                    string.slice(i - 1, i).match(/\\s/);\n            }\n            // ----------------------------------------------------------------\n            function match_entity(index) {\n                return string.slice(index).match(entity_re);\n            }\n            // ----------------------------------------------------------------\n            function is_open_formatting(i) {\n                return string[i] === '[' && string[i + 1] === '[';\n            }\n            // ----------------------------------------------------------------\n            function is_escape_bracket(i) {\n                return string[i - 1] !== '\\\\' && string[i] === '\\\\' &&\n                    string[i + 1] === ']';\n            }\n            // ----------------------------------------------------------------\n            function is_text(i) {\n                return not_formatting && (string[i] !== ']' || !have_formatting)\n                    && !opening;\n            }\n            // ----------------------------------------------------------------\n            // :: function will skip to next character in main loop\n            // :: TODO: improve performance of emoji regex and check whole\n            // :: string it's complex string if not use simple function\n            // ----------------------------------------------------------------\n            var get_next_character = make_next_char_fun(string);\n            function next_iteration() {\n                var char = get_next_character(substring);\n                if (char.length > 1 && $.terminal.length(substring) > 1) {\n                    return char.length - 1;\n                }\n                return 0;\n            }\n            // ----------------------------------------------------------------\n            function is_next_space() {\n                return (is_space(i) && (not_formatting || opening)) &&\n                    (space === -1 && prev_space !== i || space !== -1);\n            }\n            // ----------------------------------------------------------------\n            // :: last iteration or one before closing formatting\n            // ----------------------------------------------------------------\n            var last = false;\n            function is_last() {\n                if (i === string.length - 1 && !last) {\n                    last = true;\n                } else {\n                    last = !!substring.match(/^.]$/);\n                }\n                return last;\n            }\n            // ----------------------------------------------------------------\n            var have_formatting = $.terminal.have_formatting(string);\n            var formatting = '';\n            var in_text = false;\n            var count = 0;\n            var match;\n            var space = -1;\n            var space_count = -1;\n            var prev_space;\n            var length = 0;\n            var offset = 0;\n            var re_ent = /(&[^;]+);$/;\n            for (var i = 0; i < string.length; i++) {\n                var substring = string.slice(i);\n                match = substring.match(format_start_re);\n                if (match) {\n                    formatting = match[1];\n                    in_text = false;\n                } else if (formatting) {\n                    if (string[i] === ']') {\n                        if (in_text) {\n                            formatting = '';\n                            in_text = false;\n                        } else {\n                            in_text = true;\n                        }\n                    }\n                } else {\n                    in_text = true;\n                }\n                var not_formatting = (formatting && in_text) || !formatting;\n                var opening = is_open_formatting(i);\n                if (is_next_space()) {\n                    space = i;\n                    space_count = count;\n                }\n                var braket = string[i].match(/[[\\]]/);\n                offset = 0;\n                if (not_formatting) {\n                    // treat entity as one character\n                    if (string[i] === '&') {\n                        match = match_entity(i);\n                        if (match) {\n                            i += match[1].length - 2; // 2 because continue adds 1 to i\n                            continue;\n                        }\n                        ++count;\n                        ++length;\n                    } else if (is_escape_bracket(i)) {\n                        // escape \\] and \\\\ counts as one character\n                        ++count;\n                        ++length;\n                        offset = 1;\n                        i += 1;\n                    } else if (!braket || !have_formatting) {\n                        ++count;\n                        ++length;\n                    }\n                }\n                if (is_text(i)) {\n                    if (strlen(string[i]) === 2) {\n                        length++;\n                    }\n                    var char = get_next_character(substring);\n                    var size = char.length;\n                    // begining of enity that we've skipped, we are at the end\n                    if (char === ';') {\n                        match = string.slice(0, i + 1).match(re_ent);\n                        if (match) {\n                            offset = match[1].length;\n                            size = offset + 1;\n                        }\n                    }\n                    var data = {\n                        last: is_last(),\n                        count: count,\n                        index: i - offset,\n                        formatting: formatting,\n                        length: length,\n                        text: in_text,\n                        size: size,\n                        space: space,\n                        space_count: space_count\n                    };\n                    var ret = callback(data);\n                    if (ret === false) {\n                        break;\n                    } else if (ret) {\n                        if (ret.count !== undefined) {\n                            count = ret.count;\n                        }\n                        if (ret.length !== undefined) {\n                            length = ret.length;\n                        }\n                        if (ret.space !== undefined) {\n                            prev_space = space;\n                            space = ret.space;\n                        }\n                        if (ret.index !== undefined) {\n                            i = ret.index;\n                            continue;\n                        }\n                    }\n                } else if (i === string.length - 1 && !last) {\n                    // last iteration, if formatting have last bracket,\n                    // from formatting, then last iteration\n                    // was already called (in if) #550\n                    callback({\n                        count: count + 1,\n                        index: i,\n                        formatting: formatting,\n                        length: 0,\n                        text: in_text,\n                        space: space\n                    });\n                }\n                // handle emoji, suroggate pairs and combine characters\n                if (in_text) {\n                    i += next_iteration();\n                }\n            }\n        },\n        // ---------------------------------------------------------------------\n        // :: function return string splitted into single characters\n        // :: each character is wrapped into formatting from input string\n        // :: or empty formatting so it will create span when using with ::format\n        // ---------------------------------------------------------------------\n        partition: function partition(string) {\n            if (!$.terminal.have_formatting(string)) {\n                var chars = $.terminal.split_characters(string);\n                return chars.map(wrap);\n            }\n            var result = [];\n            function wrap(string) {\n                if (string.match(/\\\\$/)) {\n                    string += '\\\\';\n                }\n                return '[[;;]' + string + ']';\n            }\n            function formatting(string) {\n                if ($.terminal.is_formatting(string)) {\n                    if (string.match(/\\\\]$/)) {\n                        string = string.replace(/\\\\]/g, '\\\\\\\\]');\n                    }\n                } else {\n                    string = wrap(string);\n                }\n                return string;\n            }\n            $.terminal.iterate_formatting(string, function(data) {\n                if (data.text) {\n                    var text = [];\n                    if (data.formatting) {\n                        text.push(data.formatting);\n                    }\n                    text.push(string.substring(data.index, data.index + data.size));\n                    if (data.formatting) {\n                        text.push(']');\n                    }\n                    result.push(formatting(text.join('')));\n                }\n            });\n            return result;\n        },\n        // ---------------------------------------------------------------------\n        // :: formatting aware substring function\n        // ---------------------------------------------------------------------\n        substring: function substring(string, start_index, end_index) {\n            var chars = $.terminal.split_characters(string);\n            if (!chars.slice(start_index, end_index).length) {\n                return '';\n            }\n            if (!$.terminal.have_formatting(string)) {\n                return chars.slice(start_index, end_index).join('');\n            }\n            var start = 0;\n            var end;\n            var start_formatting = '';\n            var end_formatting = '';\n            var prev_index;\n            var offset = 1;\n            $.terminal.iterate_formatting(string, function(data) {\n                if (start_index && data.count === start_index + 1) {\n                    start = data.index;\n                    if (data.formatting) {\n                        start_formatting = data.formatting;\n                    }\n                }\n                if (end_index && data.count === end_index) {\n                    end_formatting = data.formatting;\n                    prev_index = data.index;\n                    offset = data.size;\n                }\n                if (data.count === end_index + 1) {\n                    end = data.index;\n                    if (data.formatting) {\n                        end = prev_index + offset;\n                    }\n                }\n            });\n            if (start_index && !start) {\n                return '';\n            }\n            if (end === undefined) {\n                end = string.length;\n            }\n            string = start_formatting + string.slice(start, end);\n            if (end_formatting) {\n                string = string.replace(/(\\[\\[^\\]]+)?\\]$/, '');\n                string += ']';\n            }\n            return string;\n        },\n        // ---------------------------------------------------------------------\n        // :: add format text as 5th paramter to formatting it's used for\n        // :: data attribute in format function - and fix unclosed &\n        // ---------------------------------------------------------------------\n        normalize: function normalize(string) {\n            string = string.replace(format_re, function(_, format, text) {\n                if (format.match(self_closing_re) && text === '') {\n                    return '[[' + format + '] ]';\n                }\n                if (text === '') {\n                    return '';\n                }\n                function safe(string) {\n                    return string.replace(/\\\\\\]/g, '&#93;').replace(/\\n/g, '\\\\n')\n                        .replace(/&nbsp;/g, ' ');\n                }\n                format = safe(format);\n                var semicolons = format.match(/;/g).length;\n                // missing semicolons\n                if (semicolons >= 4) {\n                    var args = format.split(/;/);\n                    var start = args.slice(0, 4).join(';');\n                    var arg = args.slice(4).join(';');\n                    return '[[' + start + ';' + (arg || text) + ']' + text + ']';\n                } else if (semicolons === 2) {\n                    semicolons = ';;';\n                } else if (semicolons === 3) {\n                    semicolons = ';';\n                }\n                // return '[[' + format + ']' + text + ']';\n                // closing braket will break formatting so we need to escape\n                // those using html entity equvalent\n                // space is hack for images that break iterate_formatting\n                format += semicolons + safe(text);\n                return '[[' + format + ']' + text + ']';\n            });\n            return $.terminal.amp(string);\n        },\n        // ---------------------------------------------------------------------\n        // :: split text into lines with equal length so each line can be\n        // :: rendered separately (text formatting can be longer then a line).\n        // ---------------------------------------------------------------------\n        split_equal: function split_equal(str, length, keep_words) {\n            var prev_format = '';\n            var result = [];\n            var array = $.terminal.normalize(str).split(/\\n/g);\n            for (var i = 0, len = array.length; i < len; ++i) {\n                if (array[i] === '') {\n                    result.push('');\n                    continue;\n                }\n                var line = array[i];\n                var get_next_character = make_next_char_fun(line);\n                var first_index = 0;\n                var output;\n                var line_length = line.length;\n                var last_bracket = !!line.match(/\\[\\[[^\\]]+\\](?:[^\\][]|\\\\\\])+\\]$/);\n                $.terminal.iterate_formatting(line, function(data) {\n                    var chr, substring;\n                    if (data.length >= length || data.last ||\n                        (data.length === length - 1 &&\n                         strlen(line[data.index + 1]) === 2)) {\n                        var can_break = false;\n                        // TODO: this need work\n                        if (keep_words && data.space !== -1) {\n                            // replace html entities with characters\n                            var stripped = text(line).substring(data.space_count);\n                            // real length, not counting formatting\n                            stripped = stripped.slice(0, length).trim();\n                            var text_len = strlen(stripped);\n                            if (stripped.match(/\\s/) || text_len < length) {\n                                can_break = true;\n                            }\n                        }\n                        // if words is true we split at last space and make next loop\n                        // continue where the space where located\n                        var after_index = data.index + data.size;\n                        if (last_bracket) {\n                            after_index += 1;\n                        }\n                        var new_index;\n                        if (keep_words && data.space !== -1 &&\n                            after_index !== line_length && can_break) {\n                            output = line.slice(first_index, data.space);\n                            new_index = data.space - 1;\n                        } else {\n                            substring = line.slice(data.index);\n                            chr = get_next_character(substring);\n                            output = line.slice(first_index, data.index) + chr;\n                            if (data.last && last_bracket && chr !== ']') {\n                                output += ']';\n                            }\n                            new_index = data.index + chr.length - 1;\n                        }\n                        if (keep_words) {\n                            output = output.replace(/^(&nbsp;|\\s)+|(&nbsp;|\\s)+$/g, '');\n                        }\n                        first_index = (new_index || data.index) + 1;\n                        if (prev_format) {\n                            var closed_formatting = output.match(/^[^\\]]*\\]/);\n                            output = prev_format + output;\n                            if (closed_formatting) {\n                                prev_format = '';\n                            }\n                        }\n                        var matched = output.match(format_re);\n                        if (matched) {\n                            var last = matched[matched.length - 1];\n                            if (last[last.length - 1] !== ']') {\n                                prev_format = last.match(format_begin_re)[1];\n                                output += ']';\n                            } else if (output.match(format_end_re)) {\n                                output = output.replace(format_end_re, '');\n                                prev_format = last.match(format_begin_re)[1];\n                            }\n                        }\n                        result.push(output);\n                        // modify loop by returing new data\n                        return {index: new_index, length: 0, space: -1};\n                    }\n                });\n            }\n            return result;\n        },\n        // ---------------------------------------------------------------------\n        // :: Escape & that's not part of entity\n        // ---------------------------------------------------------------------\n        amp: function amp(str) {\n            return str.replace(/&(?!#[0-9]+;|#x[0-9a-f]+;|[a-z]+;)/gi, '&amp;');\n        },\n        // ---------------------------------------------------------------------\n        // :: Encode formating as html for insertion into DOM\n        // ---------------------------------------------------------------------\n        encode: function encode(str, options) {\n            var settings = $.extend({\n                tabs: 4,\n                before: ''\n            }, options);\n            return $.terminal.amp(str).replace(/</g, '&lt;').replace(/>/g, '&gt;')\n                .replace(/ /g, '&nbsp;').split('\\n').map(function(line) {\n                    var splitted = line.split(/((?:\\[\\[[^\\]]+\\])?\\t(?:\\])?)/);\n                    splitted = splitted.filter(Boolean);\n                    return splitted.map(function(str, i) {\n                        if (str.match(/\\t/)) {\n                            return str.replace(/\\t([^\\t]*)$/, function(_, end) {\n                                if (i !== 0 && splitted[i - 1].match(/\\t\\]?$/)) {\n                                    var sp = new Array(settings.tabs + 1).join('&nbsp;');\n                                    return sp + end;\n                                } else {\n                                    var before = splitted.slice(i - 1, i).join('');\n                                    if (settings.before && i <= 1) {\n                                        before = settings.before + before;\n                                    }\n                                    var len = $.terminal.length(before);\n                                    var chars = settings.tabs - (len % settings.tabs);\n                                    if (chars === 0) {\n                                        chars = 4;\n                                    }\n                                    return new Array(chars + 1).join('&nbsp;') + end;\n                                }\n                            });\n                        }\n                        return str;\n                    }).join('');\n                }).join('\\n');\n        },\n        // -----------------------------------------------------------------------\n        // :: Default formatter that allow for nested formatting, example:\n        // :: [[;;#000]hello [[;#f00;]red] world]\n        // -----------------------------------------------------------------------\n        nested_formatting: function nested_formatting(string) {\n            if (!$.terminal.have_formatting(string)) {\n                return string;\n            }\n            var stack = [];\n            var re = /((?:\\[\\[(?:[^\\][]|\\\\\\])+\\])?(?:[^\\][]|\\\\\\])*\\]?)/;\n            var format_re = /\\[\\[([^\\][]+)\\][\\s\\S]*/;\n            var format_split_re = /^\\[\\[([^;]*);([^;]*);([^\\]]*)\\]/;\n            function get_inherit_style(stack) {\n                var output = [[], '', ''];\n                if (!stack.length) {\n                    return output;\n                }\n                for (var i = stack.length; i--;) {\n                    var formatting = stack[i].split(';');\n                    var style = formatting[0].split(/(-?[@!gbiuso])/g).filter(Boolean);\n                    style.forEach(function(s) {\n                        if (output[0].indexOf(s) === -1) {\n                            output[0].push(s);\n                        }\n                    });\n                    for (var j = 1; j < output.length; ++j) {\n                        var value = formatting[j].trim();\n                        if (value && !output[j]) {\n                            output[j] = value;\n                        }\n                    }\n                }\n                var ignore = output[0].filter(function(s) {\n                    return s[0] === '-';\n                }).map(function(s) {\n                    return s[1];\n                });\n                output[0] = output[0].filter(function(s) {\n                    return ignore.indexOf(s) === -1 && ignore.indexOf(s[1]) === -1;\n                }).join('');\n                return output.join(';');\n            }\n            return string.split(re).filter(Boolean).map(function(string) {\n                var style;\n                if (string.match(/^\\[\\[/)) {\n                    var formatting = string.replace(format_re, '$1');\n                    var is_formatting = $.terminal.is_formatting(string);\n                    string = string.replace(format_split_re, '');\n                    stack.push(formatting);\n                    if ($.terminal.nested_formatting.__inherit__) {\n                        style = get_inherit_style(stack);\n                    } else {\n                        style = formatting;\n                    }\n                    if (!is_formatting) {\n                        string += ']';\n                    } else {\n                        stack.pop();\n                    }\n                    string = '[[' + style + ']' + string;\n                } else {\n                    var pop = false;\n                    if (string.match(/\\]/)) {\n                        pop = true;\n                    }\n                    if (stack.length) {\n                        if ($.terminal.nested_formatting.__inherit__) {\n                            style = get_inherit_style(stack);\n                        } else {\n                            style = stack[stack.length - 1];\n                        }\n                        string = '[[' + style + ']' + string;\n                    }\n                    if (pop) {\n                        stack.pop();\n                    } else if (stack.length) {\n                        string += ']';\n                    }\n                }\n                return string;\n            }).join('');\n        },\n        // ---------------------------------------------------------------------\n        // :: safe function that will render text as it is\n        // ---------------------------------------------------------------------\n        escape_formatting: function escape_formatting(string) {\n            return $.terminal.escape_brackets(string);\n        },\n        // ---------------------------------------------------------------------\n        // :: apply custom formatters only to text\n        // ---------------------------------------------------------------------\n        apply_formatters: function apply_formatters(string, settings) {\n            if (string === \"\") {\n                if (settings && typeof settings.position === 'number') {\n                    return [\"\", settings.position];\n                } else {\n                    return \"\";\n                }\n            }\n            function test_lengths(formatter, index, ret, string) {\n                if (!formatter.__no_warn__ &&\n                    $.terminal.length(ret) !== $.terminal.length(string)) {\n                    warn('Your formatter[' + index + '] change length of the string, ' +\n                         'you should use [regex, replacement] formatter or function ' +\n                         ' that return [replacement, position] instead');\n                }\n            }\n            var formatters = $.terminal.defaults.formatters;\n            settings = settings || {};\n            var i = 0;\n            function apply_function_formatter(formatter, input) {\n                var options = $.extend({}, settings, {\n                    position: input[1]\n                });\n                var ret = formatter(input[0], options);\n                if (typeof ret === 'string') {\n                    test_lengths(formatter, i - 1, ret, input[0]);\n                    if (typeof ret === 'string') {\n                        return [ret, options.position];\n                    }\n                    return input;\n                } else if (is_array(ret) && ret.length === 2) {\n                    return ret;\n                } else {\n                    return input;\n                }\n            }\n            var input;\n            if (typeof settings.position === 'number') {\n                input = [string, settings.position];\n            } else {\n                input = [string, 0];\n            }\n            try {\n                var result = formatters.reduce(function(input, formatter) {\n                    i++;\n                    // __meta__ is for safe formatter that can handle formatters\n                    // inside formatters. for other usage we use format_split so one\n                    // formatter don't mess with formatter that was previous\n                    // on the list\n                    if (typeof formatter === 'function' && formatter.__meta__) {\n                        return apply_function_formatter(formatter, input);\n                    } else {\n                        var length = 0;\n                        var found_position = false;\n                        var splitted = $.terminal.format_split(input[0]);\n                        var partials = splitted.map(function(string) {\n                            var position;\n                            var this_len = text(string).length;\n                            // first position that match is used for this partial\n                            if (input[1] <= length + this_len && !found_position) {\n                                position = input[1] - length;\n                                found_position = true;\n                            } else {\n                                // -1 indicate that we will not track position because it\n                                // was in one of the previous parial strings\n                                position = -1;\n                            }\n                            // length is used to correct position after replace\n                            var length_before = length;\n                            var result;\n                            length += this_len;\n                            if ($.terminal.is_formatting(string)) {\n                                return [string, -1];\n                            } else {\n                                if (is_array(formatter)) {\n                                    var options = formatter[2] || {};\n                                    result = [string, position < 0 ? 0 : position];\n                                    if (result[0].match(formatter[0])) {\n                                        if (options.loop) {\n                                            while (result[0].match(formatter[0])) {\n                                                result = $.terminal.tracking_replace(\n                                                    result[0],\n                                                    formatter[0],\n                                                    formatter[1],\n                                                    result[1]\n                                                );\n                                            }\n                                        } else {\n                                            result = $.terminal.tracking_replace(\n                                                result[0],\n                                                formatter[0],\n                                                formatter[1],\n                                                result[1]\n                                            );\n                                        }\n                                    }\n                                    if (position < 0) {\n                                        return [result[0], -1];\n                                    }\n                                } else if (typeof formatter === 'function') {\n                                    result = apply_function_formatter(formatter, [\n                                        string, position\n                                    ]);\n                                }\n                                if (typeof result !== 'undefined') {\n                                    // correct position becuase it's relative\n                                    // to partial and we need global for whole string\n                                    if (result[1] !== -1) {\n                                        result[1] += length_before;\n                                    }\n                                    return result;\n                                }\n                                return [string, -1];\n                            }\n                        });\n                        var position_partial = partials.filter(function(partial) {\n                            return partial[1] !== -1;\n                        })[0];\n                        var string = partials.map(function(partial) {\n                            return partial[0];\n                        }).join('');\n                        var position;\n                        if (typeof position_partial === 'undefined') {\n                            position = input[1];\n                        } else {\n                            position = position_partial[1];\n                        }\n                        // to make sure that output position is not outside the string\n                        var max = text(string).length;\n                        max += count_selfclosing_formatting(string);\n                        if (position > max) {\n                            position = max;\n                        }\n                        if (string === input[0]) {\n                            return input;\n                        }\n                        return [string, position];\n                    }\n                }, input);\n                if (typeof settings.position === 'number') {\n                    var codepoint_len = $.terminal.strip(result[0]).length;\n                    if ($.terminal.length(result[0]) < codepoint_len) {\n                        var position = result[1];\n                        position = normalize_position(result[0], position);\n                        var max = $.terminal.length(result[0]);\n                        if (position > max) {\n                            position = max;\n                        }\n                        result[1] = position;\n                    }\n                    return result;\n                } else {\n                    return result[0];\n                }\n            } catch (e) {\n                var msg = 'Error in formatter [' + (i - 1) + ']';\n                formatters.splice(i - 1);\n                throw new $.terminal.Exception('formatting', msg, e.stack);\n            }\n        },\n        // ---------------------------------------------------------------------\n        // :: Replace terminal formatting with html\n        // ---------------------------------------------------------------------\n        format: function format(str, options) {\n            var settings = $.extend({}, {\n                linksNoReferrer: false,\n                linksNoFollow: false,\n                allowedAttributes: [],\n                char_width: undefined,\n                escape: true,\n                anyLinks: false\n            }, options || {});\n            // -----------------------------------------------------------------\n            function filter_attr_names(names) {\n                if (names.length && settings.allowedAttributes.length) {\n                    return names.filter(function(name) {\n                        if (name === 'data-text') {\n                            return false;\n                        }\n                        var allowed = false;\n                        var filters = settings.allowedAttributes;\n                        for (var i = 0; i < filters.length; ++i) {\n                            if (filters[i] instanceof RegExp) {\n                                if (filters[i].test(name)) {\n                                    allowed = true;\n                                    break;\n                                }\n                            } else if (filters[i] === name) {\n                                allowed = true;\n                                break;\n                            }\n                        }\n                        return allowed;\n                    });\n                }\n                return [];\n            }\n            // -----------------------------------------------------------------\n            function clean_data(data, text) {\n                if (data === '') {\n                    return text;\n                } else {\n                    return data.replace(/&#93;/g, ']')\n                        .replace(/>/g, '&gt;').replace(/</g, '&lt;');\n                }\n            }\n            // -----------------------------------------------------------------\n            function add_attrs(attrs) {\n                if (attrs) {\n                    var keys = filter_attr_names(Object.keys(attrs));\n                    if (keys.length) {\n                        return ' ' + keys.map(function(name) {\n                            var value = attrs[name].replace(/\"/g, '&quot;');\n                            return name + '=\"' + value + '\"';\n                        }).join(' ');\n                    }\n                }\n                return '';\n            }\n            // -----------------------------------------------------------------\n            function rel_attr() {\n                var rel = [\"noopener\"];\n                if (settings.linksNoReferrer) {\n                    rel.unshift(\"noreferrer\");\n                }\n                if (settings.linksNoFollow) {\n                    rel.unshift(\"nofollow\");\n                }\n                return rel;\n            }\n            // -----------------------------------------------------------------\n            // test if this is valid Path\n            // -----------------------------------------------------------------\n            function is_path(url) {\n                return url.match(/^\\.{1,2}\\//) ||\n                    url.match(/^\\//) ||\n                    !(url.match(/\\//) || url.match(/^[^:]+:/));\n            }\n            // -----------------------------------------------------------------\n            function with_url_validation(fn) {\n                return function(url) {\n                    if (settings.anyLinks) {\n                        return true;\n                    }\n                    var test = fn(url);\n                    if (!test) {\n                        warn('Invalid URL ' + url + ' only https ftp and Path ' +\n                             'are allowed');\n                    }\n                    return test;\n                };\n            }\n            // -----------------------------------------------------------------\n            var valid_href = with_url_validation(function(url) {\n                return url.match(/^((https?|ftp):\\/\\/|\\.{0,2}\\/)/) || is_path(url);\n            });\n            // -----------------------------------------------------------------\n            var valid_src = with_url_validation(function(url) {\n                return url.match(/^(https?:|blob:|data:)/) || is_path(url);\n            });\n            // -----------------------------------------------------------------\n            function format(s, style, color, background, _class, data_text, text) {\n                var attrs;\n                if (data_text.match(/;/)) {\n                    try {\n                        var splitted = data_text.split(';');\n                        var str = splitted.slice(1).join(';')\n                            .replace(/&nbsp;/g, ' ')\n                            .replace(/&lt;/g, '<')\n                            .replace(/&gt;/g, '>');\n                        if (str.match(/^\\s*\\{[^}]*\\}\\s*$/)) {\n                            attrs = JSON.parse(str);\n                            data_text = splitted[0];\n                        }\n                    } catch (e) {\n                    }\n                }\n                if (text === '' && !style.match(/@/)) {\n                    return ''; //'<span>&nbsp;</span>';\n                }\n                text = safe(text);\n                text = text.replace(/\\\\\\]/g, '&#93;');\n                if (settings.escape) {\n                    // inside formatting we need to unescape escaped slashes\n                    // but this escape is not needed when echo - don't know why\n                    text = text.replace(/\\\\\\\\/g, '\\\\');\n                }\n                var style_str = '';\n                if (style.indexOf('b') !== -1) {\n                    style_str += 'font-weight:bold;';\n                }\n                var text_decoration = [];\n                if (style.indexOf('u') !== -1) {\n                    text_decoration.push('underline');\n                }\n                if (style.indexOf('s') !== -1) {\n                    text_decoration.push('line-through');\n                }\n                if (style.indexOf('o') !== -1) {\n                    text_decoration.push('overline');\n                }\n                if (text_decoration.length) {\n                    style_str += 'text-decoration:' +\n                        text_decoration.join(' ') + ';';\n                }\n                if (style.indexOf('i') !== -1) {\n                    style_str += 'font-style:italic;';\n                }\n                if ($.terminal.valid_color(color)) {\n                    style_str += 'color:' + color + ';' +\n                        '--color:' + color + ';';\n                    if (style.indexOf('!') !== -1) {\n                        style_str += '--link-color:' + color + ';';\n                    }\n                    if (style.indexOf('g') !== -1) {\n                        style_str += 'text-shadow:0 0 5px ' + color + ';';\n                    }\n                }\n                if ($.terminal.valid_color(background)) {\n                    style_str += 'background-color:' + background + ';';\n                }\n                var data = clean_data(data_text, text);\n                var extra = extra_css(text, settings);\n                if (extra) {\n                    text = wide_characters(text, settings);\n                    style_str += extra;\n                }\n                var result;\n                if (style.indexOf('!') !== -1) {\n                    if (data.match(email_re)) {\n                        result = '<a href=\"mailto:' + data + '\"';\n                    } else {\n                        // only http and ftp links (prevent javascript)\n                        // unless user force it with anyLinks option\n                        if (!valid_href(data)) {\n                            data = '';\n                        }\n                        result = '<a target=\"_blank\"';\n                        if (data) {\n                            result += ' href=\"' + data + '\"';\n                        }\n                        result += ' rel=\"' + rel_attr().join(' ') + '\"';\n                    }\n                    // make focus to terminal textarea that will enable\n                    // terminal when pressing tab and terminal is disabled\n                    result += ' tabindex=\"1000\"';\n                } else if (style.indexOf('@') !== -1) {\n                    result = '<img';\n                    if (valid_src(data)) {\n                        result += ' src=\"' + data + '\"';\n                    }\n                } else {\n                    result = '<span';\n                }\n                result += add_attrs(attrs);\n                if (style_str !== '') {\n                    result += ' style=\"' + style_str + '\"';\n                }\n                if (_class !== '') {\n                    result += ' class=\"' + _class + '\"';\n                }\n                // links and image need data-text attribute cmd click behavior\n                // formatter can return links.\n                if (style.indexOf('!') !== -1) {\n                    result += ' data-text>' + text + '</a>';\n                } else if (style.indexOf('@') !== -1) {\n                    result += ' data-text/>';\n                } else {\n                    result += ' data-text=\"' + data.replace(/\"/g, '&quot;') + '\">' +\n                        text + '</span>';\n                }\n                return result;\n            }\n            if (typeof str === 'string') {\n                // support for formating foo[[u;;]bar]baz[[b;#fff;]quux]zzz\n                var splitted = $.terminal.format_split(str);\n                str = $.map(splitted, function(text) {\n                    if (text === '') {\n                        return text;\n                    } else if ($.terminal.is_formatting(text)) {\n                        // fix &nbsp; inside formatting because encode is called\n                        // before format\n                        text = text.replace(/\\[\\[[^\\]]+\\]/, function(text) {\n                            return text.replace(/&nbsp;/g, ' ');\n                        });\n                        return text.replace(format_parts_re, format);\n                    } else {\n                        text = safe(text);\n                        text = text.replace(/\\\\\\]/, '&#93;');\n                        var extra = extra_css(text, settings);\n                        if (extra.length) {\n                            text = wide_characters(text, settings);\n                            return '<span style=\"' + extra + '\">' + text + '</span>';\n                        } else {\n                            return '<span>' + text + '</span>';\n                        }\n                    }\n                }).join('');\n                return str.replace(/<span><br\\s*\\/?><\\/span>/gi, '<br/>');\n            } else {\n                return '';\n            }\n        },\n        // ---------------------------------------------------------------------\n        // :: Replace brackets with html entities\n        // ---------------------------------------------------------------------\n        escape_brackets: function escape_brackets(string) {\n            return string.replace(/\\[/g, '&#91;').replace(/\\]/g, '&#93;');\n        },\n        // ---------------------------------------------------------------------\n        // :: complmentary function\n        // ---------------------------------------------------------------------\n        unescape_brackets: function unescape_brackets(string) {\n            return string.replace(/&#91;/g, '[').replace(/&#93;/g, ']');\n        },\n        // ---------------------------------------------------------------------\n        // :: return number of characters without formatting\n        // ---------------------------------------------------------------------\n        length: function(string, raw) {\n            return $.terminal.split_characters(raw ? string : text(string)).length;\n        },\n        // ---------------------------------------------------------------------\n        // :: split characters handling emoji, surogate pairs and combine chars\n        // ---------------------------------------------------------------------\n        split_characters: function split_characters(string) {\n            var result = [];\n            var get_next_character = make_next_char_fun(string);\n            while (string.length) {\n                var chr = get_next_character(string);\n                string = string.slice(chr.length);\n                result.push(chr);\n            }\n            return result;\n        },\n        // ---------------------------------------------------------------------\n        // :: return string where array items are in columns padded spaces\n        // :: after adding align tabs arr.join('\\t\\t') looks much better\n        // ---------------------------------------------------------------------\n        columns: function(array, cols, space) {\n            var no_formatting = array.map(function(string) {\n                return $.terminal.strip(string);\n            });\n            var lengths = no_formatting.map(function(string) {\n                return strlen(string);\n            });\n            if (typeof space === 'undefined') {\n                space = 4;\n            }\n            var length = Math.max.apply(null, lengths) + space;\n            // we need value - 1 because index starts from 0\n            var column_limit = Math.floor(cols / length) - 1;\n            if (column_limit < 1) {\n                return array.join('\\n');\n            }\n            var lines = [];\n            for (var i = 0, len = array.length; i < len; i += column_limit) {\n                var line = array.slice(i, i + column_limit);\n                var last = line.pop();\n                lines.push(line.reduce(function(acc, string) {\n                    var stripped = $.terminal.strip(string);\n                    var pad = new Array(length - stripped.length + 1).join(' ');\n                    acc.push(string + pad);\n                    return acc;\n                }, []).join('') + last);\n            }\n            return lines.join('\\n');\n        },\n        // ---------------------------------------------------------------------\n        // :: Remove formatting from text\n        // ---------------------------------------------------------------------\n        strip: function strip(str) {\n            str = str.replace(format_parts_re, '$6');\n            return str.replace(/\\\\([[\\]])/g, function(whole, bracket) {\n                return bracket;\n            });\n        },\n        // ---------------------------------------------------------------------\n        // :: Return active terminal\n        // ---------------------------------------------------------------------\n        active: function active() {\n            return terminals.front();\n        },\n        // ---------------------------------------------------------------------\n        // :: Implmentation detail id is always length of terminals Cycle\n        // ---------------------------------------------------------------------\n        last_id: function last_id() {\n            var len = terminals.length();\n            return len - 1;\n        },\n        // ---------------------------------------------------------------------\n        // :: Function that works with strings like 'asd' 'asd\\' asd' \"asd asd\"\n        // :: asd\\ 123 -n -b / [^ ]+ / /\\s+/ asd\\ a it creates a regex and\n        // :: numbers and replaces escape characters in double quotes\n        // :: if strict is set to false it only strips single and double quotes\n        // :: and escapes spaces\n        // ---------------------------------------------------------------------\n        parse_argument: function parse_argument(arg, strict) {\n            function parse_string(string) {\n                // split string to string literals and non-strings\n                return string.split(string_re).map(function(string) {\n                    // remove quotes if before are even number of slashes\n                    // we don't remove slases becuase they are handled by JSON.parse\n                    if (string.match(/^['\"]/)) {\n                        // fixing regex to match empty string is not worth it\n                        if (string === '\"\"' || string === \"''\") {\n                            return '';\n                        }\n                        var quote = string[0];\n                        var re = new RegExp(\"(^|(?:\\\\\\\\(?:\\\\\\\\)*)?)\" + quote, \"g\");\n                        string = string.replace(re, \"$1\");\n                    }\n                    string = '\"' + string + '\"';\n                    // use build in function to parse rest of escaped characters\n                    return JSON.parse(string);\n                }).join('');\n            }\n            if (strict === false) {\n                if (arg[0] === \"'\" && arg[arg.length - 1] === \"'\") {\n                    return arg.replace(/^'|'$/g, '');\n                } else if (arg[0] === '\"' && arg[arg.length - 1] === '\"') {\n                    return arg.replace(/^\"|\"$/g, '').replace(/\\\\([\" ])/g, '$1');\n                } else if (arg.match(/\\/.*\\/[gimy]*$/)) {\n                    return arg;\n                } else if (arg.match(/['\"]]/)) {\n                    // part of arg is in quote\n                    return parse_string(arg);\n                } else {\n                    return arg.replace(/\\\\ /g, ' ');\n                }\n            }\n            var regex = arg.match(re_re);\n            if (regex) {\n                return new RegExp(regex[1], regex[2]);\n            } else if (arg.match(/['\"]/)) {\n                return parse_string(arg);\n            } else if (arg.match(/^-?[0-9]+$/)) {\n                return parseInt(arg, 10);\n            } else if (arg.match(float_re)) {\n                return parseFloat(arg);\n            } else {\n                return arg.replace(/\\\\(['\"() ])/g, '$1');\n            }\n        },\n        // ---------------------------------------------------------------------\n        // :: function split and parse arguments\n        // ---------------------------------------------------------------------\n        parse_arguments: function parse_arguments(string) {\n            return $.map(string.match(command_re) || [], $.terminal.parse_argument);\n        },\n        // ---------------------------------------------------------------------\n        // :: Function split and strips single and double quotes\n        // :: and escapes spaces\n        // ---------------------------------------------------------------------\n        split_arguments: function split_arguments(string) {\n            return $.map(string.match(command_re) || [], function(arg) {\n                return $.terminal.parse_argument(arg, false);\n            });\n        },\n        // ---------------------------------------------------------------------\n        // :: Function that returns an object {name,args}. Arguments are parsed\n        // :: using the function parse_arguments\n        // ---------------------------------------------------------------------\n        parse_command: function parse_command(string) {\n            return process_command(string, $.terminal.parse_argument);\n        },\n        // ---------------------------------------------------------------------\n        // :: Same as parse_command but arguments are parsed using split_arguments\n        // ---------------------------------------------------------------------\n        split_command: function split_command(string) {\n            return process_command(string, function(arg) {\n                return $.terminal.parse_argument(arg, false);\n            });\n        },\n        // ---------------------------------------------------------------------\n        // :; function that parse arguments like yargs library\n        // ---------------------------------------------------------------------\n        parse_options: function parse_options(arg, options) {\n            var settings = $.extend({}, {\n                boolean: []\n            }, options);\n            if (typeof arg === 'string') {\n                return parse_options($.terminal.split_arguments(arg), options);\n            }\n            var result = {\n                _: []\n            };\n            function token(value) {\n                this.value = value;\n            }\n            var rest = arg.reduce(function(acc, arg) {\n                var str = typeof arg === 'string' ? arg : '';\n                if (str.match(/^-/) && acc instanceof token) {\n                    result[acc.value] = true;\n                }\n                if (str.match(/^--/)) {\n                    var name = str.replace(/^--/, '');\n                    if (settings.boolean.indexOf(name) === -1) {\n                        return new token(name);\n                    } else {\n                        result[name] = true;\n                    }\n                } else if (str.match(/^-/)) {\n                    var single = str.replace(/^-/, '').split('');\n                    if (settings.boolean.indexOf(single.slice(-1)[0]) === -1) {\n                        var last = single.pop();\n                    }\n                    single.forEach(function(single) {\n                        result[single] = true;\n                    });\n                    if (last) {\n                        return new token(last);\n                    }\n                } else if (acc instanceof token) {\n                    result[acc.value] = arg;\n                } else if (arg) {\n                    result._.push(arg);\n                }\n                return null;\n            }, null);\n            if (rest instanceof token) {\n                result[rest.value] = true;\n            }\n            return result;\n        },\n        // ---------------------------------------------------------------------\n        // :: function executed for each text inside [[ .... ]] in echo\n        // ---------------------------------------------------------------------\n        extended_command: function extended_command(term, string, options) {\n            var settings = $.extend({\n                invokeMethods: false\n            }, options);\n            try {\n                change_hash = false;\n                var m = string.match(extended_command_re);\n                if (m) {\n                    if (!settings.invokeMethods) {\n                        warn('To invoke terminal or cmd methods you need to enable ' +\n                             'invokeMethods option');\n                        return;\n                    }\n                    string = m[1];\n                    var obj = m[2] === 'terminal' ? term : term.cmd();\n                    var fn = m[3];\n                    try {\n                        var args = eval('[' + m[4] + ']');\n                        if (!obj[fn]) {\n                            term.error('Unknow function ' + fn);\n                        } else {\n                            obj[fn].apply(term, args);\n                        }\n                    } catch (e) {\n                        term.error('Invalid invocation in ' +\n                                   $.terminal.escape_brackets(string));\n                    }\n                } else {\n                    term.exec(string, true).done(function() {\n                        change_hash = true;\n                    });\n                }\n            } catch (e) {\n                // error is process in exec\n            }\n        },\n        // ---------------------------------------------------------------------\n        // :: ES6 iterator for a given string that handle emoji and formatting\n        // ---------------------------------------------------------------------\n        iterator: function(string) {\n            function formatting(string) {\n                if ($.terminal.is_formatting(string)) {\n                    if (string.match(/\\]\\\\\\]/)) {\n                        string = string.replace(/\\]\\\\\\]/g, ']\\\\\\\\]');\n                    }\n                }\n                return string;\n            }\n            if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n                var len = $.terminal.length(string);\n                var i = 0;\n                var obj = {};\n                obj[Symbol.iterator] = function() {\n                    return {\n                        next: function() {\n                            if (i < len) {\n                                var text = $.terminal.substring(string, i, i + 1);\n                                i++;\n                                return {\n                                    value: formatting(text)\n                                };\n                            } else {\n                                return {\n                                    done: true\n                                };\n                            }\n                        }\n                    };\n                };\n                return obj;\n            }\n        },\n        // ---------------------------------------------------------------------\n        // :: object that can be used in string methods intead of regex\n        // ---------------------------------------------------------------------\n        formatter: new (function() {\n            try {\n                this[Symbol.split] = function(string) {\n                    return $.terminal.format_split(string);\n                };\n                this[Symbol.match] = function(string) {\n                    return string.match(format_re);\n                };\n                this[Symbol.replace] = function(string, replacer) {\n                    return string.replace(format_parts_re, replacer);\n                };\n                this[Symbol.search] = function(string) {\n                    return string.search(format_re);\n                };\n            } catch (e) {\n            }\n        })(),\n        // ---------------------------------------------------------------------\n        // :: helper function that add formatter before nested_formatting\n        // ---------------------------------------------------------------------\n        new_formatter: function(formatter) {\n            var formatters = $.terminal.defaults.formatters;\n            for (var i = 0; i < formatters.length; ++i) {\n                if (formatters[i] === $.terminal.nested_formatting) {\n                    formatters.splice(i, 0, formatter);\n                    return;\n                }\n            }\n            formatters.push(formatter);\n        }\n    };\n    // -------------------------------------------------------------------------\n    $.terminal.Exception = function Terminal_Exception(type, message, stack) {\n        if (arguments.length === 1) {\n            this.message = arguments[0];\n            this.type = 'TERMINAL';\n        } else {\n            this.type = type;\n            this.message = message;\n            if (stack) {\n                this.stack = stack;\n            }\n        }\n    };\n    $.terminal.Exception.prototype = new Error();\n    $.terminal.Exception.prototype.toString = function() {\n        return this.message + '\\n' + this.stack;\n    };\n    // -----------------------------------------------------------------------\n    // Helper plugins and functions\n    // -----------------------------------------------------------------------\n    $.fn.visible = function() {\n        return this.css('visibility', 'visible');\n    };\n    $.fn.hidden = function() {\n        return this.css('visibility', 'hidden');\n    };\n    // -----------------------------------------------------------------------\n    var warnings = [];\n    function warn(msg) {\n        msg = '[jQuery Terminal] ' + msg;\n        if (warnings.indexOf(msg) === -1) {\n            warnings.push(msg);\n            /* eslint-disable */\n            if (console) {\n                if (console.warn) {\n                    console.warn(msg);\n                } else if (console.log) {\n                    console.log(msg);\n                }\n                /* eslint-enable */\n            } else {\n                // prevent catching in outer try..catch\n                setTimeout(function() {\n                    throw new Error('WARN: ' + msg);\n                }, 0);\n            }\n        }\n    }\n    // -----------------------------------------------------------------------\n    // JSON-RPC CALL\n    // -----------------------------------------------------------------------\n    var ids = {}; // list of url based ids of JSON-RPC\n    $.jrpc = function(url, method, params, success, error) {\n        var deferred = new $.Deferred();\n        var options;\n        if ($.isPlainObject(url)) {\n            options = url;\n        } else {\n            options = {\n                url: url,\n                method: method,\n                params: params,\n                success: success,\n                error: error\n            };\n        }\n        function validJSONRPC(response) {\n            return $.isNumeric(response.id) &&\n                (typeof response.result !== 'undefined' ||\n                 typeof response.error !== 'undefined');\n        }\n        ids[options.url] = ids[options.url] || 0;\n        var request = {\n            'jsonrpc': '2.0',\n            'method': options.method,\n            'params': options.params,\n            'id': ++ids[options.url]\n        };\n        $.ajax({\n            url: options.url,\n            beforeSend: function beforeSend(jxhr, settings) {\n                if (is_function(options.request)) {\n                    options.request(jxhr, request);\n                }\n                settings.data = JSON.stringify(request);\n            },\n            success: function success(response, status, jqXHR) {\n                var content_type = jqXHR.getResponseHeader('Content-Type');\n                if (!content_type.match(/(application|text)\\/json/)) {\n                    warn('Response Content-Type is neither application/json' +\n                         ' nor text/json');\n                }\n                var json;\n                try {\n                    json = JSON.parse(response);\n                } catch (e) {\n                    if (options.error) {\n                        options.error(jqXHR, 'Invalid JSON', e);\n                    } else {\n                        throw new $.terminal.Exception('JSON', 'Invalid JSON', e.stack);\n                    }\n                    deferred.reject({message: 'Invalid JSON', response: response});\n                    return;\n                }\n                if (is_function(options.response)) {\n                    options.response(jqXHR, json);\n                }\n                if (validJSONRPC(json) || options.method === 'system.describe') {\n                    // don't catch errors in success callback\n                    if (options.success) {\n                        options.success(json, status, jqXHR);\n                    }\n                    deferred.resolve(json);\n                } else {\n                    if (options.error) {\n                        options.error(jqXHR, 'Invalid JSON-RPC');\n                    }\n                    deferred.reject({message: 'Invalid JSON-RPC', response: response});\n                }\n            },\n            error: options.error,\n            contentType: 'application/json',\n            dataType: 'text',\n            async: true,\n            cache: false,\n            // timeout: 1,\n            type: 'POST'\n        });\n        return deferred.promise();\n    };\n\n    // -----------------------------------------------------------------------\n    /*\n    function is_scrolled_into_view(elem) {\n        var docViewTop = $(window).scrollTop();\n        var docViewBottom = docViewTop + $(window).height();\n\n        var elemTop = $(elem).offset().top;\n        var elemBottom = elemTop + $(elem).height();\n\n        return ((elemBottom >= docViewTop) && (elemTop <= docViewBottom));\n    }\n    */\n    // -----------------------------------------------------------------------\n    function terminal_ready(term) {\n        return !!(term.closest('body').length &&\n                  term.is(':visible') &&\n                  term.find('.cmd-prompt').length);\n    }\n    // -----------------------------------------------------------------------\n    // :: Create fake terminal to calcualte the dimention of one character\n    // :: this will make terminal work if terminal div is not added to the\n    // :: DOM at init like with:\n    // :: $('<div/>').terminal().echo('foo bar').appendTo('body');\n    // -----------------------------------------------------------------------\n    function get_char_size(term) {\n        var rect;\n        if (terminal_ready(term)) {\n            var $prompt = term.find('.cmd-prompt').clone().css({\n                visiblity: 'hidden',\n                position: 'absolute'\n            });\n            $prompt.appendTo(term.find('.cmd')).html('&nbsp;');\n            rect = $prompt[0].getBoundingClientRect();\n            $prompt.remove();\n        } else {\n            var temp = $('<div class=\"terminal terminal-temp\"><div class=\"terminal-' +\n                         'wrapper\"><div class=\"terminal-output\"><div><div class=\"te' +\n                         'rminal-line\" style=\"float: left\"><span>&nbsp;</span></div' +\n                         '></div></div></div>').appendTo('body');\n            temp.addClass(term.attr('class')).attr('id', term.attr('id'));\n            if (term) {\n                var style = term.attr('style');\n                if (style) {\n                    style = style.split(/\\s*;\\s*/).filter(function(s) {\n                        return !s.match(/display\\s*:\\s*none/i);\n                    }).join(';');\n                    temp.attr('style', style);\n                }\n            }\n            rect = temp.find('.terminal-line')[0].getBoundingClientRect();\n        }\n        var result = {\n            width: rect.width,\n            height: rect.height\n        };\n        if (temp) {\n            temp.remove();\n        }\n        return result;\n    }\n    // -----------------------------------------------------------------------\n    // :: calculate numbers of characters\n    // -----------------------------------------------------------------------\n    function get_num_chars(terminal, char_size) {\n        var width = terminal.find('.terminal-fill').width();\n        var result = Math.floor(width / char_size.width);\n        // random number to not get NaN in node.js but big enough to\n        // not wrap exception\n        return result || 1000;\n    }\n    // -----------------------------------------------------------------------\n    // :: Calculate number of lines that fit without scroll\n    // -----------------------------------------------------------------------\n    function get_num_rows(terminal, char_size) {\n        return Math.floor(terminal.find('.terminal-fill').height() / char_size.height);\n    }\n    // -----------------------------------------------------------------------\n    function all(array, fn) {\n        var same = array.filter(function(item) {\n            return item[fn]() === item;\n        });\n        return same.length === array.length;\n    }\n    // -----------------------------------------------------------------------\n    function string_case(string) {\n        var array = string.split('');\n        if (all(array, 'toLowerCase')) {\n            return 'lower';\n        } else if (all(array, 'toUpperCase')) {\n            return 'upper';\n        } else {\n            return 'mixed';\n        }\n    }\n    // -----------------------------------------------------------------------\n    function same_case(string) {\n        return string_case(string) !== 'mixed';\n    }\n    // -----------------------------------------------------------------------\n    // fix for jQuery bug\n    function is_function(object) {\n        return get_type(object) === 'function';\n    }\n    // -----------------------------------------------------------------------\n    function is_array(object) {\n        return get_type(object) === 'array';\n    }\n    // -----------------------------------------------------------------------\n    function get_type(object) {\n        return typeof object === 'function' ? 'function' : $.type(object);\n    }\n    // -----------------------------------------------------------------------\n    // :: TERMINAL PLUGIN CODE\n    // -----------------------------------------------------------------------\n    var version_set = !$.terminal.version.match(/^\\{\\{/);\n    var copyright = 'Copyright (c) 2011-2019 Jakub T. Jankiewicz ' +\n        '<https://jcubic.pl/me>';\n    var version_string = version_set ? ' v. ' + $.terminal.version : ' ';\n    // regex is for placing version string aligned to the right\n    var reg = new RegExp(' {' + version_string.length + '}$');\n    var name_ver = 'jQuery Terminal Emulator' +\n        (version_set ? version_string : '');\n    // -----------------------------------------------------------------------\n    // :: Terminal Signatures\n    // -----------------------------------------------------------------------\n    var signatures = [\n        ['jQuery Terminal', '(c) 2011-2019 jcubic'],\n        [name_ver, copyright.replace(/^Copyright | *<.*>/g, '')],\n        [name_ver, copyright.replace(/^Copyright /, '')],\n        [\n            '      _______                 ________                        __',\n            '     / / _  /_ ____________ _/__  ___/______________  _____  / /',\n            ' __ / / // / // / _  / _/ // / / / _  / _/     / /  \\\\/ / _ \\\\/ /',\n            '/  / / // / // / ___/ // // / / / ___/ // / / / / /\\\\  / // / /__',\n            '\\\\___/____ \\\\\\\\__/____/_/ \\\\__ / /_/____/_//_/_/_/_/_/  \\\\/\\\\__\\\\_\\\\___/',\n            '         \\\\/          /____/                                   '\n                .replace(reg, ' ') + version_string,\n            copyright\n        ],\n        [\n            '      __ _____                     ________                            ' +\n                '  __',\n            '     / // _  /__ __ _____ ___ __ _/__  ___/__ ___ ______ __ __  __ ___ ' +\n                ' / /',\n            ' __ / // // // // // _  // _// // / / // _  // _//     // //  \\\\/ // _ ' +\n                '\\\\/ /',\n            '/  / // // // // // ___// / / // / / // ___// / / / / // // /\\\\  // // ' +\n                '/ /__',\n            '\\\\___//____ \\\\\\\\___//____//_/ _\\\\_  / /_//____//_/ /_/ /_//_//_/ /_/ \\\\' +\n                '__\\\\_\\\\___/',\n            ('          \\\\/              /____/                                     ' +\n             '     ').replace(reg, '') + version_string,\n            copyright\n        ]\n    ];\n    // -----------------------------------------------------------------------\n    // :: Default options\n    // -----------------------------------------------------------------------\n    $.terminal.nested_formatting.__meta__ = true;\n    // if set to true nested formatting will inherit styles from styles outside\n    $.terminal.nested_formatting.__inherit__ = false;\n    // nested formatting will always return different length so we silent the warning\n    $.terminal.nested_formatting.__no_warn__ = true;\n    $.terminal.defaults = {\n        prompt: '> ',\n        history: true,\n        exit: true,\n        clear: true,\n        enabled: true,\n        maskChar: '*',\n        wrap: true,\n        checkArity: true,\n        raw: false,\n        tabindex: 1,\n        invokeMethods: false,\n        exceptionHandler: null,\n        pauseEvents: true,\n        softPause: false,\n        memory: false,\n        cancelableAjax: true,\n        processArguments: true,\n        linksNoReferrer: false,\n        anyLinks: false,\n        linksNoFollow: false,\n        processRPCResponse: null,\n        completionEscape: true,\n        onCommandChange: null,\n        mobileDelete: is_mobile,\n        onPositionChange: null,\n        convertLinks: true,\n        extra: {},\n        tabs: 4,\n        historySize: 60,\n        scrollObject: null,\n        historyState: false,\n        importHistory: false,\n        historyFilter: null,\n        echoCommand: true,\n        scrollOnEcho: true,\n        login: null,\n        outputLimit: -1,\n        formatters: [$.terminal.nested_formatting],\n        onAjaxError: null,\n        pasteImage: true,\n        scrollBottomOffset: 20,\n        wordAutocomplete: true,\n        caseSensitiveAutocomplete: true,\n        caseSensitiveSearch: true,\n        clickTimeout: 200,\n        holdTimeout: 400,\n        holdRepeatTimeout: 200,\n        repeatTimeoutKeys: [],\n        mobileIngoreAutoSpace: [],\n        request: $.noop,\n        response: $.noop,\n        describe: 'procs',\n        onRPCError: null,\n        doubleTab: null,\n        doubleTabEchoCommand: false,\n        completion: false,\n        onInit: $.noop,\n        onClear: $.noop,\n        onBlur: $.noop,\n        onFocus: $.noop,\n        onTerminalChange: $.noop,\n        onExit: $.noop,\n        onPush: $.noop,\n        onPop: $.noop,\n        keypress: $.noop,\n        keydown: $.noop,\n        renderHandler: null,\n        onAfterRedraw: $.noop,\n        onEchoCommand: $.noop,\n        onPaste: $.noop,\n        onFlush: $.noop,\n        onBeforeCommand: null,\n        onAfterCommand: null,\n        onBeforeEcho: null,\n        onAfterEcho: null,\n        onBeforeLogin: null,\n        onAfterLogout: null,\n        onBeforeLogout: null,\n        allowedAttributes: ['title', /^aria-/, 'id', /^data-/],\n        strings: {\n            comletionParameters: 'From version 1.0.0 completion function need to' +\n                ' have two arguments',\n            wrongPasswordTryAgain: 'Wrong password try again!',\n            wrongPassword: 'Wrong password!',\n            ajaxAbortError: 'Error while aborting ajax call!',\n            wrongArity: \"Wrong number of arguments. Function '%s' expects %s got\" +\n                ' %s!',\n            commandNotFound: \"Command '%s' Not Found!\",\n            oneRPCWithIgnore: 'You can use only one rpc with describe == false ' +\n                'or rpc without system.describe',\n            oneInterpreterFunction: \"You can't use more than one function (rpc \" +\n                'without system.describe or with option describe == false count' +\n                 's as one)',\n            loginFunctionMissing: \"You didn't specify a login function\",\n            noTokenError: 'Access denied (no token)',\n            serverResponse: 'Server responded',\n            wrongGreetings: 'Wrong value of greetings parameter',\n            notWhileLogin: \"You can't call `%s' function while in login\",\n            loginIsNotAFunction: 'Authenticate must be a function',\n            canExitError: \"You can't exit from main interpreter\",\n            invalidCompletion: 'Invalid completion',\n            invalidSelector: 'Sorry, but terminal said that you use invalid ' +\n                'selector!',\n            invalidTerminalId: 'Invalid Terminal ID',\n            login: 'login',\n            password: 'password',\n            recursiveCall: 'Recursive call detected, skip',\n            notAString: '%s function: argument is not a string',\n            redrawError: 'Internal error, wrong position in cmd redraw',\n            invalidStrings: 'Command %s have unclosed strings',\n            defunctTerminal: \"You can't call method on terminal that was destroyed\"\n        }\n    };\n    // -------------------------------------------------------------------------\n    // :: All terminal globals\n    // -------------------------------------------------------------------------\n    var requests = []; // for canceling on CTRL+D\n    var terminals = new Cycle(); // list of terminals global in this scope\n    // state for all terminals, terminals can't have own array fo state because\n    // there is only one popstate event\n    var save_state = []; // hold objects returned by export_view by history API\n    var hash_commands;\n    var change_hash = false; // don't change hash on Init\n    var fire_hash_change = true;\n    var first_instance = true; // used by history state\n    $.fn.terminal = function(init_interpreter, options) {\n        function StorageHelper(memory) {\n            if (memory) {\n                this.storage = {};\n            }\n            this.set = function(key, value) {\n                if (memory) {\n                    this.storage[key] = value;\n                } else {\n                    $.Storage.set(key, value);\n                }\n            };\n            this.get = function(key) {\n                if (memory) {\n                    return this.storage[key];\n                } else {\n                    return $.Storage.get(key);\n                }\n            };\n            this.remove = function(key) {\n                if (memory) {\n                    delete this.storage[key];\n                } else {\n                    $.Storage.remove(key);\n                }\n            };\n        }\n        // ---------------------------------------------------------------------\n        // :: helper function\n        // ---------------------------------------------------------------------\n        function get_processed_command(command) {\n            if ($.terminal.unclosed_strings(command)) {\n                var string = $.terminal.escape_brackets(command);\n                var message = sprintf(strings().invalidStrings, \"`\" + string + \"`\");\n                throw new $.terminal.Exception(message);\n            } else if (is_function(settings.processArguments)) {\n                return process_command(command, settings.processArguments);\n            } else if (settings.processArguments) {\n                return $.terminal.parse_command(command);\n            } else {\n                return $.terminal.split_command(command);\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: helper function that use option to render objects\n        // ---------------------------------------------------------------------\n        function preprocess_value(value) {\n            if (is_function(settings.renderHandler)) {\n                var ret = settings.renderHandler.call(self, value, self);\n                if (ret === false) {\n                    return false;\n                }\n                if (typeof ret === 'string' || is_node(ret)) {\n                    return ret;\n                } else {\n                    return value;\n                }\n            }\n            return value;\n        }\n        // ---------------------------------------------------------------------\n        // :: call when line is out of view when outputLimit is used\n        // :: NOTE: it's not called when less plugin is used onClear is called\n        // :: instead because less call term::clear() after export old view\n        // ---------------------------------------------------------------------\n        function unmount(node) {\n            var index = node.data('index');\n            var line = lines[index];\n            var options = line[1];\n            if (is_function(options.unmount)) {\n                options.unmount.call(self, node);\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: helper function used in render and in update\n        // ---------------------------------------------------------------------\n        function prepare_render(value, options) {\n            if (is_node(value)) {\n                var settings = $.extend({}, options, {\n                    raw: true,\n                    finalize: function(div) {\n                        var node;\n                        if (value instanceof $.fn.init) {\n                            // deep clone with events - we clone because remove\n                            // from DOM will remove events from original object\n                            node = value.clone(true, true);\n                        } else {\n                            // don't clone html nodes because it will not\n                            // work for canvas or video tag\n                            node = value;\n                        }\n                        div.find('.terminal-render-item').replaceWith(node);\n                        if (options && is_function(options.finalize)) {\n                            options.finalize(div, self);\n                        }\n                    }\n                });\n                return ['<div class=\"terminal-render-item\"/>', settings];\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: helper function that renders DOM nodes and jQuery objects\n        // ---------------------------------------------------------------------\n        function render(value, options) {\n            var ret = prepare_render(value, options);\n            if (ret) {\n                self.echo.apply(self, ret);\n                return true;\n            }\n        }\n        // ---------------------------------------------------------------------\n        function get_node(index) {\n            return output.find('[data-index=' + index + ']');\n        }\n        // ---------------------------------------------------------------------\n        // :: test if object can be rendered\n        // ---------------------------------------------------------------------\n        function is_node(object) {\n            return object instanceof $.fn.init || object instanceof Element;\n        }\n        // ---------------------------------------------------------------------\n        // :: Display object on terminal\n        // ---------------------------------------------------------------------\n        function display_object(object) {\n            object = preprocess_value(object);\n            if (object === false) {\n                return;\n            }\n            if (render(object)) {\n                return;\n            }\n            if (typeof object === 'string') {\n                self.echo(object);\n            } else if (is_array(object)) {\n                self.echo($.map(object, function(object) {\n                    return JSON.stringify(object);\n                }).join(' '));\n            } else if (typeof object === 'object') {\n                self.echo(JSON.stringify(object));\n            } else {\n                self.echo(object);\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: Display line code in the file if line numbers are present\n        // ---------------------------------------------------------------------\n        function print_line(url_spec, cols) {\n            var re = /(.*):([0-9]+):([0-9]+)$/;\n            // google chrome have line and column after filename\n            var m = url_spec.match(re);\n            if (m) {\n                // TODO: do we need to call pause/resume or return promise?\n                self.pause(settings.softPause);\n                $.get(m[1], function(response) {\n                    var file = m[1];\n                    var code = response.split('\\n');\n                    var n = +m[2] - 1;\n                    var start = n > 2 ? n - 2 : 0;\n                    var lines = code.slice(start, n + 3).map(function(line, i) {\n                        var prefix = '[' + (n + i - 1) + ']: ';\n                        var limit = cols - prefix.length - 4;\n                        if (line.length > limit) {\n                            line = line.substring(0, limit) + '...';\n                        }\n                        if (n > 2 ? i === 2 : i === n) {\n                            line = '[[;#f00;]' +\n                                $.terminal.escape_brackets(line) + ']';\n                        }\n                        return prefix + line;\n                    }).filter(Boolean).join('\\n');\n                    if (lines.length) {\n                        self.echo('[[b;white;]' + file + ']');\n                        self.echo(lines).resume();\n                    }\n                }, 'text');\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: Helper function\n        // ---------------------------------------------------------------------\n        function display_json_rpc_error(error) {\n            if (is_function(settings.onRPCError)) {\n                settings.onRPCError.call(self, error);\n            } else {\n                self.error('&#91;RPC&#93; ' + error.message);\n                if (error.error && error.error.message) {\n                    error = error.error;\n                    // more detailed error message\n                    var msg = '\\t' + error.message;\n                    if (error.file) {\n                        msg += ' in file \"' + error.file.replace(/.*\\//, '') + '\"';\n                    }\n                    if (error.at) {\n                        msg += ' at line ' + error.at;\n                    }\n                    self.error(msg);\n                }\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: Create interpreter function from url string\n        // ---------------------------------------------------------------------\n        function make_basic_json_rpc(url, auth) {\n            var interpreter = function(method, params) {\n                self.pause(settings.softPause);\n                $.jrpc({\n                    url: url,\n                    method: method,\n                    params: params,\n                    request: function(jxhr, request) {\n                        try {\n                            settings.request.call(self, jxhr, request, self);\n                        } catch (e) {\n                            display_exception(e, 'USER');\n                        }\n                    },\n                    response: function(jxhr, response) {\n                        try {\n                            settings.response.call(self, jxhr, response, self);\n                        } catch (e) {\n                            display_exception(e, 'USER');\n                        }\n                    },\n                    success: function success(json) {\n                        if (json.error) {\n                            display_json_rpc_error(json.error);\n                        } else if (is_function(settings.processRPCResponse)) {\n                            settings.processRPCResponse.call(self, json.result, self);\n                        } else {\n                            display_object(json.result);\n                        }\n                        self.resume();\n                    },\n                    error: ajax_error\n                });\n            };\n            // this is the interpreter function\n            return function(command, terminal) {\n                if (command === '') {\n                    return;\n                }\n                try {\n                    command = get_processed_command(command);\n                } catch (e) {\n                    // exception can be thrown on invalid regex\n                    display_exception(e, 'TERMINAL (get_processed_command)');\n                    return;\n                    // throw e; // this will show stack in other try..catch\n                }\n                if (!auth || command.name === 'help') {\n                    // allows to call help without a token\n                    interpreter(command.name, command.args);\n                } else {\n                    var token = terminal.token();\n                    if (token) {\n                        interpreter(command.name, [token].concat(command.args));\n                    } else {\n                        // should never happen\n                        terminal.error('&#91;AUTH&#93; ' + strings().noTokenError);\n                    }\n                }\n            };\n        }\n        // ---------------------------------------------------------------------\n        // :: Create interpreter function from Object. If the value is object\n        // :: it will create nested interpreters\n        // ---------------------------------------------------------------------\n        function make_object_interpreter(object, arity, login, fallback) {\n            // function that maps commands to object methods\n            // it keeps terminal context\n            return function(user_command, terminal) {\n                if (user_command === '') {\n                    return;\n                }\n                // command = split_command_line(command);\n                var command;\n                try {\n                    command = get_processed_command(user_command);\n                } catch (e) {\n                    // exception can be thrown on invalid regex\n                    if (is_function(settings.exception)) {\n                        settings.exception(e, self);\n                    } else {\n                        self.error('Error: ' + (e.message || e));\n                    }\n                    return;\n                    // throw e; // this will show stack in other try..catch\n                }\n                var val = object[command.name];\n                var type = get_type(val);\n                if (type === 'function') {\n                    if (arity && val.length !== command.args.length) {\n                        self.error(\n                            '&#91;Arity&#93; ' +\n                                sprintf(\n                                    strings().wrongArity,\n                                    command.name,\n                                    val.length,\n                                    command.args.length\n                                )\n                        );\n                    } else {\n                        return val.apply(self, command.args);\n                    }\n                } else if (type === 'object' || type === 'string') {\n                    var commands = [];\n                    if (type === 'object') {\n                        commands = Object.keys(val);\n                        val = make_object_interpreter(\n                            val,\n                            arity,\n                            login\n                        );\n                    }\n                    terminal.push(val, {\n                        prompt: command.name + '> ',\n                        name: command.name,\n                        completion: type === 'object' ? commands : undefined\n                    });\n                } else if (is_function(fallback)) {\n                    fallback(user_command, self);\n                } else if (is_function(settings.onCommandNotFound)) {\n                    settings.onCommandNotFound.call(self, user_command, self);\n                } else {\n                    terminal.error(sprintf(strings().commandNotFound, command.name));\n                }\n            };\n        }\n        // ---------------------------------------------------------------------\n        function ajax_error(xhr, status, error) {\n            self.resume(); // onAjaxError can use pause/resume call it first\n            if (is_function(settings.onAjaxError)) {\n                settings.onAjaxError.call(self, xhr, status, error);\n            } else if (status !== 'abort') {\n                self.error('&#91;AJAX&#93; ' + status + ' - ' +\n                           strings().serverResponse + ':\\n' +\n                           $.terminal.escape_brackets(xhr.responseText));\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: function create interpreter object based on JSON-RPC meta data\n        // ---------------------------------------------------------------------\n        function make_json_rpc_object(url, auth, success) {\n            function jrpc_success(json) {\n                if (json.error) {\n                    display_json_rpc_error(json.error);\n                } else if (is_function(settings.processRPCResponse)) {\n                    settings.processRPCResponse.call(self, json.result, self);\n                } else {\n                    display_object(json.result);\n                }\n                self.resume();\n            }\n            function jrpc_request(jxhr, request) {\n                try {\n                    settings.request.call(self, jxhr, request, self);\n                } catch (e) {\n                    display_exception(e, 'USER');\n                }\n            }\n            function jrpc_response(jxhr, response) {\n                try {\n                    settings.response.call(self, jxhr, response, self);\n                } catch (e) {\n                    display_exception(e, 'USER');\n                }\n            }\n            function response(response) {\n                var procs = response;\n                // we check if it's false before we call this function but\n                // it don't hurt to be explicit here\n                if (settings.describe !== false && settings.describe !== '') {\n                    settings.describe.split('.').forEach(function(field) {\n                        procs = procs[field];\n                    });\n                }\n                if (procs && procs.length) {\n                    var interpreter_object = {};\n                    $.each(procs, function(_, proc) {\n                        if ($.isPlainObject(proc) && typeof proc.name === 'string') {\n                            interpreter_object[proc.name] = function() {\n                                var append = auth && proc.name !== 'help';\n                                var args = Array.prototype.slice.call(arguments);\n                                var args_len = args.length + (append ? 1 : 0);\n                                if (settings.checkArity && proc.params &&\n                                    proc.params.length !== args_len) {\n                                    self.error(\n                                        '&#91;Arity&#93; ' +\n                                            sprintf(\n                                                strings().wrongArity,\n                                                proc.name,\n                                                proc.params.length,\n                                                args_len\n                                            )\n                                    );\n                                } else {\n                                    self.pause(settings.softPause);\n                                    if (append) {\n                                        var token = self.token(true);\n                                        if (token) {\n                                            args = [token].concat(args);\n                                        } else {\n                                            self.error('&#91;AUTH&#93; ' +\n                                                       strings().noTokenError);\n                                        }\n                                    }\n                                    $.jrpc({\n                                        url: url,\n                                        method: proc.name,\n                                        params: args,\n                                        request: jrpc_request,\n                                        response: jrpc_response,\n                                        success: jrpc_success,\n                                        error: ajax_error\n                                    });\n                                }\n                            };\n                        }\n                    });\n                    var login = typeof auth === 'string' ? auth : 'login';\n                    interpreter_object.help = interpreter_object.help || function(fn) {\n                        if (typeof fn === 'undefined') {\n                            var names = procs.map(function(proc) {\n                                return proc.name;\n                            }).join(', ') + ', help';\n                            self.echo('Available commands: ' + names);\n                        } else {\n                            var found = false;\n                            $.each(procs, function(_, proc) {\n                                if (proc.name === fn) {\n                                    found = true;\n                                    var msg = '';\n                                    msg += '[[bu;;]' + proc.name + ']';\n                                    if (proc.params) {\n                                        var params = proc.params;\n                                        if (auth && proc.name !== login) {\n                                            params = params.slice(1);\n                                        }\n                                        msg += ' ' + params.join(' ');\n                                    }\n                                    if (proc.help) {\n                                        msg += '\\n' + proc.help;\n                                    }\n                                    self.echo(msg);\n                                    return false;\n                                }\n                            });\n                            if (!found) {\n                                if (fn === 'help') {\n                                    self.echo('[[bu;;]help] [method]\\ndisplay help ' +\n                                              'for the method or list of methods if not' +\n                                              ' specified');\n                                } else {\n                                    var msg = 'Method `' + fn + \"' not found \";\n                                    self.error(msg);\n                                }\n                            }\n                        }\n                    };\n                    success(interpreter_object);\n                } else {\n                    success(null);\n                }\n            }\n            return $.jrpc({\n                url: url,\n                method: 'system.describe',\n                params: [],\n                success: response,\n                request: jrpc_request,\n                response: jrpc_response,\n                error: function error() {\n                    success(null);\n                }\n            });\n        }\n        // ---------------------------------------------------------------------\n        // :: function create interpeter function and call finalize with\n        // :: interpreter and optional completion\n        // ---------------------------------------------------------------------\n        function make_interpreter(user_intrp, login, finalize) {\n            finalize = finalize || $.noop;\n            var type = get_type(user_intrp);\n            var object;\n            var result = {};\n            var rpc_count = 0; // only one rpc can be use for array\n            var fn_interpreter;\n            if (type === 'array') {\n                object = {};\n                // recur will be called when previous acync call is finished\n                (function recur(interpreters, success) {\n                    if (interpreters.length) {\n                        var first = interpreters[0];\n                        var rest = interpreters.slice(1);\n                        var type = get_type(first);\n                        if (type === 'string') {\n                            self.pause(settings.softPause);\n                            if (settings.describe === false) {\n                                if (++rpc_count === 1) {\n                                    fn_interpreter = make_basic_json_rpc(first, login);\n                                } else {\n                                    self.error(strings().oneRPCWithIgnore);\n                                }\n                                recur(rest, success);\n                            } else {\n                                make_json_rpc_object(first, login, function(new_obj) {\n                                    if (new_obj) {\n                                        $.extend(object, new_obj);\n                                    } else if (++rpc_count === 1) {\n                                        fn_interpreter = make_basic_json_rpc(\n                                            first,\n                                            login\n                                        );\n                                    } else {\n                                        self.error(strings().oneRPCWithIgnore);\n                                    }\n                                    self.resume();\n                                    recur(rest, success);\n                                });\n                            }\n                        } else if (type === 'function') {\n                            if (fn_interpreter) {\n                                self.error(strings().oneInterpreterFunction);\n                            } else {\n                                fn_interpreter = first;\n                            }\n                            recur(rest, success);\n                        } else if (type === 'object') {\n                            $.extend(object, first);\n                            recur(rest, success);\n                        }\n                    } else {\n                        success();\n                    }\n                })(user_intrp, function() {\n                    finalize({\n                        interpreter: make_object_interpreter(\n                            object,\n                            false,\n                            login,\n                            fn_interpreter && fn_interpreter.bind(self)\n                        ),\n                        completion: Object.keys(object)\n                    });\n                });\n            } else if (type === 'string') {\n                if (settings.describe === false) {\n                    object = {\n                        interpreter: make_basic_json_rpc(user_intrp, login)\n                    };\n                    if ($.isArray(settings.completion)) {\n                        object.completion = settings.completion;\n                    }\n                    finalize(object);\n                } else {\n                    self.pause(settings.softPause);\n                    make_json_rpc_object(user_intrp, login, function(object) {\n                        if (object) {\n                            result.interpreter = make_object_interpreter(\n                                object,\n                                false,\n                                login\n                            );\n                            result.completion = Object.keys(object);\n                        } else {\n                            // no procs in system.describe\n                            result.interpreter = make_basic_json_rpc(user_intrp, login);\n                        }\n                        finalize(result);\n                        self.resume();\n                    });\n                }\n            } else if (type === 'object') {\n                finalize({\n                    interpreter: make_object_interpreter(\n                        user_intrp,\n                        settings.checkArity,\n                        login\n                    ),\n                    completion: Object.keys(user_intrp)\n                });\n            } else {\n                // allow $('<div/>').terminal();\n                if (type === 'undefined') {\n                    user_intrp = $.noop;\n                } else if (type !== 'function') {\n                    var msg = type + ' is invalid interpreter value';\n                    throw new $.terminal.Exception(msg);\n                }\n                // single function don't need bind\n                finalize({\n                    interpreter: user_intrp,\n                    completion: settings.completion\n                });\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: Create JSON-RPC authentication function\n        // ---------------------------------------------------------------------\n        function make_json_rpc_login(url, login) {\n            var method = get_type(login) === 'boolean' ? 'login' : login;\n            return function(user, passwd, callback) {\n                self.pause(settings.softPause);\n                $.jrpc({\n                    url: url,\n                    method: method,\n                    params: [user, passwd],\n                    request: function(jxhr, request) {\n                        try {\n                            settings.request.call(self, jxhr, request, self);\n                        } catch (e) {\n                            display_exception(e, 'USER');\n                        }\n                    },\n                    response: function(jxhr, response) {\n                        try {\n                            settings.response.call(self, jxhr, response, self);\n                        } catch (e) {\n                            display_exception(e, 'USER');\n                        }\n                    },\n                    success: function success(response) {\n                        if (!response.error && response.result) {\n                            callback(response.result);\n                        } else {\n                            // null will trigger message that login fail\n                            callback(null);\n                        }\n                        self.resume();\n                    },\n                    error: ajax_error\n                });\n            };\n            // default name is login so you can pass true\n        }\n        // ---------------------------------------------------------------------\n        // :: display Exception on terminal\n        // ---------------------------------------------------------------------\n        function display_exception(e, label, silent) {\n            if (is_function(settings.exceptionHandler)) {\n                settings.exceptionHandler.call(self, e, label);\n            } else {\n                self.exception(e, label);\n                if (!silent) {\n                    setTimeout(function() {\n                        throw e;\n                    }, 0);\n                }\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: Draw line - can have line breaks and be longer than the width of\n        // :: the terminal, there are 2 options raw and finalize\n        // :: raw - will not encode the string and finalize if a function that\n        // :: will have div container of the line as first argument\n        // :: NOTE: it formats and appends lines to output_buffer. The actual\n        // :: append to terminal output happens in the flush function\n        // ---------------------------------------------------------------------\n        var output_buffer = [];\n        var NEW_LINE = 1;\n        var format_cache;\n        if ('Map' in root) {\n            format_cache = new Map();\n        }\n        function buffer_line(arg, index, options) {\n            // urls should always have formatting to keep url if split\n            var i, len;\n            output_buffer.push(NEW_LINE);\n            var format_options = {\n                linksNoReferrer: settings.linksNoReferrer,\n                linksNoFollow: settings.linksNoFollow,\n                anyLinks: settings.anyLinks,\n                char_width: char_size.width,\n                escape: false,\n                allowedAttributes: options.allowedAttributes || []\n            };\n            var use_cache = settings.useCache && format_cache;\n            function format_buff(arg, newline) {\n                var args = JSON.stringify([arg, format_options]);\n                if (use_cache) {\n                    if (format_cache.has(args)) {\n                        return format_cache.get(args);\n                    }\n                }\n                var data = {\n                    line: $.terminal.format(\n                        arg,\n                        format_options\n                    ),\n                    newline: newline\n                };\n                if (use_cache) {\n                    format_cache.set(args, data);\n                }\n                return data;\n            }\n            if (arg instanceof Array) {\n                for (i = 0, len = arg.length; i < len; ++i) {\n                    if (arg[i] === '' || arg[i] === '\\r') {\n                        output_buffer.push({line: '<span></span>'});\n                    } else {\n                        output_buffer.push(format_buff(arg[i], i === len - 1));\n                    }\n                }\n            } else if (!options.raw) {\n                output_buffer.push(format_buff(arg));\n            } else {\n                output_buffer.push({line: arg});\n            }\n            output_buffer.push({\n                finalize: options.finalize,\n                index: index\n            });\n        }\n        // ---------------------------------------------------------------------\n        function links(string) {\n            function format(_, style, color, background, _class, data, text) {\n                function formatting(s, text) {\n                    return '[[' + [\n                        style + (s || ''),\n                        color,\n                        background,\n                        _class,\n                        data || text\n                    ].join(';') + ']';\n                }\n                function escaped(_) {\n                    return ']' + formatting('!', _) + _ + ']' + formatting();\n                }\n                if (!style.match(/!/)) {\n                    if (text.match(email_full_re) || text.match(url_full_re)) {\n                        return formatting('!', text) + text + ']';\n                    } else if (text.match(email_re) || text.match(url_nf_re)) {\n                        var output = text.replace(email_re, escaped)\n                            .replace(url_nf_re, escaped);\n                        return formatting('', data) + output + ']';\n                    }\n                }\n                return _;\n            }\n            if (!(string.match(email_re) || string.match(url_nf_re))) {\n                return string;\n            }\n            if (!$.terminal.have_formatting(string)) {\n                return string.replace(email_re, '[[!;;]$1]').\n                    replace(url_nf_re, '[[!;;]$1]');\n            }\n            return $.terminal.format_split(string).map(function(str) {\n                if ($.terminal.is_formatting(str)) {\n                    return str.replace(format_parts_re, format);\n                } else {\n                    return str.replace(email_re, '[[!;;]$1]').\n                        replace(url_nf_re, '[[!;;]$1]');\n                }\n            }).join('');\n        }\n        // ---------------------------------------------------------------------\n        function should_wrap(string, options) {\n            return (strlen(text(string)) > options.cols ||\n                    string.match(/\\n/)) &&\n                ((settings.wrap === true &&\n                  options.wrap === undefined) ||\n                 settings.wrap === false &&\n                 options.wrap === true);\n        }\n        // ---------------------------------------------------------------------\n        var string_cache;\n        if ('Map' in root) {\n            string_cache = new Map();\n        }\n        function process_line(line) {\n            // prevent exception in display exception\n            try {\n                var line_settings = $.extend({\n                    exec: true,\n                    raw: false,\n                    finalize: $.noop,\n                    invokeMethods: false,\n                    formatters: true,\n                    convertLinks: settings.convertLinks\n                }, line.options || {});\n                var string;\n                string = stringify_value(line.value);\n                if (string !== '') {\n                    if (!line_settings.raw) {\n                        if (line_settings.formatters) {\n                            try {\n                                string = $.terminal.apply_formatters(\n                                    string,\n                                    settings\n                                );\n                            } catch (e) {\n                                display_exception(e, 'FORMATTING');\n                            }\n                        }\n                        if (settings.useCache) {\n                            var key = string;\n                            if (string_cache && string_cache.has(key)) {\n                                string = string_cache.get(key);\n                                buffer_line(string, line.index, line_settings);\n                                return;\n                            }\n                        }\n                        if (line_settings.exec) {\n                            var parts = string.split(format_exec_re);\n                            string = $.map(parts, function(string) {\n                                if (string && string.match(format_exec_re) &&\n                                    !$.terminal.is_formatting(string)) {\n                                    // redraw should not execute commands and it have\n                                    // and lines variable have all extended commands\n                                    string = string.replace(/^\\[\\[|\\]\\]$/g, '');\n                                    if (line_settings.exec) {\n                                        var trim = string.trim();\n                                        if (prev_exec_cmd && prev_exec_cmd === trim) {\n                                            prev_exec_cmd = '';\n                                            self.error(strings().recursiveCall);\n                                        } else {\n                                            prev_exec_cmd = trim;\n                                            $.terminal.extended_command(self, string, {\n                                                invokeMethods: line_settings.invokeMethods\n                                            });\n                                        }\n                                    }\n                                    return '';\n                                } else {\n                                    return string;\n                                }\n                            }).join('');\n                        }\n                        if (string === '') {\n                            return;\n                        }\n                        if (line_settings.convertLinks) {\n                            string = links(string);\n                        }\n                        string = crlf($.terminal.normalize(string));\n                        string = $.terminal.encode(string, {\n                            tabs: settings.tabs\n                        });\n                        //string = $.terminal.normalize(string);\n                        var array;\n                        var cols = line_settings.cols = self.cols();\n                        if (should_wrap(string, line_settings)) {\n                            var words = line_settings.keepWords;\n                            array = $.terminal.split_equal(string, cols, words);\n                        } else if (string.match(/\\n/)) {\n                            array = string.split(/\\n/);\n                        }\n                    }\n                }\n                var arg = array || string;\n                if (string_cache && key) {\n                    string_cache.set(key, arg);\n                }\n                buffer_line(arg, line.index, line_settings);\n            } catch (e) {\n                output_buffer = [];\n                // don't display exception if exception throw in terminal\n                if (is_function(settings.exceptionHandler)) {\n                    settings.exceptionHandler.call(self, e, 'TERMINAL');\n                } else {\n                    alert_exception('[Internal Exception(process_line)]', e);\n                }\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: Update terminal lines\n        // ---------------------------------------------------------------------\n        function redraw(options) {\n            options = $.extend({}, {\n                // should be used when single line is updated\n                update: false,\n                // should be used if you want to scroll to bottom after redraw\n                scroll: true\n            }, options || {});\n            if (!options.update) {\n                command_line.resize(num_chars);\n                // we don't want reflow while processing lines\n                var detached_output = output.empty().detach();\n            }\n            var lines_to_show = [];\n            // Dead code\n            if (settings.outputLimit >= 0) {\n                // flush will limit lines but if there is lot of\n                // lines we don't need to show them and then remove\n                // them from terminal\n                var limit;\n                if (settings.outputLimit === 0) {\n                    limit = self.rows();\n                } else {\n                    limit = settings.outputLimit;\n                }\n                lines.forEach(function(line, index) {\n                    var value = line[0];\n                    var options = line[1];\n                    lines_to_show.push({\n                        value: value,\n                        index: index,\n                        options: options\n                    });\n                });\n                var pivot = lines_to_show.length - limit - 1;\n                lines_to_show = lines_to_show.slice(pivot);\n            } else {\n                lines_to_show = lines.map(function(line, index) {\n                    return {\n                        value: line[0],\n                        index: index,\n                        options: line[1]\n                    };\n                });\n            }\n            try {\n                output_buffer = [];\n                $.each(lines_to_show, function(i, line) {\n                    process_line(line);\n                });\n                if (!options.update) {\n                    command_line.before(detached_output); // reinsert output\n                }\n                self.flush(options);\n                fire_event('onAfterRedraw');\n            } catch (e) {\n                if (is_function(settings.exceptionHandler)) {\n                    settings.exceptionHandler.call(self, e, 'TERMINAL (redraw)');\n                } else {\n                    alert_exception('[redraw]', e);\n                }\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: Function limit output lines based on outputLimit option\n        // ---------------------------------------------------------------------\n        function limit_lines() {\n            if (settings.outputLimit >= 0) {\n                var limit;\n                if (settings.outputLimit === 0) {\n                    limit = self.rows();\n                } else {\n                    limit = settings.outputLimit;\n                }\n                var $lines = output.find('> div > div');\n                if ($lines.length + 1 > limit) {\n                    var max = $lines.length - limit + 1;\n                    var for_remove = $lines.slice(0, max);\n                    // you can't get parent if you remove the\n                    // element so we first get the parent\n                    var parents = for_remove.parent();\n                    for_remove.remove();\n                    parents.each(function() {\n                        var $self = $(this);\n                        if ($self.is(':empty')) {\n                            unmount($self);\n                            // there can be divs inside parent that\n                            // was not removed\n                            $self.remove();\n                        }\n                    });\n                }\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: Display user greetings or terminal signature\n        // ---------------------------------------------------------------------\n        function show_greetings() {\n            if (settings.greetings === undefined) {\n                // signature have ascii art so it's not suite for screen readers\n                self.echo(self.signature, {finalize: a11y_hide, formatters: false});\n            } else if (settings.greetings) {\n                var type = typeof settings.greetings;\n                if (type === 'string') {\n                    self.echo(settings.greetings);\n                } else if (type === 'function') {\n                    try {\n                        var ret = settings.greetings.call(self, self.echo);\n                        var error = make_label_error('Greetings');\n                        unpromise(ret, self.echo, function(e) {\n                            error(e);\n                            settings.greetings = null;\n                        });\n                    } catch (e) {\n                        settings.greetings = null;\n                        display_exception(e, 'greetings');\n                    }\n                } else {\n                    self.error(strings().wrongGreetings);\n                }\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: Display prompt and last command\n        // ---------------------------------------------------------------------\n        function echo_command(command) {\n            if (typeof command === 'undefined') {\n                command = self.get_command();\n            }\n            // true will return last rendered string\n            var prompt = command_line.prompt(true);\n            var mask = command_line.mask();\n            switch (typeof mask) {\n                case 'string':\n                    command = command.replace(/./g, mask);\n                    break;\n                case 'boolean':\n                    if (mask) {\n                        command = command.replace(/./g, settings.maskChar);\n                    } else {\n                        command = $.terminal.escape_formatting(command);\n                    }\n                    break;\n            }\n            var options = {\n                convertLinks: false,\n                exec: false,\n                finalize: function finalize(div) {\n                    a11y_hide(div.addClass('terminal-command'));\n                    fire_event('onEchoCommand', [div, command]);\n                }\n            };\n            self.echo(prompt + command, options);\n        }\n        // ---------------------------------------------------------------------\n        function have_scrollbar() {\n            return fill.outerWidth() !== self.outerWidth();\n        }\n        // ---------------------------------------------------------------------\n        // :: Helper function that restore state. Call import_view or exec\n        // ---------------------------------------------------------------------\n        function restore_state(spec) {\n            // spec [terminal_id, state_index, command]\n            var terminal = terminals.get()[spec[0]];\n            if (!terminal) {\n                throw new $.terminal.Exception(strings().invalidTerminalId);\n            }\n            var command_idx = spec[1];\n            if (save_state[command_idx]) { // state exists\n                terminal.import_view(save_state[command_idx]);\n            } else {\n                // restore state\n                change_hash = false;\n                var command = spec[2];\n                if (command) {\n                    terminal.exec(command).done(function() {\n                        change_hash = true;\n                        save_state[command_idx] = terminal.export_view();\n                    });\n                }\n            }\n            /*if (spec[3].length) {\n                restore_state(spec[3]);\n            }*/\n        }\n        // ---------------------------------------------------------------------\n        function make_label_error(label) {\n            return function(e) {\n                self.error('[' + label + '] ' + (e.message || e)).resume();\n            };\n        }\n        // ---------------------------------------------------------------------\n        // :: Helper function\n        // ---------------------------------------------------------------------\n        function maybe_update_hash() {\n            if (change_hash) {\n                fire_hash_change = false;\n                location.hash = '#' + JSON.stringify(hash_commands);\n                setTimeout(function() {\n                    fire_hash_change = true;\n                }, 100);\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: Wrapper over interpreter, it implements exit and catches all\n        // :: exeptions from user code and displays them on the terminal\n        // ---------------------------------------------------------------------\n        var first_command = true;\n        var resume_callbacks = [];\n        function commands(command, silent, exec) {\n            function init_state() {\n                // execHash need first empty command too\n                if (settings.historyState || settings.execHash && exec) {\n                    if (!save_state.length) {\n                        // first command in first terminal don't have hash\n                        self.save_state();\n                    } else {\n                        self.save_state(null);\n                    }\n                }\n            }\n            // -----------------------------------------------------------------\n            function after_exec() {\n                // variables defined later in commands\n                if (!exec) {\n                    change_hash = true;\n                    if (settings.historyState) {\n                        self.save_state(command, false);\n                    }\n                    change_hash = saved_change_hash;\n                }\n                deferred.resolve();\n                fire_event('onAfterCommand', [command]);\n            }\n            // -----------------------------------------------------------------\n            function show(result) {\n                if (typeof result !== 'undefined') {\n                    display_object(result);\n                }\n                after_exec();\n                self.resume();\n            }\n            // -----------------------------------------------------------------\n\n            // -----------------------------------------------------------------\n            function invoke() {\n                // Call user interpreter function\n                var result = interpreter.interpreter.call(self, command, self);\n                if (result) {\n                    // auto pause/resume when user return promises\n                    // it should not pause when user return promise from read()\n                    if (!force_awake) {\n                        self.pause(settings.softPause);\n                    }\n                    force_awake = false;\n                    var error = make_label_error('Command');\n                    // when for native Promise object work only in jQuery 3.x\n                    if (is_function(result.done || result.then)) {\n                        return unpromise(result, show, error);\n                    } else {\n                        return $.when(result).done(show).catch(error);\n                    }\n                } else if (paused) {\n                    resume_callbacks.push(function() {\n                        // exec with resume/pause in user code\n                        after_exec();\n                    });\n                } else {\n                    after_exec();\n                }\n            }\n            // -----------------------------------------------------------------\n            // first command store state of the terminal before the command get\n            // executed\n            if (first_command) {\n                first_command = false;\n                init_state();\n            }\n            try {\n                // this callback can disable commands\n                if (fire_event('onBeforeCommand', [command]) === false) {\n                    return;\n                }\n                if (exec) {\n                    prev_exec_cmd = command.trim();\n                } else {\n                    prev_command = $.terminal.split_command(command);\n                }\n                if (!ghost()) {\n                    // exec execute this function wihout the help of cmd plugin\n                    // that add command to history on enter\n                    if (exec && (is_function(settings.historyFilter) &&\n                                 settings.historyFilter(command) ||\n                                 command.match(settings.historyFilter))) {\n                        command_line.history().append(command);\n                    }\n                }\n                var interpreter = interpreters.top();\n                if (!silent && settings.echoCommand) {\n                    echo_command(command);\n                }\n                // new promise will be returned to exec that will resolve his\n                // returned promise\n                var deferred = new $.Deferred();\n                // we need to save sate before commands is deleyd because\n                // execute_extended_command disable it and it can be executed\n                // after delay\n                var saved_change_hash = change_hash;\n                if (command.match(/^\\s*login\\s*$/) && self.token(true)) {\n                    if (self.level() > 1) {\n                        self.logout(true);\n                    } else {\n                        self.logout();\n                    }\n                    after_exec();\n                } else if (settings.exit && command.match(/^\\s*exit\\s*$/) &&\n                           !in_login) {\n                    var level = self.level();\n                    if (level === 1 && self.get_token() || level > 1) {\n                        if (self.get_token(true)) {\n                            self.set_token(undefined, true);\n                        }\n                        self.pop();\n                    }\n                    after_exec();\n                } else if (settings.clear && command.match(/^\\s*clear\\s*$/) &&\n                           !in_login) {\n                    self.clear();\n                    after_exec();\n                } else {\n                    var ret = invoke();\n                    if (ret) {\n                        return ret;\n                    }\n                }\n                return deferred.promise();\n            } catch (e) {\n                display_exception(e, 'USER', exec);\n                self.resume();\n                if (exec) {\n                    throw e;\n                }\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: The logout function removes Storage, disables history and runs\n        // :: the login function. This function is called only when options.login\n        // :: function is defined. The check for this is in the self.pop method\n        // ---------------------------------------------------------------------\n        function global_logout() {\n            if (fire_event('onBeforeLogout', [], true) === false) {\n                return;\n            }\n            clear_loging_storage();\n            fire_event('onAfterlogout', [], true);\n            self.login(global_login_fn, true, initialize);\n        }\n        // ---------------------------------------------------------------------\n        function clear_loging_storage() {\n            var name = self.prefix_name(true) + '_';\n            storage.remove(name + 'token');\n            storage.remove(name + 'login');\n        }\n        // ---------------------------------------------------------------------\n        // :: Save the interpreter name for use with purge\n        // ---------------------------------------------------------------------\n        function maybe_append_name(interpreter_name) {\n            var storage_key = self.prefix_name() + '_interpreters';\n            var names = storage.get(storage_key);\n            if (names) {\n                names = JSON.parse(names);\n            } else {\n                names = [];\n            }\n            if ($.inArray(interpreter_name, names) === -1) {\n                names.push(interpreter_name);\n                storage.set(storage_key, JSON.stringify(names));\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: Function enables history, sets prompt, runs interpreter function\n        // ---------------------------------------------------------------------\n        function prepare_top_interpreter(silent) {\n            var interpreter = interpreters.top();\n            var name = self.prefix_name(true);\n            if (!ghost()) {\n                maybe_append_name(name);\n            }\n            var login = self.login_name(true);\n            command_line.name(name + (login ? '_' + login : ''));\n            var prompt = interpreter.prompt;\n            if (is_function(prompt)) {\n                prompt = context_callback_proxy(prompt);\n            }\n            if (prompt !== command_line.prompt()) {\n                if (is_function(interpreter.prompt)) {\n                    // prevent flicker of old prompt until async prompt finishes\n                    command_line.prompt('');\n                }\n                command_line.prompt(interpreter.prompt);\n            }\n            if (typeof interpreter.history !== 'undefined') {\n                self.history().toggle(interpreter.history);\n            }\n            if ($.isPlainObject(interpreter.keymap)) {\n                command_line.keymap($.omap(interpreter.keymap, function(name, fun) {\n                    return function() {\n                        var args = [].slice.call(arguments);\n                        try {\n                            return fun.apply(self, args);\n                        } catch (e) {\n                            display_exception(e, 'USER KEYMAP');\n                        }\n                    };\n                }));\n            }\n            command_line.set('');\n            init_queue.resolve();\n            if (!silent && is_function(interpreter.onStart)) {\n                interpreter.onStart.call(self, self);\n            }\n        }\n        // ---------------------------------------------------------------------\n        function fire_event(name, args, skip_local) {\n            args = (args || []).concat([self]); // create new array\n            // even can be fired before interpreters is created\n            var top = interpreters && interpreters.top();\n            if (top && is_function(top[name]) && !skip_local) {\n                try {\n                    return top[name].apply(self, args);\n                } catch (e) {\n                    delete top[name];\n                    display_exception(e, name);\n                }\n            } else if (is_function(settings[name])) {\n                try {\n                    return settings[name].apply(self, args);\n                } catch (e) {\n                    settings[name] = null;\n                    display_exception(e, name);\n                }\n            }\n        }\n        var scroll_to_view = (function() {\n            function scroll_to_view(visible) {\n                if (!visible) {\n                    // try catch for Node.js unit tests\n                    try {\n                        self.scroll_to(self.find('.cmd-cursor'));\n                        return true;\n                    } catch (e) {\n                        return true;\n                    }\n                }\n            }\n            // we don't want debounce in Unit Tests\n            if (typeof global !== 'undefined' && typeof global.it === 'function') {\n                return scroll_to_view;\n            }\n            return debounce(scroll_to_view, 100, {\n                leading: true,\n                trailing: false\n            });\n        })();\n        // ---------------------------------------------------------------------\n        function make_cursor_visible() {\n            var cursor = self.find('.cmd-cursor-line');\n            return cursor.is_fully_in_viewport(self).then(scroll_to_view);\n        }\n        // ---------------------------------------------------------------------\n        function hashchange() {\n            if (fire_hash_change && settings.execHash) {\n                try {\n                    if (location.hash) {\n                        var hash = location.hash.replace(/^#/, '');\n                        hash_commands = JSON.parse(decodeURIComponent(hash));\n                    } else {\n                        hash_commands = [];\n                    }\n                    if (hash_commands.length) {\n                        restore_state(hash_commands[hash_commands.length - 1]);\n                    } else if (save_state[0]) {\n                        self.import_view(save_state[0]);\n                    }\n                } catch (e) {\n                    display_exception(e, 'TERMINAL');\n                }\n            }\n        }\n        // ---------------------------------------------------------------------\n        function initialize() {\n            prepare_top_interpreter();\n            show_greetings();\n            if (lines.length) {\n                self.refresh(); // for case when showing long error before init\n            }\n            // was_paused flag is workaround for case when user call exec before\n            // login and pause in onInit, 3rd exec will have proper timing (will\n            // execute after onInit resume)\n            var was_paused = false;\n            if (is_function(settings.onInit)) {\n                onPause = function() { // local in terminal\n                    was_paused = true;\n                };\n                try {\n                    settings.onInit.call(self, self);\n                } catch (e) {\n                    display_exception(e, 'OnInit');\n                    // throw e; // it will be catched by terminal\n                } finally {\n                    onPause = $.noop;\n                    if (!was_paused && self.enabled()) {\n                        // resume login if user didn't call pause in onInit\n                        // if user pause in onInit wait with exec until it\n                        // resume\n                        self.resume(true);\n                    }\n                }\n            }\n            if (first_instance) {\n                first_instance = false;\n                $(window).on('hashchange', hashchange);\n            }\n        }\n        // ---------------------------------------------------------------------\n        // :: If Ghost don't store anything in localstorage\n        // ---------------------------------------------------------------------\n        function ghost() {\n            return in_login || command_line.mask() !== false;\n        }\n        // ---------------------------------------------------------------------\n        // :: Keydown event handler\n        // ---------------------------------------------------------------------\n        function user_key_down(e) {\n            var result, top = interpreters.top();\n            if (is_function(top.keydown)) {\n                result = top.keydown.call(self, e, self);\n                if (result !== undefined) {\n                    return result;\n                }\n            } else if (is_function(settings.keydown)) {\n                result = settings.keydown.call(self, e, self);\n                if (result !== undefined) {\n                    return result;\n                }\n            }\n        }\n        var keymap = {\n            'CTRL+D': function(e, original) {\n                if (!in_login) {\n                    if (command_line.get() === '') {\n                        if (interpreters.size() > 1 ||\n                            is_function(global_login_fn)) {\n                            self.pop('');\n                        } else {\n                            self.resume();\n                            self.echo('');\n                        }\n                    } else {\n                        original();\n                    }\n                }\n                return false;\n            },\n            'CTRL+C': function() {\n                with_selection(function(html) {\n                    if (html === '') {\n                        var command = self.get_command();\n                        var position = self.get_position();\n                        command = command.slice(0, position) + '^C' +\n                            command.slice(position + 2);\n                        echo_command(command);\n                        self.set_command('');\n                    } else {\n                        var clip = self.find('textarea');\n                        text_to_clipboard(clip, process_selected_html(html));\n                    }\n                });\n                return false;\n            },\n            'CTRL+L': function() {\n                self.clear();\n            },\n            'TAB': function(e, orignal) {\n                // TODO: move this to cmd plugin\n                //       add completion = array | function\n                //       !!! Problem complete more then one key need terminal\n                var top = interpreters.top(), completion, caseSensitive;\n                if (typeof top.caseSensitiveAutocomplete !== 'undefined') {\n                    caseSensitive = top.caseSensitiveAutocomplete;\n                } else {\n                    caseSensitive = settings.caseSensitiveAutocomplete;\n                }\n                if (settings.completion &&\n                    get_type(settings.completion) !== 'boolean' &&\n                    top.completion === undefined) {\n                    completion = settings.completion;\n                } else {\n                    completion = top.completion;\n                }\n                if (completion === 'settings') {\n                    completion = settings.completion;\n                }\n                function resolve(commands) {\n                    // local copy\n                    commands = commands.slice();\n                    // default commands should not match for arguments\n                    if (!self.before_cursor(false).match(/\\s/)) {\n                        if (settings.clear && $.inArray('clear', commands) === -1) {\n                            commands.push('clear');\n                        }\n                        if (settings.exit && $.inArray('exit', commands) === -1) {\n                            commands.push('exit');\n                        }\n                    }\n                    self.complete(commands, {\n                        echo: true,\n                        word: settings.wordAutocomplete,\n                        escape: settings.completionEscape,\n                        caseSensitive: caseSensitive,\n                        echoCommand: settings.doubleTabEchoCommand,\n                        doubleTab: settings.doubleTab\n                    });\n                }\n                if (completion) {\n                    switch (get_type(completion)) {\n                        case 'function':\n                            var string = self.before_cursor(settings.wordAutocomplete);\n                            if (completion.length === 3) {\n                                var error = new Error(strings().comletionParameters);\n                                display_exception(error, 'USER');\n                                return false;\n                            }\n                            var result = completion.call(self, string, resolve);\n                            unpromise(result, resolve, make_label_error('Completion'));\n                            break;\n                        case 'array':\n                            resolve(completion);\n                            break;\n                        default:\n                            throw new $.terminal.Exception(strings().invalidCompletion);\n                    }\n                } else {\n                    orignal();\n                }\n                return false;\n            },\n            'CTRL+V': function(e, original) {\n                original(e);\n                self.oneTime(200, function() {\n                    self.scroll_to_bottom();\n                });\n                return true;\n            },\n            'CTRL+TAB': function() {\n                if (terminals.length() > 1) {\n                    self.focus(false);\n                    return false;\n                }\n            },\n            'PAGEDOWN': function() {\n                self.scroll(self.height());\n            },\n            'PAGEUP': function() {\n                self.scroll(-self.height());\n            }\n        };\n        // ---------------------------------------------------------------------\n        function key_down(e) {\n            // Prevent to be executed by cmd: CTRL+D, TAB, CTRL+TAB (if more\n            // then one terminal)\n            var result, i;\n            if (self.enabled()) {\n                if (!self.paused()) {\n                    result = user_key_down(e);\n                    if (result !== undefined) {\n                        return result;\n                    }\n                    if (e.which !== 9) { // not a TAB\n                        tab_count = 0;\n                    }\n                } else {\n                    if (!settings.pauseEvents) {\n                        result = user_key_down(e);\n                        if (result !== undefined) {\n                            return result;\n                        }\n                    }\n                    if (e.which === 68 && e.ctrlKey) { // CTRL+D (if paused)\n                        if (settings.pauseEvents) {\n                            result = user_key_down(e);\n                            if (result !== undefined) {\n                                return result;\n                            }\n                        }\n                        if (requests.length) {\n                            for (i = requests.length; i--;) {\n                                var r = requests[i];\n                                if (r.readyState !== 4) {\n                                    try {\n                                        r.abort();\n                                    } catch (error) {\n                                        if (is_function(settings.exceptionHandler)) {\n                                            settings.exceptionHandler.call(\n                                                self,\n                                                e,\n                                                'AJAX ABORT'\n                                            );\n                                        } else {\n                                            self.error(strings().ajaxAbortError);\n                                        }\n                                    }\n                                }\n                            }\n                            requests = [];\n                        }\n                        self.resume();\n                    }\n                    return false;\n                }\n            }\n        }\n        // ---------------------------------------------------------------------\n        function key_press(e) {\n            var top = interpreters.top();\n            if (enabled && (!paused || !settings.pauseEvents)) {\n                if (is_function(top.keypress)) {\n                    return top.keypress.call(self, e, self);\n                } else if (is_function(settings.keypress)) {\n                    return settings.keypress.call(self, e, self);\n                }\n            }\n        }\n        // ---------------------------------------------------------------------\n        function ready(queue) {\n            return function(fun) {\n                queue.add(fun);\n            };\n        }\n        // ---------------------------------------------------------------------\n        function strings() {\n            return $.extend(\n                {},\n                $.terminal.defaults.strings,\n                settings && settings.strings || {}\n            );\n        }\n        // ---------------------------------------------------------------------\n        var self = this;\n        if (self.is('body,html')) {\n            self = $('<div/>').appendTo('body');\n            $('body').addClass('full-screen-terminal');\n        }\n        if (this.length > 1) {\n            return this.each(function() {\n                $.fn.terminal.call(\n                    $(this),\n                    init_interpreter,\n                    $.extend({name: self.selector}, options)\n                );\n            });\n        }\n        // terminal already exists\n        if (self.data('terminal')) {\n            return self.data('terminal');\n        }\n        // -----------------------------------------------------------------\n        // TERMINAL METHODS\n        // -----------------------------------------------------------------\n        $.extend(self, $.omap({\n            id: function() {\n                return terminal_id;\n            },\n            // -------------------------------------------------------------\n            // :: Clear the output\n            // -------------------------------------------------------------\n            clear: function() {\n                if (fire_event('onClear') !== false) {\n                    lines.forEach(function(line, i) {\n                        var options = line[1];\n                        if (is_function(options.onClear)) {\n                            options.onClear.call(self, get_node(i));\n                        }\n                    });\n                    lines = [];\n                    output[0].innerHTML = '';\n                    self.prop({scrollTop: 0});\n                }\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Return an object that can be used with import_view to\n            // :: restore the state\n            // -------------------------------------------------------------\n            export_view: function() {\n                var user_export = fire_event('onExport');\n                user_export = user_export || {};\n                return $.extend({}, {\n                    focus: enabled,\n                    mask: command_line.mask(),\n                    prompt: self.get_prompt(),\n                    command: self.get_command(),\n                    position: command_line.position(),\n                    lines: clone(lines),\n                    interpreters: interpreters.clone(),\n                    history: command_line.history().data\n                }, user_export);\n            },\n            // -------------------------------------------------------------\n            // :: Restore the state of the previous exported view\n            // -------------------------------------------------------------\n            import_view: function(view) {\n                if (in_login) {\n                    throw new Error(sprintf(strings().notWhileLogin, 'import_view'));\n                }\n                fire_event('onImport', [view]);\n                when_ready(function ready() {\n                    self.set_prompt(view.prompt);\n                    self.set_command(view.command);\n                    command_line.position(view.position);\n                    command_line.mask(view.mask);\n                    if (view.focus) {\n                        self.focus();\n                    }\n                    lines = clone(view.lines).filter(function(line) {\n                        return line[0];\n                    });\n                    if (view.interpreters instanceof Stack) {\n                        interpreters = view.interpreters;\n                    }\n                    if (settings.importHistory) {\n                        command_line.history().set(view.history);\n                    }\n                    redraw();\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Store current terminal state\n            // -------------------------------------------------------------\n            save_state: function(command, ignore_hash, index) {\n                // save_state.push({view:self.export_view(), join:[]});\n                if (typeof index !== 'undefined') {\n                    save_state[index] = self.export_view();\n                } else {\n                    save_state.push(self.export_view());\n                }\n                if (!$.isArray(hash_commands)) {\n                    hash_commands = [];\n                }\n                if (command !== undefined && !ignore_hash) {\n                    var state = [\n                        terminal_id,\n                        save_state.length - 1,\n                        command\n                    ];\n                    hash_commands.push(state);\n                    maybe_update_hash();\n                }\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Execute a command, it will handle commands that do AJAX\n            // :: calls and have delays, if the second argument is set to\n            // :: true it will not echo executed command\n            // -------------------------------------------------------------\n            exec: function(command, silent, deferred) {\n                var d = deferred || new $.Deferred();\n                cmd_ready(function ready() {\n                    if ($.isArray(command)) {\n                        (function recur() {\n                            var cmd = command.shift();\n                            if (cmd) {\n                                self.exec(cmd, silent).done(recur);\n                            } else {\n                                d.resolve();\n                            }\n                        })();\n                    } else if (paused) {\n                        // both commands executed here (resume will call Term::exec)\n                        // delay command multiple time\n                        delayed_commands.push([command, silent, d]);\n                    } else {\n                        // commands may return promise from user code\n                        // it will resolve exec promise when user promise\n                        // is resolved\n                        var ret = commands(command, silent, true);\n                        unpromise(ret, function() {\n                            d.resolve();\n                        }, function() {\n                            d.reject();\n                        });\n                    }\n                });\n                // while testing it didn't executed last exec when using this\n                // for resolved deferred\n                return d.promise();\n            },\n            // -------------------------------------------------------------\n            // :: bypass login function that wait untill you type user/pass\n            // :: it hide implementation detail\n            // -------------------------------------------------------------\n            autologin: function(user, token, silent) {\n                self.trigger('terminal.autologin', [user, token, silent]);\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Function changes the prompt of the command line to login\n            // :: with a password and calls the user login function with\n            // :: the callback that expects a token. The login is successful\n            // :: if the user calls it with value that is truthy\n            // -------------------------------------------------------------\n            login: function(auth, infinite, success, error) {\n                logins.push([].slice.call(arguments));\n                if (in_login) {\n                    throw new Error(sprintf(strings().notWhileLogin, 'login'));\n                }\n                if (!is_function(auth)) {\n                    throw new Error(strings().loginIsNotAFunction);\n                }\n                in_login = true;\n                if (self.token() && self.level() === 1 && !autologin) {\n                    in_login = false; // logout will call login\n                    self.logout(true);\n                } else if (self.token(true) && self.login_name(true)) {\n                    in_login = false;\n                    if (is_function(success)) {\n                        success();\n                    }\n                    return self;\n                }\n                // don't store login data in history\n                if (settings.history) {\n                    command_line.history().disable();\n                }\n                function popUserPass() {\n                    while (self.level() > level) {\n                        self.pop(undefined, true);\n                    }\n                    if (settings.history) {\n                        command_line.history().enable();\n                    }\n                }\n                // so we know how many times call pop\n                var level = self.level();\n                function login_callback(user, token, silent) {\n                    if (self.paused()) {\n                        self.resume();\n                    }\n                    if (token) {\n                        popUserPass();\n                        var name = self.prefix_name(true) + '_';\n                        storage.set(name + 'token', token);\n                        storage.set(name + 'login', user);\n                        in_login = false;\n                        fire_event('onAfterLogin', [user, token]);\n                        if (is_function(success)) {\n                            // will be used internaly since users know\n                            // when login success (they decide when\n                            // it happen by calling the callback -\n                            // this funtion)\n                            success();\n                        }\n                    } else {\n                        if (infinite) {\n                            if (!silent) {\n                                self.error(strings().wrongPasswordTryAgain);\n                            }\n                            self.pop(undefined, true).set_mask(false);\n                        } else {\n                            in_login = false;\n                            if (!silent) {\n                                self.error(strings().wrongPassword);\n                            }\n                            self.pop(undefined, true).pop(undefined, true);\n                        }\n                        // used only to call pop in push\n                        if (is_function(error)) {\n                            error();\n                        }\n                    }\n                    self.off('terminal.autologin');\n                }\n                self.on('terminal.autologin', function(event, user, token, silent) {\n                    if (fire_event('onBeforeLogin', [user, token]) === false) {\n                        return;\n                    }\n                    login_callback(user, token, silent);\n                });\n                self.push(function(user) {\n                    self.set_mask(settings.maskChar).push(function(pass) {\n                        try {\n                            if (fire_event('onBeforeLogin', [user, pass]) === false) {\n                                popUserPass();\n                                return;\n                            }\n                            self.pause();\n                            var ret = auth.call(self, user, pass, function(\n                                token,\n                                silent) {\n                                login_callback(user, token, silent);\n                            });\n                            if (ret && is_function(ret.then || ret.done)) {\n                                (ret.then || ret.done).call(ret, function(token) {\n                                    login_callback(user, token);\n                                });\n                            }\n                        } catch (e) {\n                            display_exception(e, 'AUTH');\n                        }\n                    }, {\n                        prompt: strings().password + ': ',\n                        name: 'password'\n                    });\n                }, {\n                    prompt: strings().login + ': ',\n                    name: 'login'\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: User defined settings and defaults as well\n            // -------------------------------------------------------------\n            settings: function() {\n                return settings;\n            },\n            // -------------------------------------------------------------\n            // :: Get string before cursor\n            // -------------------------------------------------------------\n            before_cursor: function(word) {\n                var pos = command_line.position();\n                var command = command_line.get().slice(0, pos);\n                var cmd_strings = command.split(' ');\n                var string; // string before cursor that will be completed\n                if (word) {\n                    if (cmd_strings.length === 1) {\n                        string = cmd_strings[0];\n                    } else {\n                        var m = command.match(/(\\\\?\")/g);\n                        var double_quotes = m ? m.filter(function(chr) {\n                            return !chr.match(/^\\\\/);\n                        }).length : 0;\n                        m = command.match(/'/g);\n                        var single_quote = m ? m.length : 0;\n                        if (single_quote % 2 === 1) {\n                            string = command.match(/('[^']*)$/)[0];\n                        } else if (double_quotes % 2 === 1) {\n                            string = command.match(/(\"(?:[^\"]|\\\\\")*)$/)[0];\n                        } else {\n                            string = cmd_strings[cmd_strings.length - 1];\n                            for (i = cmd_strings.length - 1; i > 0; i--) {\n                                // treat escape space as part of the string\n                                var prev_string = cmd_strings[i - 1];\n                                if (prev_string[prev_string.length - 1] === '\\\\') {\n                                    string = cmd_strings[i - 1] + ' ' + string;\n                                } else {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    string = command;\n                }\n                return string;\n            },\n            // -------------------------------------------------------------\n            // :: complete word or command based on array of words\n            // -------------------------------------------------------------\n            complete: function(commands, options) {\n                options = $.extend({\n                    word: true,\n                    echo: false,\n                    escape: true,\n                    echoCommand: false,\n                    caseSensitive: true,\n                    doubleTab: null\n                }, options || {});\n                var sensitive = options.caseSensitive;\n                // cursor can be in the middle of the command\n                // so we need to get the text before the cursor\n                var string = self.before_cursor(options.word).replace(/\\\\\"/g, '\"');\n                var quote = false;\n                if (options.word) {\n                    if (string.match(/^\"/)) {\n                        quote = '\"';\n                    } else if (string.match(/^'/)) {\n                        quote = \"'\";\n                    }\n                    if (quote) {\n                        string = string.replace(/^[\"']/, '');\n                    }\n                }\n                if (tab_count % 2 === 0) {\n                    command = self.before_cursor(options.word);\n                } else {\n                    var test = self.before_cursor(options.word);\n                    if (test !== command) {\n                        // command line changed between TABS - ignore\n                        return;\n                    }\n                }\n                var safe = $.terminal.escape_regex(string);\n                if (options.escape) {\n                    safe = safe.replace(/(\\\\+)([\"'() ])/g, function(_, slash, chr) {\n                        if (chr.match(/[()]/)) {\n                            return slash + '\\\\?\\\\' + chr;\n                        } else {\n                            return slash + '?' + chr;\n                        }\n                    });\n                }\n                function escape(string) {\n                    if (quote === '\"') {\n                        string = string.replace(/\"/g, '\\\\\"');\n                    }\n                    if (!quote && options.escape) {\n                        string = string.replace(/([\"'() ])/g, '\\\\$1');\n                    }\n                    return string;\n                }\n                function matched_strings() {\n                    var matched = [];\n                    for (var i = commands.length; i--;) {\n                        if (commands[i].match(/\\n/) && options.word) {\n                            warn('If you use commands with newlines you ' +\n                                 'should use word option for complete or' +\n                                 ' wordAutocomplete terminal option');\n                        }\n                        if (regex.test(commands[i])) {\n                            var match = escape(commands[i]);\n                            if (!sensitive && same_case(match)) {\n                                if (string.toLowerCase() === string) {\n                                    match = match.toLowerCase();\n                                } else if (string.toUpperCase() === string) {\n                                    match = match.toUpperCase();\n                                }\n                            }\n                            matched.push(match);\n                        }\n                    }\n                    return matched;\n                }\n                var flags = sensitive ? '' : 'i';\n                var regex = new RegExp('^' + safe, flags);\n                var matched = matched_strings();\n                function replace(input, replacement) {\n                    var text = self.get_command();\n                    var pos = self.get_position();\n                    var re = new RegExp('^' + input, 'i');\n                    var pre = text.slice(0, pos);\n                    var post = text.slice(pos);\n                    var to_insert = replacement.replace(re, '') + (quote || '');\n                    self.set_command(pre + to_insert + post);\n                    self.set_position((pre + to_insert).length);\n                }\n                if (matched.length === 1) {\n                    if (options.escape) {\n                        replace(safe, matched[0]);\n                    } else {\n                        self.insert(matched[0].replace(regex, '') + (quote || ''));\n                    }\n                    command = self.before_cursor(options.word);\n                    return true;\n                } else if (matched.length > 1) {\n                    if (++tab_count >= 2) {\n                        tab_count = 0;\n                        if (options.echo) {\n                            if (is_function(options.doubleTab)) {\n                                // new API old is keep for backward compatibility\n                                if (options.echoCommand) {\n                                    echo_command();\n                                }\n                                var ret = options.doubleTab.call(\n                                    self,\n                                    string,\n                                    matched,\n                                    echo_command\n                                );\n                                if (typeof ret === 'undefined') {\n                                    return true;\n                                } else {\n                                    return ret;\n                                }\n                            } else if (options.doubleTab !== false) {\n                                echo_command();\n                                var text = matched.slice().reverse().join('\\t\\t');\n                                self.echo($.terminal.escape_brackets(text), {\n                                    keepWords: true,\n                                    formatters: false\n                                });\n                            }\n                            return true;\n                        }\n                    } else {\n                        var common = common_string(escape(string), matched, sensitive);\n                        if (common) {\n                            replace(safe, common);\n                            command = self.before_cursor(options.word);\n                            return true;\n                        }\n                    }\n                }\n            },\n            // -------------------------------------------------------------\n            // :: Return commands function from top interpreter\n            // -------------------------------------------------------------\n            commands: function() {\n                return interpreters.top().interpreter;\n            },\n            // -------------------------------------------------------------\n            // :: Low Level method that overwrites interpreter\n            // -------------------------------------------------------------\n            set_interpreter: function(user_intrp, login) {\n                function overwrite_interpreter() {\n                    self.pause(settings.softPause);\n                    make_interpreter(user_intrp, login, function(result) {\n                        self.resume();\n                        var top = interpreters.top();\n                        $.extend(top, result);\n                        prepare_top_interpreter(true);\n                    });\n                }\n                if (is_function(login)) {\n                    self.login(login, true, overwrite_interpreter);\n                } else if (get_type(user_intrp) === 'string' && login) {\n                    self.login(\n                        make_json_rpc_login(user_intrp, login),\n                        true,\n                        overwrite_interpreter\n                    );\n                } else {\n                    overwrite_interpreter();\n                }\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Show user greetings or terminal signature\n            // -------------------------------------------------------------\n            greetings: function() {\n                show_greetings();\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Return true if terminal is paused false otherwise\n            // -------------------------------------------------------------\n            paused: function() {\n                return paused;\n            },\n            // -------------------------------------------------------------\n            // :: Pause the terminal, it should be used for ajax calls\n            // -------------------------------------------------------------\n            pause: function(visible) {\n                cmd_ready(function ready() {\n                    onPause();\n                    paused = true;\n                    command_line.disable(visible || is_android);\n                    if (!visible) {\n                        command_line.find('.cmd-prompt').hidden();\n                    }\n                    fire_event('onPause');\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Resume the previously paused terminal\n            // -------------------------------------------------------------\n            resume: function(silent) {\n                cmd_ready(function ready() {\n                    paused = false;\n                    if (enabled && terminals.front() === self) {\n                        command_line.enable(silent);\n                    }\n                    command_line.find('.cmd-prompt').visible();\n                    var original = delayed_commands;\n                    delayed_commands = [];\n                    for (var i = 0; i < original.length; ++i) {\n                        self.exec.apply(self, original[i]);\n                    }\n                    self.trigger('resume');\n                    var fn = resume_callbacks.shift();\n                    if (fn) {\n                        fn();\n                    }\n                    self.scroll_to_bottom();\n                    fire_event('onResume');\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Return the number of characters that fit into the width of\n            // :: the terminal\n            // -------------------------------------------------------------\n            cols: function() {\n                if (settings.numChars) {\n                    return settings.numChars;\n                }\n                if (typeof num_chars === 'undefined' || num_chars === 1000) {\n                    num_chars = get_num_chars(self, char_size);\n                }\n                return num_chars;\n            },\n            // -------------------------------------------------------------\n            // :: Return the number of lines that fit into the height of the\n            // :: terminal\n            // -------------------------------------------------------------\n            rows: function() {\n                if (settings.numRows) {\n                    return settings.numRows;\n                }\n                if (typeof num_rows === 'undefined') {\n                    num_rows = get_num_rows(self, char_size);\n                }\n                return num_rows;\n            },\n            // -------------------------------------------------------------\n            // :: Return the History object\n            // -------------------------------------------------------------\n            history: function() {\n                return command_line.history();\n            },\n            // -------------------------------------------------------------\n            // :: toggle recording of history state\n            // -------------------------------------------------------------\n            history_state: function(toggle) {\n                function run() {\n                    settings.historyState = true;\n                    if (!save_state.length) {\n                        self.save_state();\n                    } else if (terminals.length() > 1) {\n                        self.save_state(null);\n                    }\n                }\n                if (toggle) {\n                    // if set to true and if set from user command we need\n                    // not to include the command\n                    if (typeof window.setImmediate === 'undefined') {\n                        setTimeout(run, 0);\n                    } else {\n                        setImmediate(run);\n                    }\n                } else {\n                    settings.historyState = false;\n                }\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: clear the history state\n            // -------------------------------------------------------------\n            clear_history_state: function() {\n                hash_commands = [];\n                save_state = [];\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Switch to the next terminal\n            // -------------------------------------------------------------\n            next: function() {\n                if (terminals.length() === 1) {\n                    return self;\n                } else {\n                    terminals.front().disable();\n                    var next = terminals.rotate().enable();\n                    // 50 provides buffer in viewport\n                    var x = next.offset().top - 50;\n                    $('html,body').animate({scrollTop: x}, 500);\n                    try {\n                        trigger_terminal_change(next);\n                    } catch (e) {\n                        display_exception(e, 'onTerminalChange');\n                    }\n                    return next;\n                }\n            },\n            // -------------------------------------------------------------\n            // :: Make the terminal in focus or blur depending on the first\n            // :: argument. If there is more then one terminal it will\n            // :: switch to next one, if the second argument is set to true\n            // :: the events will be not fired. Used on init\n            // -------------------------------------------------------------\n            focus: function(toggle, silent) {\n                cmd_ready(function ready() {\n                    if (terminals.length() === 1) {\n                        if (toggle === false) {\n                            self.disable(silent);\n                        } else {\n                            self.enable(silent);\n                        }\n                    } else if (toggle === false) {\n                        self.next();\n                    } else {\n                        var front = terminals.front();\n                        if (front !== self) {\n                            // there should be only from terminal enabled but tests\n                            // sometime fail because there where more them one\n                            // where cursor have blink class\n                            terminals.forEach(function(terminal) {\n                                if (terminal !== self && terminal.enabled()) {\n                                    terminal.disable(silent);\n                                }\n                            });\n                            if (!silent) {\n                                try {\n                                    trigger_terminal_change(self);\n                                } catch (e) {\n                                    display_exception(e, 'onTerminalChange');\n                                }\n                            }\n                        }\n                        terminals.set(self);\n                        self.enable(silent);\n                    }\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Disable/Enable terminal that can be enabled by click\n            // -------------------------------------------------------------\n            freeze: function(freeze) {\n                when_ready(function ready() {\n                    if (freeze) {\n                        self.disable();\n                        frozen = true;\n                    } else {\n                        frozen = false;\n                        self.enable();\n                    }\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: check if terminal is frozen\n            // -------------------------------------------------------------\n            frozen: function() {\n                return frozen;\n            },\n            // -------------------------------------------------------------\n            // :: Enable the terminal\n            // -------------------------------------------------------------\n            enable: function(silent) {\n                if (!enabled && !frozen) {\n                    if (num_chars === undefined) {\n                        // enabling first time\n                        self.resize();\n                    }\n                    cmd_ready(function ready() {\n                        var ret;\n                        if (!silent && !enabled) {\n                            fire_event('onFocus');\n                        }\n                        if (!silent && ret === undefined || silent) {\n                            enabled = true;\n                            if (!self.paused()) {\n                                command_line.enable(true);\n                            }\n                        }\n                    });\n                }\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: function clear formatting cache if you don't longer need it\n            // :: cache is used if option useCache is set to true\n            // -------------------------------------------------------------\n            clear_cache: 'Map' in root ? function() {\n                format_cache.clear();\n                string_cache.clear();\n                return self;\n            } : function() {\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Disable the terminal\n            // -------------------------------------------------------------\n            disable: function(silent) {\n                cmd_ready(function ready() {\n                    var ret;\n                    if (!silent && enabled) {\n                        ret = fire_event('onBlur');\n                    }\n                    if (!silent && ret === undefined || silent) {\n                        enabled = false;\n                        command_line.disable();\n                    }\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: return true if the terminal is enabled\n            // -------------------------------------------------------------\n            enabled: function() {\n                return enabled;\n            },\n            // -------------------------------------------------------------\n            // :: Return the terminal signature depending on the size of the terminal\n            // -------------------------------------------------------------\n            signature: function() {\n                var cols = self.cols();\n                for (var i = signatures.length; i--;) {\n                    var lengths = signatures[i].map(function(line) {\n                        return line.length;\n                    });\n                    if (Math.max.apply(null, lengths) <= cols) {\n                        return signatures[i].join('\\n') + '\\n';\n                    }\n                }\n                return '';\n            },\n            // -------------------------------------------------------------\n            // :: Return the version number\n            // -------------------------------------------------------------\n            version: function() {\n                return $.terminal.version;\n            },\n            // -------------------------------------------------------------\n            // :: Return actual command line object (jquery object with cmd\n            // :: methods)\n            // -------------------------------------------------------------\n            cmd: function() {\n                return command_line;\n            },\n            // -------------------------------------------------------------\n            // :: Return the current command entered by terminal\n            // -------------------------------------------------------------\n            get_command: function() {\n                return command_line.get();\n            },\n            // -------------------------------------------------------------\n            // :: echo command and previous prompt (used by echo_newline.js)\n            // -------------------------------------------------------------\n            echo_command: function(command) {\n                return echo_command(command);\n            },\n            // -------------------------------------------------------------\n            // :: Change the command line to the new one\n            // -------------------------------------------------------------\n            set_command: function(command, silent) {\n                when_ready(function ready() {\n                    // TODO: refactor to use options - breaking change\n                    if (typeof command !== 'string') {\n                        command = JSON.stringify(command);\n                    }\n                    command_line.set(command, undefined, silent);\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Change position of the command line\n            // -------------------------------------------------------------\n            set_position: function(position, relative) {\n                when_ready(function ready() {\n                    command_line.position(position, relative);\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Return position of the command line\n            // -------------------------------------------------------------\n            get_position: function() {\n                return command_line.position();\n            },\n            // -------------------------------------------------------------\n            // :: Insert text into the command line after the cursor\n            // -------------------------------------------------------------\n            insert: function(string, stay) {\n                if (typeof string === 'string') {\n                    when_ready(function ready() {\n                        var bottom = self.is_bottom();\n                        command_line.insert(string, stay);\n                        if (settings.scrollOnEcho || bottom) {\n                            self.scroll_to_bottom();\n                        }\n                    });\n                    return self;\n                } else {\n                    throw new Error(sprintf(strings().notAString, 'insert'));\n                }\n            },\n            // -------------------------------------------------------------\n            // :: Set the prompt of the command line\n            // -------------------------------------------------------------\n            set_prompt: function(prompt) {\n                when_ready(function ready() {\n                    if (is_function(prompt)) {\n                        command_line.prompt(function(callback) {\n                            prompt.call(self, callback, self);\n                        });\n                    } else {\n                        command_line.prompt(prompt);\n                    }\n                    interpreters.top().prompt = prompt;\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Return the prompt used by the terminal\n            // -------------------------------------------------------------\n            get_prompt: function() {\n                return interpreters.top().prompt;\n                // command_line.prompt(); - can be a wrapper\n                //return command_line.prompt();\n            },\n            // -------------------------------------------------------------\n            // :: Enable or Disable mask depedning on the passed argument\n            // :: the mask can also be character (in fact it will work with\n            // :: strings longer then one)\n            // -------------------------------------------------------------\n            set_mask: function(mask) {\n                when_ready(function ready() {\n                    command_line.mask(mask === true ? settings.maskChar : mask);\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Return the ouput of the terminal as text\n            // -------------------------------------------------------------\n            get_output: function(raw) {\n                if (raw) {\n                    return lines;\n                } else {\n                    return $.map(lines, function(item) {\n                        return is_function(item[0]) ? item[0]() : item[0];\n                    }).join('\\n');\n                }\n            },\n            // -------------------------------------------------------------\n            // :: Recalculate and redraw everything\n            // -------------------------------------------------------------\n            resize: function(width, height) {\n                if (!self.is(':visible')) {\n                    // delay resize if terminal not visible\n                    self.stopTime('resize');\n                    self.oneTime(500, 'resize', function() {\n                        self.resize(width, height);\n                    });\n                } else {\n                    if (width && height) {\n                        self.width(width);\n                        self.height(height);\n                    }\n                    width = self.width();\n                    height = self.height();\n                    if (typeof settings.numChars !== 'undefined' ||\n                        typeof settings.numRows !== 'undefined') {\n                        command_line.resize(settings.numChars);\n                        self.refresh();\n                        fire_event('onResize');\n                        return;\n                    }\n                    var new_num_chars = get_num_chars(self, char_size);\n                    var new_num_rows = get_num_rows(self, char_size);\n                    // only if number of chars changed\n                    if (new_num_chars !== num_chars ||\n                        new_num_rows !== num_rows) {\n                        num_chars = new_num_chars;\n                        num_rows = new_num_rows;\n                        command_line.resize(num_chars);\n                        self.refresh();\n                        fire_event('onResize');\n                    }\n                }\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: redraw the terminal\n            // -------------------------------------------------------------\n            refresh: function() {\n                if (char_size.width !== 0) {\n                    self[0].style.setProperty('--char-width', char_size.width);\n                }\n                redraw({\n                    scroll: false,\n                    update: true\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Flush the output to the terminal\n            // -------------------------------------------------------------\n            flush: function(options) {\n                options = $.extend({}, {\n                    update: false,\n                    scroll: true\n                }, options || {});\n                try {\n                    var bottom = self.is_bottom();\n                    output.css('visibilty', 'hidden');\n                    var wrapper;\n                    // print all lines\n                    // var output_buffer = lines.flush();\n                    while (output_buffer.length) {\n                        var data = output_buffer.shift();\n                        if (data === NEW_LINE) {\n                            wrapper = $(document.createElement('div'));\n                        } else if ($.isPlainObject(data) && is_function(data.finalize)) {\n                            // this is finalize function from echo\n                            if (options.update) {\n                                var selector = '> div[data-index=' + data.index + ']';\n                                var node = output.find(selector);\n                                if (node.html() !== wrapper.html()) {\n                                    node.replaceWith(wrapper);\n                                }\n                            } else {\n                                wrapper.appendTo(output);\n                            }\n                            wrapper.attr('data-index', data.index);\n                            data.finalize(wrapper);\n                        } else {\n                            var line = data.line;\n                            var div = document.createElement('div');\n                            div.style.width = '100%';\n                            div.innerHTML = line;\n                            if (data.newline) {\n                                div.className = 'cmd-end-line';\n                            }\n                            wrapper[0].appendChild(div);\n                        }\n                    }\n                    limit_lines();\n                    output.css('visibilty', '');\n                    fire_event('onFlush');\n\n                    if ((settings.scrollOnEcho && options.scroll) || bottom) {\n                        self.scroll_to_bottom();\n                    }\n                } catch (e1) {\n                    if (is_function(settings.exceptionHandler)) {\n                        try {\n                            settings.exceptionHandler.call(self, e1, 'TERMINAL (Flush)');\n                        } catch (e2) {\n                            settings.exceptionHandler = $.noop;\n                            alert_exception('[exceptionHandler]', e2);\n                        }\n                    } else {\n                        alert_exception('[Flush]', e1);\n                    }\n                } finally {\n                    output_buffer = [];\n                }\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Update the output line - line number can be negative\n            // -------------------------------------------------------------\n            update: function(line, value, options) {\n                when_ready(function ready() {\n                    if (line < 0) {\n                        line = lines.length + line; // yes +\n                    }\n                    if (!lines[line]) {\n                        self.error('Invalid line number ' + line);\n                    } else if (value === null) {\n                        lines.splice(line, 1);\n                        output.find('[data-index=' + line + ']').remove();\n                    } else {\n                        var ret = prepare_render(value, options);\n                        if (ret) {\n                            value = ret[0];\n                            options = ret[1];\n                        }\n                        lines[line][0] = value;\n                        if (options) {\n                            lines[line][1] = options;\n                        }\n                        process_line({\n                            value: value,\n                            index: line,\n                            options: options\n                        });\n                        self.flush({\n                            scroll: false,\n                            update: true\n                        });\n                    }\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: convenience method for removing selected line\n            // -------------------------------------------------------------\n            remove_line: function(line) {\n                return self.update(line, null);\n            },\n            // -------------------------------------------------------------\n            // :: return index of last line in case when you need to update\n            // :: after something is echo on the terminal\n            // -------------------------------------------------------------\n            last_index: function() {\n                return lines.length - 1;\n            },\n            // -------------------------------------------------------------\n            // :: Print data to the terminal output. It can have options\n            // :: * flush - indicate that arg should be send to DOM\n            // :: * raw - indicate if it should handle input as html\n            // :: * finalize - function call with container div\n            // :: * keepWords - inform how to wrap text\n            // :: * formatters - inform function if it should use formatters\n            // ::   on input string - good to prevent XSS when you want\n            // ::   advanced server side controling of terminal\n            // :: you can echo: promise, function, strings array or string\n            // -------------------------------------------------------------\n            echo: function(arg, options) {\n                var arg_defined = arguments.length > 0;\n                function echo(arg) {\n                    try {\n                        var locals = $.extend({\n                            flush: true,\n                            exec: true,\n                            raw: settings.raw,\n                            finalize: $.noop,\n                            unmount: $.noop,\n                            keepWords: false,\n                            invokeMethods: settings.invokeMethods,\n                            onClear: null,\n                            formatters: true,\n                            allowedAttributes: settings.allowedAttributes\n                        }, options || {});\n                        // finalize function is passed around and invoked\n                        // in terminal::flush after content is added to DOM\n                        (function(finalize) {\n                            locals.finalize = function(div) {\n                                if (locals.raw) {\n                                    div.addClass('raw');\n                                }\n                                try {\n                                    if (is_function(finalize)) {\n                                        finalize.call(self, div);\n                                    }\n                                    div.find('img').each(function() {\n                                        var self = $(this);\n                                        var img = new Image();\n                                        img.onerror = function() {\n                                            self.replaceWith(use_broken_image);\n                                        };\n                                        img.src = this.src;\n                                    });\n                                } catch (e) {\n                                    display_exception(e, 'USER:echo(finalize)');\n                                    finalize = null;\n                                }\n                            };\n                        })(locals.finalize);\n                        if (locals.flush) {\n                            // flush buffer if there was no flush after previous echo\n                            if (output_buffer.length) {\n                                self.flush();\n                            }\n                        }\n                        if (fire_event('onBeforeEcho', [arg]) === false) {\n                            return;\n                        }\n                        var value;\n                        if (typeof arg === 'function') {\n                            value = arg.bind(self);\n                        } else if (typeof arg === 'undefined') {\n                            if (arg_defined) {\n                                value = String(arg);\n                            } else {\n                                value = '';\n                            }\n                        } else {\n                            var ret = preprocess_value(arg);\n                            if (ret === false) {\n                                return self;\n                            }\n                            value = ret;\n                        }\n                        if (render(value, locals)) {\n                            return self;\n                        }\n                        process_line({\n                            value: value,\n                            options: locals,\n                            index: lines.length\n                        });\n                        // extended commands should be processed only\n                        // once in echo and not on redraw\n                        locals.exec = false;\n                        lines.push([value, locals]);\n                        if (locals.flush) {\n                            self.flush();\n                            fire_event('onAfterEcho', [arg]);\n                        }\n                    } catch (e) {\n                        // if echo throw exception we can't use error to\n                        // display that exception\n                        if (is_function(settings.exceptionHandler)) {\n                            settings.exceptionHandler.call(self, e, 'TERMINAL (echo)');\n                        } else {\n                            alert_exception('[Terminal.echo]', e);\n                        }\n                    }\n                }\n                if (arg !== undefined && is_function(arg.then)) {\n                    $.when(arg).done(echo).catch(make_label_error('Echo'));\n                } else {\n                    echo(arg);\n                }\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: echo red text\n            // -------------------------------------------------------------\n            error: function(message, options) {\n                options = $.extend({}, options, {raw: false, formatters: false});\n                function format(string) {\n                    if (typeof string !== 'string') {\n                        string = String(string);\n                    }\n                    // quick hack to fix trailing backslash\n                    var str = $.terminal.escape_brackets(string).\n                        replace(/\\\\$/, '&#92;').\n                        replace(url_re, ']$1[[;;;terminal-error]');\n                    return '[[;;;terminal-error]' + str + ']';\n                }\n                if (typeof message === 'function') {\n                    return self.echo(function() {\n                        return format(message.call(self));\n                    }, options);\n                }\n                if (message && message.then) {\n                    message.then(function(string) {\n                        self.echo(format(string));\n                    }).catch(make_label_error('Echo Error'));\n                    return self;\n                }\n                return self.echo(format(message), options);\n            },\n            // -------------------------------------------------------------\n            // :: Display Exception on terminal\n            // -------------------------------------------------------------\n            exception: function(e, label) {\n                var message = exception_message(e);\n                if (label) {\n                    message = '&#91;' + label + '&#93;: ' + message;\n                }\n                if (message) {\n                    self.error(message, {\n                        finalize: function(div) {\n                            div.addClass('terminal-exception terminal-message');\n                        },\n                        keepWords: true\n                    });\n                }\n                if (typeof e.fileName === 'string') {\n                    // display filename and line which throw exeption\n                    self.pause(settings.softPause);\n                    $.get(e.fileName, function(file) {\n                        var num = e.lineNumber - 1;\n                        var line = file.split('\\n')[num];\n                        if (line) {\n                            self.error('[' + e.lineNumber + ']: ' + line);\n                        }\n                        self.resume();\n                    }, 'text');\n                }\n                if (e.stack) {\n                    var stack = $.terminal.escape_brackets(e.stack);\n                    self.echo(stack.split(/\\n/g).map(function(trace) {\n                        // nested formatting will handle urls but that formatting\n                        // can be removed - this code was created before\n                        // that formatting existed (see commit ce01c3f5)\n                        return '[[;;;terminal-error]' +\n                            trace.replace(url_re, function(url) {\n                                return ']' + url + '[[;;;terminal-error]';\n                            }) + ']';\n                    }).join('\\n'), {\n                        finalize: function(div) {\n                            div.addClass('terminal-exception terminal-stack-trace');\n                        },\n                        formatters: false\n                    });\n                }\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Scroll Div that holds the terminal\n            // -------------------------------------------------------------\n            scroll: function(amount) {\n                var pos;\n                amount = Math.round(amount);\n                if (self.prop) { // work with jQuery > 1.6\n                    if (amount > self.prop('scrollTop') && amount > 0) {\n                        self.prop('scrollTop', 0);\n                    }\n                    pos = self.prop('scrollTop');\n                    self.scrollTop(pos + amount);\n                } else {\n                    if (amount > self.prop('scrollTop') && amount > 0) {\n                        self.prop('scrollTop', 0);\n                    }\n                    pos = self.prop('scrollTop');\n                    self.scrollTop(pos + amount);\n                }\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Exit all interpreters and logout. The function will throw\n            // :: exception if there is no login provided\n            // -------------------------------------------------------------\n            logout: function(local) {\n                if (in_login) {\n                    throw new Error(sprintf(strings().notWhileLogin, 'logout'));\n                }\n                when_ready(function ready() {\n                    if (local) {\n                        var login = logins.pop();\n                        self.set_token(undefined, true);\n                        self.login.apply(self, login);\n                    } else if (interpreters.size() === 1 && self.token()) {\n                        self.logout(true);\n                    } else {\n                        while (interpreters.size() > 1) {\n                            // pop will call global_logout that will call login\n                            // and size will be > 0; this is workaround the problem\n                            if (self.token()) {\n                                self.logout(true).pop().pop();\n                            } else {\n                                self.pop();\n                            }\n                        }\n                    }\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Function returns the token returned by callback function\n            // :: in login function. It does nothing (return undefined) if\n            // :: there is no login\n            // -------------------------------------------------------------\n            token: function(local) {\n                return storage.get(self.prefix_name(local) + '_token');\n            },\n            // -------------------------------------------------------------\n            // :: Function sets the token to the supplied value. This function\n            // :: works regardless of wherer settings.login is supplied\n            // -------------------------------------------------------------\n            set_token: function(token, local) {\n                var name = self.prefix_name(local) + '_token';\n                if (typeof token === 'undefined') {\n                    storage.remove(name);\n                } else {\n                    storage.set(name, token);\n                }\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Function get the token either set by the login method or\n            // :: by the set_token method.\n            // -------------------------------------------------------------\n            get_token: function(local) {\n                return self.token(local);\n            },\n            // -------------------------------------------------------------\n            // :: Function return Login name entered by the user\n            // -------------------------------------------------------------\n            login_name: function(local) {\n                return storage.get(self.prefix_name(local) + '_login');\n            },\n            // -------------------------------------------------------------\n            // :: Function returns the name of current interpreter\n            // -------------------------------------------------------------\n            name: function() {\n                return interpreters.top().name;\n            },\n            // -------------------------------------------------------------\n            // :: Function return prefix name for login/token\n            // -------------------------------------------------------------\n            prefix_name: function(local) {\n                var name = (settings.name ? settings.name + '_' : '') +\n                    terminal_id;\n                if (local && interpreters.size() > 1) {\n                    var local_name = interpreters.map(function(intrp) {\n                        return intrp.name || '';\n                    }).slice(1).join('_');\n                    if (local_name) {\n                        name += '_' + local_name;\n                    }\n                }\n                return name;\n            },\n            // -------------------------------------------------------------\n            // :: wrapper for common use case\n            // -------------------------------------------------------------\n            read: function(message, success, cancel) {\n                // return from read() should not pause terminal\n                force_awake = true;\n                var defer = jQuery.Deferred();\n                var read = false;\n                self.push(function(string) {\n                    read = true;\n                    defer.resolve(string);\n                    if (is_function(success)) {\n                        success(string);\n                    }\n                    self.pop();\n                    if (settings.history) {\n                        command_line.history().enable();\n                    }\n                }, {\n                    name: 'read',\n                    history: false,\n                    prompt: message || '',\n                    onExit: function() {\n                        if (!read) {\n                            defer.reject();\n                            if (is_function(cancel)) {\n                                cancel();\n                            }\n                        }\n                    }\n                });\n                if (settings.history) {\n                    command_line.history().disable();\n                }\n                return defer.promise();\n            },\n            // -------------------------------------------------------------\n            // :: Push a new interenter on the Stack\n            // -------------------------------------------------------------\n            push: function(interpreter, options) {\n                cmd_ready(function ready() {\n                    options = options || {};\n                    var defaults = {\n                        infiniteLogin: false\n                    };\n                    var push_settings = $.extend({}, defaults, options);\n                    if (!push_settings.name && prev_command) {\n                        // push is called in login\n                        push_settings.name = prev_command.name;\n                    }\n                    if (push_settings.prompt === undefined) {\n                        push_settings.prompt = (push_settings.name || '>') + ' ';\n                    }\n                    // names.push(options.name);\n                    var top = interpreters.top();\n                    if (top) {\n                        top.mask = command_line.mask();\n                    }\n                    var was_paused = paused;\n                    function init() {\n                        fire_event('onPush', [top, interpreters.top()]);\n                        prepare_top_interpreter();\n                    }\n                    // self.pause();\n                    make_interpreter(interpreter, options.login, function(ret) {\n                        // result is object with interpreter and completion properties\n                        interpreters.push($.extend({}, ret, push_settings));\n                        if (push_settings.completion === true) {\n                            if ($.isArray(ret.completion)) {\n                                interpreters.top().completion = ret.completion;\n                            } else if (!ret.completion) {\n                                interpreters.top().completion = false;\n                            }\n                        }\n                        if (push_settings.login) {\n                            var error;\n                            var type = get_type(push_settings.login);\n                            if (type === 'function') {\n                                error = push_settings.infiniteLogin ? $.noop : self.pop;\n                                self.login(\n                                    push_settings.login,\n                                    push_settings.infiniteLogin,\n                                    init,\n                                    error\n                                );\n                            } else if (get_type(interpreter) === 'string' &&\n                                       type === 'string' || type === 'boolean') {\n                                error = push_settings.infiniteLogin ? $.noop : self.pop;\n                                self.login(\n                                    make_json_rpc_login(\n                                        interpreter,\n                                        push_settings.login\n                                    ),\n                                    push_settings.infiniteLogin,\n                                    init,\n                                    error\n                                );\n                            }\n                        } else {\n                            init();\n                        }\n                        if (!was_paused && self.enabled()) {\n                            self.resume();\n                        }\n                    });\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Remove the last interpreter from the Stack\n            // -------------------------------------------------------------\n            pop: function(string, silent) {\n                if (string !== undefined) {\n                    echo_command(string);\n                }\n                var token = self.token(true);\n                var top;\n                if (interpreters.size() === 1) {\n                    top = interpreters.top();\n                    if (settings.login) {\n                        if (!silent) {\n                            fire_event('onPop', [top, null]);\n                        }\n                        global_logout();\n                        fire_event('onExit');\n                    } else {\n                        self.error(strings().canExitError);\n                    }\n                } else {\n                    if (token) {\n                        clear_loging_storage();\n                    }\n                    var current = interpreters.pop();\n                    top = interpreters.top();\n                    prepare_top_interpreter();\n                    // restore mask\n                    self.set_mask(top.mask);\n                    if (!silent) {\n                        fire_event('onPop', [current, top]);\n                    }\n                    // we check in case if you don't pop from password interpreter\n                    if (in_login && self.get_prompt() !== strings().login + ': ') {\n                        in_login = false;\n                    }\n                    if (is_function(current.onExit)) {\n                        try {\n                            current.onExit.call(self, self);\n                        } catch (e) {\n                            current.onExit = $.noop;\n                            display_exception(e, 'onExit');\n                        }\n                    }\n                }\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Change terminal option(s) at runtime\n            // -------------------------------------------------------------\n            option: function(object_or_name, value) {\n                if (typeof value === 'undefined') {\n                    if (typeof object_or_name === 'string') {\n                        return settings[object_or_name];\n                    } else if (typeof object_or_name === 'object') {\n                        $.each(object_or_name, function(key, value) {\n                            settings[key] = value;\n                        });\n                    }\n                } else {\n                    settings[object_or_name] = value;\n                    if (object_or_name.match(/^num(Chars|Rows)$/)) {\n                        redraw();\n                    }\n                }\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: invoke keydown shorcut\n            // -------------------------------------------------------------\n            invoke_key: function(shortcut) {\n                command_line.invoke_key(shortcut);\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: change terminal keymap at runtime\n            // -------------------------------------------------------------\n            keymap: function(keymap, fn) {\n                if (arguments.length === 0) {\n                    return command_line.keymap();\n                }\n                if (typeof fn === 'undefined') {\n                    if (typeof keymap === 'string') {\n                        return command_line.keymap(keymap);\n                    } else if ($.isPlainObject(keymap)) {\n                        // argument is an object\n                        keymap = $.omap(keymap || {}, function(key, fn) {\n                            if (!new_keymap[key]) {\n                                return fn.bind(self);\n                            }\n                            return function(e, original) {\n                                // new keymap function will get default as 2nd argument\n                                return fn.call(self, e, function() {\n                                    return new_keymap[key](e, original);\n                                });\n                            };\n                        });\n                        command_line.keymap(keymap);\n                    }\n                } else if (typeof fn === 'function') {\n                    var key = keymap;\n                    if (!new_keymap[key]) {\n                        command_line.keymap(key, fn.bind(self));\n                    } else {\n                        command_line.keymap(key, function(e, original) {\n                            return fn.call(self, e, function() {\n                                return new_keymap[key](e, original);\n                            });\n                        });\n                    }\n                }\n            },\n            // -------------------------------------------------------------\n            // :: Return how deep you are in nested interpreters\n            // -------------------------------------------------------------\n            level: function() {\n                return interpreters.size();\n            },\n            // -------------------------------------------------------------\n            // :: Reinitialize the terminal\n            // -------------------------------------------------------------\n            reset: function() {\n                when_ready(function ready() {\n                    self.clear();\n                    while (interpreters.size() > 1) {\n                        interpreters.pop();\n                    }\n                    initialize();\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Remove all local storage left by terminal, it will not\n            // :: logout you until you refresh the browser\n            // -------------------------------------------------------------\n            purge: function() {\n                when_ready(function ready() {\n                    var prefix = self.prefix_name() + '_';\n                    var names = storage.get(prefix + 'interpreters');\n                    if (names) {\n                        $.each(JSON.parse(names), function(_, name) {\n                            storage.remove(name + '_commands');\n                            storage.remove(name + '_token');\n                            storage.remove(name + '_login');\n                        });\n                    }\n                    command_line.purge();\n                    storage.remove(prefix + 'interpreters');\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: Remove all events and DOM nodes left by terminal, it will\n            // :: not purge the terminal so you will have the same state\n            // :: when you refresh the browser\n            // -------------------------------------------------------------\n            destroy: function() {\n                when_ready(function ready() {\n                    command_line.destroy().remove();\n                    self.resizer('unbind');\n                    font_resizer.resizer('unbind').remove();\n                    $(document).unbind('.terminal_' + self.id());\n                    $(window).unbind('.terminal_' + self.id());\n                    self.unbind('click wheel mousewheel mousedown mouseup');\n                    self.removeData('terminal').removeClass('terminal').\n                        unbind('.terminal');\n                    if (settings.width) {\n                        self.css('width', '');\n                    }\n                    if (settings.height) {\n                        self.css('height', '');\n                    }\n                    $(window).off('blur', blur_terminal).\n                        off('focus', focus_terminal);\n                    self.find('.terminal-fill, .terminal-font').remove();\n                    self.stopTime();\n                    terminals.remove(terminal_id);\n                    if (visibility_observer) {\n                        if (visibility_observer.unobserve) {\n                            visibility_observer.unobserve(self[0]);\n                        } else {\n                            clearInterval(visibility_observer);\n                        }\n                    }\n                    var scroll_marker = self.find('.terminal-scroll-marker');\n                    if (is_bottom_observer) {\n                        visibility_observer.unobserve(scroll_marker[0]);\n                    }\n                    scroll_marker.remove();\n                    if (mutation_observer) {\n                        mutation_observer.disconnect();\n                    }\n                    if (!terminals.length()) {\n                        $(window).off('hashchange');\n                    }\n                    output.remove();\n                    wrapper.remove();\n                    defunct = true;\n                });\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: ref: https://stackoverflow.com/a/18927969/387194\n            // -------------------------------------------------------------\n            scroll_to: function(elem) {\n                var scroll = self.scrollTop() - self.offset().top + $(elem).offset().top;\n                self.scrollTop(scroll);\n                return self;\n            },\n            // -------------------------------------------------------------\n            scroll_to_bottom: function() {\n                var scrollHeight;\n                if (self.prop) {\n                    scrollHeight = self.prop('scrollHeight');\n                } else {\n                    scrollHeight = self.attr('scrollHeight');\n                }\n                self.scrollTop(scrollHeight);\n                return self;\n            },\n            // -------------------------------------------------------------\n            // :: return true if terminal div or body is at the bottom\n            // :: is use scrollBottomOffset option as margin for the check\n            // -------------------------------------------------------------\n            is_bottom: function() {\n                if (settings.scrollBottomOffset === -1) {\n                    return false;\n                } else if (typeof is_bottom_detected === 'boolean') {\n                    return is_bottom_detected;\n                } else {\n                    var scroll_height, scroll_top, height;\n                    scroll_height = self[0].scrollHeight;\n                    scroll_top = self[0].scrollTop;\n                    height = self[0].offsetHeight;\n                    var limit = scroll_height - settings.scrollBottomOffset;\n                    return scroll_top + height > limit;\n                }\n            }\n        }, function(name, fun) {\n            // wrap all functions and display execptions\n            return function() {\n                if (defunct) {\n                    if (!settings.exceptionHandler) {\n                        throw new $.terminal.Exception(strings().defunctTerminal);\n                    }\n                }\n                try {\n                    return fun.apply(self, [].slice.apply(arguments));\n                } catch (e) {\n                    // exec catch by command (resume call exec)\n                    if (name !== 'exec' && name !== 'resume') {\n                        display_exception(e, e.type || 'TERMINAL', true);\n                    }\n                    if (!settings.exceptionHandler) {\n                        throw e;\n                    }\n                }\n            };\n        }));\n        // -----------------------------------------------------------------\n        // :: INIT CODE\n        // -----------------------------------------------------------------\n        if (self.length === 0) {\n            var msg = sprintf(strings().invalidSelector);\n            throw new $.terminal.Exception(msg);\n        }\n        self.data('terminal', self);\n        // var names = []; // stack if interpreter names\n        var prev_command; // used for name on the terminal if not defined\n        var prev_exec_cmd;\n        var tab_count = 0; // for tab completion\n        var output; // .terminal-output jquery object\n        var terminal_id = terminals.length();\n        var force_awake = false; // flag used to don't pause when user return read() call\n        var num_chars; // numer of chars in line\n        var num_rows; // number of lines that fit without scrollbar\n        var command; // for tab completion\n        var logins = new Stack(); // stack of logins\n        var command_queue = new DelayQueue();\n        var init_queue = new DelayQueue();\n        var when_ready = ready(init_queue);\n        var cmd_ready = ready(command_queue);\n        var is_bottom_detected;\n        var is_bottom_observer;\n        var in_login = false;// some Methods should not be called when login\n        // TODO: Try to use mutex like counter for pause/resume\n        var onPause = $.noop;// used to indicate that user call pause onInit\n        var old_width, old_height;\n        var delayed_commands = []; // used when exec commands while paused\n        var settings = $.extend(\n            {},\n            $.terminal.defaults,\n            {\n                name: self.selector,\n                exit: !!(options && options.login || !options)\n            },\n            options || {}\n        );\n        if (typeof settings.width === 'number') {\n            self.width(settings.width);\n        }\n        if (typeof settings.height === 'number') {\n            self.height(settings.height);\n        }\n        var char_size = get_char_size(self);\n        // so it's the same as in TypeScript definition for options\n        delete settings.formatters;\n        // used to throw error when calling methods on destroyed terminal\n        var defunct = false;\n        var lines = [];\n        var storage = new StorageHelper(settings.memory);\n        var enabled = settings.enabled;\n        var frozen = false;\n        var paused = false;\n        var autologin = true; // set to false if onBeforeLogin return false\n        var interpreters;\n        var command_line;\n        var old_enabled;\n        var visibility_observer;\n        var mutation_observer;\n        // backward compatibility\n        if (settings.ignoreSystemDescribe === true) {\n            settings.describe = false;\n        }\n        // register ajaxSend for cancel requests on CTRL+D\n        $(document).bind('ajaxSend.terminal_' + self.id(), function(e, xhr) {\n            requests.push(xhr);\n        });\n        var wrapper = $('<div class=\"terminal-wrapper\"/>').appendTo(self);\n        $(broken_image).hide().appendTo(wrapper);\n        var font_resizer = $('<div class=\"terminal-font\">&nbsp;</div>').appendTo(self);\n        var fill = $('<div class=\"terminal-fill\"/>').appendTo(self);\n        output = $('<div>').addClass('terminal-output').attr('role', 'log')\n            .appendTo(wrapper);\n        self.addClass('terminal');\n        // before login event\n        if (settings.login && fire_event('onBeforeLogin') === false) {\n            autologin = false;\n        }\n        // create json-rpc authentication function\n        var base_interpreter;\n        if (typeof init_interpreter === 'string') {\n            base_interpreter = init_interpreter;\n        } else if (is_array(init_interpreter)) {\n            // first JSON-RPC\n            for (var i = 0, len = init_interpreter.length; i < len; ++i) {\n                if (typeof init_interpreter[i] === 'string') {\n                    base_interpreter = init_interpreter[i];\n                    break;\n                }\n            }\n        }\n        var global_login_fn;\n        if (is_function(settings.login)) {\n            global_login_fn = settings.login;\n        } else if (base_interpreter &&\n            (typeof settings.login === 'string' || settings.login === true)) {\n            global_login_fn = make_json_rpc_login(base_interpreter, settings.login);\n        }\n        terminals.append(self);\n        function focus_terminal() {\n            if (old_enabled) {\n                self.focus();\n            }\n        }\n        // -------------------------------------------------------------------------------\n        function blur_terminal() {\n            old_enabled = enabled;\n            self.disable().find('.cmd textarea').trigger('blur', [true]);\n        }\n        // -------------------------------------------------------------------------------\n        function stringify_value(value) {\n            if (is_function(value)) {\n                value = value();\n            }\n            if (get_type(value) !== 'string') {\n                if (is_function(settings.parseObject)) {\n                    var ret = settings.parseObject(value);\n                    if (get_type(ret) === 'string') {\n                        value = ret;\n                    }\n                } else if (is_array(value)) {\n                    value = $.terminal.columns(value, self.cols(), settings.tabs);\n                } else {\n                    value = String(value);\n                }\n            }\n            return value;\n        }\n        // -------------------------------------------------------------------------------\n        function context_callback_proxy(fn) {\n            if (fn.proxy) {\n                return fn;\n            }\n            var wrapper = function(callback) {\n                return fn.call(self, callback, self);\n            };\n            wrapper.proxy = true;\n            return wrapper;\n        }\n        // -------------------------------------------------------------------------------\n        // paste event is not testable in node\n        // istanbul ignore next\n        function paste_event(e) {\n            e = e.originalEvent;\n            // we don't care about browser that don't support clipboard data\n            // those browser simple will not have this feature normal paste\n            // is cross-browser and it's handled by cmd plugin\n            function is_type(item, type) {\n                return item.type.indexOf(type) !== -1;\n            }\n            function echo_image(image) {\n                self.echo('<img src=\"' + image + '\"/>', {raw: true});\n            }\n            function data_uri(blob) {\n                var URL = window.URL || window.webkitURL;\n                return URL.createObjectURL(blob);\n            }\n            function echo(object, ignoreEvents) {\n                if (!ignoreEvents && is_function(settings.onPaste)) {\n                    var event = {\n                        target: self\n                    };\n                    if (typeof object === 'string') {\n                        event['text'] = object;\n                    } else if (object instanceof Blob) {\n                        event['image'] = data_uri(object);\n                    }\n                    var ret = fire_event('onPaste', [event]);\n                    if (ret) {\n                        if (is_function(ret.then || ret.done)) {\n                            return (ret.then || ret.done).call(ret, function(ret) {\n                                echo(ret, true);\n                            });\n                        } else {\n                            echo(ret, true);\n                        }\n                    } else {\n                        echo(event.image || event.text, true);\n                    }\n                } else if (object instanceof Blob) {\n                    echo_image(data_uri(object));\n                } else if (typeof object === 'string') {\n                    if (object.match(/^(data:|blob:)/)) {\n                        echo_image(object);\n                    } else {\n                        self.insert(object);\n                    }\n                }\n            }\n            if (e.clipboardData) {\n                if (self.enabled()) {\n                    var items = e.clipboardData.items;\n                    if (items) {\n                        for (var i = 0; i < items.length; i++) {\n                            if (is_type(items[i], 'image') && settings.pasteImage) {\n                                var blob = items[i].getAsFile();\n                                echo(blob);\n                            } else if (is_type(items[i], 'text/plain')) {\n                                items[i].getAsString(echo);\n                            }\n                        }\n                    } else if (e.clipboardData.getData) {\n                        var text = e.clipboardData.getData('text/plain');\n                        echo(text);\n                    }\n                    return false;\n                }\n            }\n        }\n        $(document).on('paste.terminal_' + self.id(), paste_event);\n        var new_keymap = $.extend(\n            {},\n            keymap,\n            $.omap(settings.keymap || {}, function(key, fn) {\n                if (!keymap[key]) {\n                    return fn.bind(self);\n                }\n                return function(e, original) {\n                    // new keymap function will get default as 2nd argument\n                    return fn.call(self, e, function() {\n                        return keymap[key](e, original);\n                    });\n                };\n            })\n        );\n        make_interpreter(init_interpreter, settings.login, function(interpreter) {\n            if (settings.completion && typeof settings.completion !== 'boolean' ||\n                !settings.completion) {\n                // overwrite interpreter completion by global setting #224\n                // we use string to indicate that it need to be taken from settings\n                // so we are able to change it using option API method\n                interpreter.completion = 'settings';\n            }\n            var prompt = settings.prompt;\n            if (is_function(prompt)) {\n                prompt = context_callback_proxy(prompt);\n            }\n            interpreters = new Stack($.extend({}, settings.extra, {\n                name: settings.name,\n                prompt: prompt,\n                keypress: settings.keypress,\n                keydown: settings.keydown,\n                resize: settings.onResize,\n                greetings: settings.greetings,\n                mousewheel: settings.mousewheel,\n                history: settings.history,\n                keymap: new_keymap\n            }, interpreter));\n            // CREATE COMMAND LINE\n            command_line = $('<div/>').appendTo(wrapper).cmd({\n                tabindex: settings.tabindex,\n                mobileDelete: settings.mobileDelete,\n                mobileIngoreAutoSpace: settings.mobileIngoreAutoSpace,\n                prompt: global_login_fn ? false : prompt,\n                history: settings.memory ? 'memory' : settings.history,\n                historyFilter: settings.historyFilter,\n                historySize: settings.historySize,\n                caseSensitiveSearch: settings.caseSensitiveSearch,\n                onPaste: settings.onPaste,\n                width: '100%',\n                enabled: false,\n                char_width: char_size.width,\n                keydown: key_down,\n                keymap: new_keymap,\n                clickTimeout: settings.clickTimeout,\n                holdTimeout: settings.holdTimeout,\n                holdRepeatTimeout: settings.holdRepeatTimeout,\n                repeatTimeoutKeys: settings.repeatTimeoutKeys,\n                allowedAttributes: settings.allowedAttributes,\n                keypress: key_press,\n                tabs: settings.tabs,\n                onPositionChange: function() {\n                    var args = [].slice.call(arguments);\n                    make_cursor_visible();\n                    fire_event('onPositionChange', args);\n                },\n                onCommandChange: function(command) {\n                    // resize is not triggered when insert called just after init\n                    //  and scrollbar appear\n                    if (old_width !== fill.width()) {\n                        // resizer handler will update old_width\n                        self.resizer();\n                    }\n                    fire_event('onCommandChange', [command]);\n                    make_cursor_visible();\n                },\n                commands: commands\n            });\n            function disable(e) {\n                e = e.originalEvent;\n                if (e) {\n                    // e.terget is body when click outside of context menu to close it\n                    // even if you click on terminal\n                    var node = document.elementFromPoint(e.clientX, e.clientY);\n                    if (!$(node).closest('.terminal').length && self.enabled()) {\n                        // we only need to disable when click outside of terminal\n                        // click on other terminal is handled by focus event\n                        self.disable();\n                    }\n                }\n            }\n            self.oneTime(100, function() {\n                $(document).bind('click.terminal_' + self.id(), disable).\n                    bind('contextmenu.terminal_' + self.id(), disable);\n            });\n            var $win = $(window);\n            // cordova application, if keyboard was open and we resume, it will be\n            // closed so we need to disable terminal so you can enable it with tap\n            document.addEventListener(\"resume\", function() {\n                self.disable();\n            });\n            // istanbul ignore next\n            if (is_mobile) {\n                self.click(function() {\n                    if (!frozen) {\n                        if (!self.enabled()) {\n                            self.focus();\n                            command_line.enable();\n                        } else {\n                            self.disable();\n                        }\n                    }\n                });\n            } else {\n                // work weird on mobile\n                $win.on('focus.terminal_' + self.id(), focus_terminal).\n                    on('blur.terminal_' + self.id(), blur_terminal);\n                // detect mouse drag\n                (function() {\n                    var count = 0;\n                    var $target;\n                    var name = 'click_' + self.id();\n                    var textarea = self.find('.cmd textarea');\n                    function click() {\n                        if ($target.is('.terminal') ||\n                            $target.is('.terminal-wrapper')) {\n                            var len = self.get_command().length;\n                            self.set_position(len);\n                        } else if ($target.closest('.cmd-prompt').length) {\n                            self.set_position(0);\n                        }\n                        if (!textarea.is(':focus')) {\n                            textarea.focus();\n                        }\n                        reset();\n                    }\n                    function reset() {\n                        count = 0;\n                        $target = null;\n                    }\n                    var ignore_elements = '.terminal-output textarea,' +\n                        '.terminal-output input';\n                    self.mousedown(function(e) {\n                        if (!scrollbar_event(e, fill)) {\n                            $target = $(e.target);\n                        }\n                    }).mouseup(function() {\n                        if ($target && $target.closest(ignore_elements).length) {\n                            if (enabled) {\n                                self.disable();\n                            }\n                        } else if (get_selected_html() === '' && $target) {\n                            if (++count === 1) {\n                                if (!frozen) {\n                                    if (!enabled) {\n                                        self.focus();\n                                    } else {\n                                        var timeout = settings.clickTimeout;\n                                        self.oneTime(timeout, name, click);\n                                        return;\n                                    }\n                                }\n                            } else {\n                                self.stopTime(name);\n                            }\n                        }\n                        reset();\n                    }).dblclick(function() {\n                        reset();\n                        self.stopTime(name);\n                    });\n                })();\n                (function() {\n                    var clip = self.find('.cmd textarea');\n                    function is_context_event(e) {\n                        return e.type === 'mousedown' && e.buttons === 2 ||\n                            e.type === 'contextmenu';\n                    }\n                    self.on('contextmenu.terminal mousedown.terminal', function(e) {\n                        if (get_selected_html() === '' && is_context_event(e)) {\n                            if (!$(e.target).is('img,value,audio,object,canvas,a')) {\n                                if (!self.enabled()) {\n                                    self.enable();\n                                }\n                                var offset = command_line.offset();\n                                clip.css({\n                                    left: e.pageX - offset.left - 20,\n                                    top: e.pageY - offset.top - 20,\n                                    width: '5em',\n                                    height: '4em'\n                                });\n                                if (!clip.is(':focus')) {\n                                    clip.focus();\n                                }\n                                self.stopTime('textarea');\n                                self.oneTime(100, 'textarea', function() {\n                                    var props = {\n                                        left: '',\n                                        top: '',\n                                        width: '',\n                                        height: ''\n                                    };\n                                    if (!is_css_variables_supported) {\n                                        var in_line = self.find('.cmd .cmd-cursor-line')\n                                            .prevUntil('.cmd-prompt').length;\n                                        props.top = in_line * 14 + 'px';\n                                    }\n                                    clip.css(props);\n                                });\n                                self.stopTime('selection');\n                                self.everyTime(20, 'selection', function() {\n                                    if (clip[0].selection !== clip[0].value) {\n                                        if (get_textarea_selection(clip[0])) {\n                                            clear_textarea_selection(clip[0]);\n                                            select(\n                                                self.find('.terminal-output')[0],\n                                                self.find('.cmd div:last-of-type')[0]\n                                            );\n                                            self.stopTime('selection');\n                                        }\n                                    }\n                                });\n                            }\n                        }\n                    });\n                })();\n            }\n            self.on('click', 'a', function(e) {\n                var $this = $(this);\n                if ($this.closest('.terminal-exception').length) {\n                    var href = $this.attr('href');\n                    if (href.match(/:[0-9]+$/)) { // display line if specified\n                        e.preventDefault();\n                        print_line(href, self.cols());\n                    }\n                }\n                // refocus because links have tabindex in case where user want\n                // tab change urls, we can ignore this function on click\n                if (enabled) {\n                    self.find('.cmd textarea').focus();\n                }\n            });\n            function calculate_char_size() {\n                var width = char_size.width;\n                char_size = get_char_size(self);\n                if (width !== char_size.width) {\n                    command_line.option('char_width', char_size.width).refresh();\n                }\n            }\n            resize();\n            function resize() {\n                if (self.is(':visible')) {\n                    var width = fill.width();\n                    var height = fill.height();\n                    // prevent too many calculations in IE\n                    if (old_height !== height || old_width !== width) {\n                        self.resize();\n                    }\n                    old_height = height;\n                    old_width = width;\n                }\n            }\n            function create_resizers() {\n                var options = {\n                    prefix: 'terminal-'\n                };\n                self.resizer('unbind').resizer(resize, options);\n                font_resizer.resizer('unbind').resizer(function() {\n                    calculate_char_size();\n                    self.resize();\n                }, options);\n            }\n            function bottom_detect(intersections) {\n                is_bottom_detected = intersections[0].intersectionRatio === 1;\n            }\n            function create_bottom_detect() {\n                if (window.IntersectionObserver) {\n                    var top = $('<div class=\"terminal-scroll-marker\"/>').appendTo(self);\n                    var marker = top;\n                    if (settings.scrollBottomOffset !== -1) {\n                        marker = $('<div/>').css({\n                            height: settings.scrollBottomOffset\n                        }).appendTo(top);\n                    }\n                    is_bottom_observer = new IntersectionObserver(bottom_detect, {\n                        root: self[0]\n                    });\n                    is_bottom_observer.observe(marker[0]);\n                }\n            }\n            // this observer can be added imedietely even if terminal is not in the DOM\n            // because both of the elements (root and target) are in same fragment\n            create_bottom_detect();\n            if (self.is(':visible')) {\n                create_resizers();\n            }\n            function observe_visibility() {\n                if (visibility_observer) {\n                    if (visibility_observer.unobserve) {\n                        visibility_observer.unobserve(self[0]);\n                    } else {\n                        clearInterval(visibility_observer);\n                    }\n                }\n                var was_enabled = self.enabled();\n                var visible = self.is(':visible');\n                if (was_enabled && !visible) {\n                    self.disable();\n                }\n                if (visible) {\n                    create_resizers();\n                } else {\n                    // hide terminal content until it's resized (and num chars calculated)\n                    wrapper.css('visibility', 'hidden');\n                }\n                function visibility_checker() {\n                    if (self.is(':visible') && !visible) {\n                        visible = true;\n                        create_resizers();\n                        calculate_char_size();\n                        resize();\n                        if (was_enabled) {\n                            self.enable();\n                        }\n                        wrapper.css('visibility', '');\n                    } else if (visible && !self.is(':visible')) {\n                        visible = false;\n                        was_enabled = $.terminal.active() === self && self.enabled();\n                        self.disable();\n                        wrapper.css('visibility', 'hidden');\n                    }\n                }\n                if (window.IntersectionObserver && self.css('position') !== 'fixed') {\n                    visibility_observer = new IntersectionObserver(visibility_checker, {\n                        root: null\n                    });\n                    visibility_observer.observe(self[0]);\n                } else {\n                    visibility_observer = setInterval(visibility_checker, 100);\n                }\n            }\n            var in_dom = !!self.closest('body').length;\n            var MutationObsrv = window.MutationObserver || window.WebKitMutationObserver;\n            if (MutationObsrv) {\n                mutation_observer = new MutationObsrv(function() {\n                    if (self.closest('body').length) {\n                        if (!in_dom) {\n                            self.scroll_to_bottom();\n                            // this observer need to be added when terminal is in the DOM\n                            observe_visibility();\n                            resize();\n                        }\n                        in_dom = true;\n                    } else if (in_dom) {\n                        in_dom = false;\n                    }\n                });\n                mutation_observer.observe(document.body, {childList: true});\n            }\n            if (in_dom) {\n                // check if element is in the DOM if not running IntersectionObserver\n                // don't make sense\n                observe_visibility();\n            }\n            command_queue.resolve();\n            // touch devices need touch event to get virtual keyboard\n            if (enabled && self.is(':visible') && !is_mobile) {\n                self.focus(undefined, true);\n            } else {\n                self.disable();\n            }\n            // -------------------------------------------------------------\n            // Run Login\n            if (is_function(global_login_fn)) {\n                self.login(global_login_fn, true, initialize);\n            } else {\n                initialize();\n            }\n            // -------------------------------------------------------------\n            // :: helper\n            function exec_spec(spec) {\n                var terminal = terminals.get()[spec[0]];\n                // execute if belong to this terminal\n                if (terminal && terminal_id === terminal.id()) {\n                    if (!spec[2]) {\n                        defer.resolve();\n                        return defer.promise();\n                    } else if (paused) {\n                        var defer = $.Deferred();\n                        resume_callbacks.push(function() {\n                            return terminal.exec(spec[2]).done(function() {\n                                terminal.save_state(spec[2], true, spec[1]);\n                                defer.resolve();\n                            });\n                        });\n                        return defer.promise();\n                    } else {\n                        return terminal.exec(spec[2]).done(function() {\n                            terminal.save_state(spec[2], true, spec[1]);\n                        });\n                    }\n                }\n            }\n            // exec from hash called in each terminal instance\n            if (settings.execHash) {\n                if (location.hash) {\n                    // wait until login is initialized\n                    setTimeout(function() {\n                        try {\n                            var hash = location.hash.replace(/^#/, '');\n                            // yes no var - local inside terminal\n                            hash_commands = JSON.parse(decodeURIComponent(hash));\n                            var i = 0;\n                            (function recur() {\n                                var spec = hash_commands[i++];\n                                if (spec) {\n                                    exec_spec(spec).done(recur);\n                                } else {\n                                    change_hash = true;\n                                }\n                            })();// */\n                        } catch (e) {\n                            // invalid json - ignore\n                        }\n                    });\n                } else {\n                    change_hash = true;\n                }\n            } else {\n                change_hash = true; // if enabled later\n            }\n            // change_hash = true; // exec can now change hash\n            // -------------------------------------------------------------\n            /* istanbul ignore next */\n            (function() {\n                var shift = false;\n                $(document).bind('keydown.terminal_' + self.id(), function(e) {\n                    if (e.shiftKey) {\n                        shift = true;\n                    }\n                }).bind('keyup.terminal_' + self.id(), function(e) {\n                    // in Google Chromium/Linux shiftKey is false\n                    if (e.shiftKey || e.which === 16) {\n                        shift = false;\n                    }\n                });\n                // this could work without calling scroll on wheel event but we\n                // need it for cases where you have mouse wheel work differently\n                // like with less command that scroll text\n                function mousewheel(event, delta) {\n                    if (!shift) {\n                        var interpreter = interpreters.top();\n                        var ret;\n                        if (is_function(interpreter.mousewheel)) {\n                            ret = interpreter.mousewheel(event, delta, self);\n                        } else if (is_function(settings.mousewheel)) {\n                            ret = settings.mousewheel(event, delta, self);\n                        }\n                        if (ret === true) {\n                            return;\n                        }\n                        if ((have_scrollbar() || ret === false) && !event.ctrlKey) {\n                            event.stopPropagation();\n                            event.preventDefault();\n                        }\n                        if (ret === false) {\n                            return false;\n                        }\n                        if (delta > 0) {\n                            self.scroll(-40);\n                        } else {\n                            self.scroll(40);\n                        }\n                    }\n                }\n                if ($.event.special.mousewheel) {\n                    // we keep mousewheel plugin just in case\n                    self.on('mousewheel', mousewheel);\n                } else {\n                    // detection take from:\n                    // https://developer.mozilla.org/en-US/docs/Web/Events/wheel\n                    var event;\n                    var div = document.createElement(\"div\");\n                    if (\"onwheel\" in div) {\n                        event = \"wheel\"; // Modern browsers support \"wheel\"\n                    } else if (document.onmousewheel !== undefined) {\n                        // Webkit and IE support at least \"mousewheel\"\n                        event = \"mousewheel\";\n                    } else {\n                        // let's assume that remaining browsers are older Firefox\n                        event = \"DOMMouseScroll\";\n                    }\n                    div = null;\n                    self.on(event, function(e) {\n                        var delta;\n                        if (event === 'mousewheel') {\n                            delta = - 1 / 40 * e.originalEvent.wheelDelta;\n                        } else {\n                            delta = e.originalEvent.deltaY || e.originalEvent.detail;\n                        }\n                        mousewheel(e, -delta);\n                    });\n                }\n            })();\n        }); // make_interpreter\n        return self;\n    }; // terminal plugin\n});\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LnRlcm1pbmFsL2pzL2pxdWVyeS50ZXJtaW5hbC5qcz8wOWJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsK0JBQStCO0FBQy9CO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELDZEQUE2RDtBQUM3RCxzREFBc0Q7QUFDdEQsaUdBQWlHO0FBQ2pHLG1HQUFtRztBQUNuRyxvREFBb0Q7QUFDcEQscUdBQXFHO0FBQ3JHLDhDQUE4QztBQUM5QyxxREFBcUQ7QUFDckQsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxFQUFFO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDBCQUEwQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxHQUFHLEdBQUc7QUFDeEQsbURBQW1ELElBQUksSUFBSSxJQUFJLE1BQU0sS0FBSyxNQUFNO0FBQ2hGLDRDQUE0QyxHQUFHLEtBQUssR0FBRyxRQUFRLFdBQVc7QUFDMUUsa0RBQWtELEdBQUcsS0FBSyxHQUFHLFFBQVEsV0FBVztBQUNoRixxREFBcUQsR0FBRyxLQUFLLEdBQUcsUUFBUSxXQUFXO0FBQ25GLGtEQUFrRCxHQUFHLEdBQUc7QUFDeEQsbURBQW1ELEdBQUcsR0FBRztBQUN6RCwrQ0FBK0MsR0FBRyxHQUFHO0FBQ3JELHdDQUF3QyxNQUFNLEdBQUc7QUFDakQsb0NBQW9DLEVBQUUsVUFBVSxFQUFFO0FBQ2xELDZDQUE2QyxHQUFHLFVBQVU7QUFDMUQsOERBQThELEdBQUcsVUFBVTtBQUMzRSx1Q0FBdUMsd0JBQXdCLDZCQUE2QixJQUFJLFFBQVEsSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLGlDQUFpQyxHQUFHO0FBQ3hLLGlEQUFpRCxHQUFHLFVBQVU7QUFDOUQsNkNBQTZDLHdCQUF3Qiw2QkFBNkIsSUFBSSxRQUFRLElBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSxpQ0FBaUMsR0FBRztBQUM5SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGtCQUFrQjtBQUMxRSxxQ0FBcUMsd0JBQXdCO0FBQzdELHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHlDQUF5QyxLQUFLO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLElBQUk7QUFDakQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxlQUFlO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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cUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFDQUFxQyw0Q0FBNEM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0RBQWdEO0FBQ3JGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQ7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiwwREFBMEQsZ0JBQWdCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakMseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsbUNBQW1DO0FBQ25DO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTLEVBQUU7QUFDWDtBQUNBLE1BQU07QUFDTixDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2pxdWVyeS50ZXJtaW5hbC9qcy9qcXVlcnkudGVybWluYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipAbGljZW5zZVxuICogICAgICAgX18gX19fX18gICAgICAgICAgICAgICAgICAgICBfX19fX19fXyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fXG4gKiAgICAgIC8gLy8gXyAgL19fIF9fIF9fX19fIF9fXyBfXyBfL19fICBfX18vX18gX19fIF9fX19fXyBfXyBfXyAgX18gX19fICAvIC9cbiAqICBfXyAvIC8vIC8vIC8vIC8vIC8vIF8gIC8vIF8vLyAvLyAvIC8gLy8gXyAgLy8gXy8vICAgICAvLyAvLyAgXFwvIC8vIF8gXFwvIC9cbiAqIC8gIC8gLy8gLy8gLy8gLy8gLy8gX19fLy8gLyAvIC8vIC8gLyAvLyBfX18vLyAvIC8gLyAvIC8vIC8vIC9cXCAgLy8gLy8gLyAvX19cbiAqIFxcX19fLy9fX19fIFxcXFxfX18vL19fX18vL18vIF9cXF8gIC8gL18vL19fX18vL18vIC9fLyAvXy8vXy8vXy8gL18vIFxcX19cXF9cXF9fXy9cbiAqICAgICAgICAgICBcXC8gICAgICAgICAgICAgIC9fX19fLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24gMi4xMi4wXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgalF1ZXJ5IFRlcm1pbmFsLiBodHRwczovL3Rlcm1pbmFsLmpjdWJpYy5wbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE5IEpha3ViIFQuIEphbmtpZXdpY3ogPGh0dHBzOi8vamN1YmljLnBsL20+ZVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKlxuICogQ29udGFpbnM6XG4gKlxuICogU3RvcmFnZSBwbHVnaW4gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBtb2RpZmllZCB0byB3b3JrIGZyb20gRGF0YSBVUklzIHRoYXQgYmxvY2sgc3RvcmFnZSBhbmQgY29va2llcyBpbiBDaHJvbWVcbiAqIENvcHlyaWdodCAoYykgMjAxMCBEYXZlIFNjaGluZGxlclxuICpcbiAqIGpRdWVyeSBUaW1lcnMgbGljZW5jZWQgd2l0aCB0aGUgV1RGUExcbiAqIDxodHRwOi8vanF1ZXJ5Lm9mZnB1dC5jYS90aW1lcnMvPlxuICpcbiAqIENyb3NzLUJyb3dzZXIgU3BsaXQgMS4xLjFcbiAqIENvcHlyaWdodCAyMDA3LTIwMTIgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+XG4gKiBBdmFpbGFibGUgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKlxuICogalF1ZXJ5IENhcmV0XG4gKiBDb3B5cmlnaHQgKGMpIDIwMDksIEdpZGVvbiBTaXJlbGluZ1xuICogMyBjbGF1c2UgQlNEIExpY2Vuc2VcbiAqXG4gKiBzcHJpbnRmLmpzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDctMjAxMyBBbGV4YW5kcnUgTWFyYXN0ZWFudSA8aGVsbG8gYXQgYWxleGVpIGRvdCBybz5cbiAqIGxpY2Vuc2VkIHVuZGVyIDMgY2xhdXNlIEJTRCBsaWNlbnNlXG4gKlxuICogZGVib3VuY2UgZnVuY3Rpb24gZnJvbSBMb2Rhc2hcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanMuZm91bmRhdGlvbi8+XG4gKiBUaGUgTUlUIExpY2Vuc2VcbiAqXG4gKiBlbW9qaSByZWdleCB2Ny4wLjEgYnkgTWF0aGlhcyBCeW5lbnNcbiAqIE1JVCBsaWNlbnNlXG4gKlxuICogYnJva2VuIGltYWdlIGJ5IFNvcGhpYSBCYWkgZnJvbSB0aGUgTm91biBQcm9qZWN0IChDQy1CWSlcbiAqXG4gKiBEYXRlOiBXZWQsIDAxIEphbiAyMDIwIDE3OjAzOjE2ICswMDAwXG4gKi9cbi8qIGdsb2JhbCBsb2NhdGlvbiwgc2V0VGltZW91dCwgd2luZG93LCBnbG9iYWwsIHNwcmludGYsIHNldEltbWVkaWF0ZSxcbiAgICAgICAgICBJbnRlcnNlY3Rpb25PYnNlcnZlciwgIFJlc2l6ZU9ic2VydmVyLCBtb2R1bGUsIHJlcXVpcmUsIGRlZmluZSxcbiAgICAgICAgICBzZXRJbnRlcnZhbCwgY2xlYXJJbnRlcnZhbCwgY2xlYXJUaW1lb3V0LCBCbG9iLCBNYXAsIEltYWdlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbihmdW5jdGlvbihjdHgpIHtcbiAgICB2YXIgc3ByaW50ZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNwcmludGYuY2FjaGUuaGFzT3duUHJvcGVydHkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgc3ByaW50Zi5jYWNoZVthcmd1bWVudHNbMF1dID0gc3ByaW50Zi5wYXJzZShhcmd1bWVudHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcHJpbnRmLmZvcm1hdC5jYWxsKG51bGwsIHNwcmludGYuY2FjaGVbYXJndW1lbnRzWzBdXSwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHNwcmludGYuZm9ybWF0ID0gZnVuY3Rpb24ocGFyc2VfdHJlZSwgYXJndikge1xuICAgICAgICB2YXIgY3Vyc29yID0gMSwgdHJlZV9sZW5ndGggPSBwYXJzZV90cmVlLmxlbmd0aCwgbm9kZV90eXBlID0gJycsIGFyZywgb3V0cHV0ID0gW10sIGksIGssIG1hdGNoLCBwYWQsIHBhZF9jaGFyYWN0ZXIsIHBhZF9sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0cmVlX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBub2RlX3R5cGUgPSBnZXRfdHlwZShwYXJzZV90cmVlW2ldKTtcbiAgICAgICAgICAgIGlmIChub2RlX3R5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocGFyc2VfdHJlZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlX3R5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHBhcnNlX3RyZWVbaV07IC8vIGNvbnZlbmllbmNlIHB1cnBvc2VzIG9ubHlcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMl0pIHsgLy8ga2V5d29yZCBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd2W2N1cnNvcl07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBtYXRjaFsyXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmcuaGFzT3duUHJvcGVydHkobWF0Y2hbMl1ba10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coc3ByaW50ZignW3NwcmludGZdIHByb3BlcnR5IFwiJXNcIiBkb2VzIG5vdCBleGlzdCcsIG1hdGNoWzJdW2tdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmdbbWF0Y2hbMl1ba11dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzFdKSB7IC8vIHBvc2l0aW9uYWwgYXJndW1lbnQgKGV4cGxpY2l0KVxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd2W21hdGNoWzFdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIHBvc2l0aW9uYWwgYXJndW1lbnQgKGltcGxpY2l0KVxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd2W2N1cnNvcisrXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoL1tec10vLnRlc3QobWF0Y2hbOF0pICYmIChnZXRfdHlwZShhcmcpICE9PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3coc3ByaW50ZignW3NwcmludGZdIGV4cGVjdGluZyBudW1iZXIgYnV0IGZvdW5kICVzJywgZ2V0X3R5cGUoYXJnKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1hdGNoWzhdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOiBhcmcgPSBhcmcudG9TdHJpbmcoMik7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzogYXJnID0gU3RyaW5nLmZyb21DaGFyQ29kZShhcmcpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6IGFyZyA9IHBhcnNlSW50KGFyZywgMTApOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZSc6IGFyZyA9IG1hdGNoWzddID8gYXJnLnRvRXhwb25lbnRpYWwobWF0Y2hbN10pIDogYXJnLnRvRXhwb25lbnRpYWwoKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOiBhcmcgPSBtYXRjaFs3XSA/IHBhcnNlRmxvYXQoYXJnKS50b0ZpeGVkKG1hdGNoWzddKSA6IHBhcnNlRmxvYXQoYXJnKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ28nOiBhcmcgPSBhcmcudG9TdHJpbmcoOCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzogYXJnID0gKChhcmcgPSBTdHJpbmcoYXJnKSkgJiYgbWF0Y2hbN10gPyBhcmcuc2xpY2UoMCwgbWF0Y2hbN10pIDogYXJnKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOiBhcmcgPSBhcmcgPj4+IDA7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzogYXJnID0gYXJnLnRvU3RyaW5nKDE2KTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1gnOiBhcmcgPSBhcmcudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcmcgPSAoL1tkZWZdLy50ZXN0KG1hdGNoWzhdKSAmJiBtYXRjaFszXSAmJiBhcmcgPj0gMCA/ICcgKycgKyBhcmcgOiBhcmcpO1xuICAgICAgICAgICAgICAgIHBhZF9jaGFyYWN0ZXIgPSBtYXRjaFs0XSA/IG1hdGNoWzRdID09PSAnMCcgPyAnMCcgOiBtYXRjaFs0XS5jaGFyQXQoMSkgOiAnICc7XG4gICAgICAgICAgICAgICAgcGFkX2xlbmd0aCA9IG1hdGNoWzZdIC0gU3RyaW5nKGFyZykubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBhZCA9IG1hdGNoWzZdID8gc3RyX3JlcGVhdChwYWRfY2hhcmFjdGVyLCBwYWRfbGVuZ3RoKSA6ICcnO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG1hdGNoWzVdID8gYXJnICsgcGFkIDogcGFkICsgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICAgIH07XG5cbiAgICBzcHJpbnRmLmNhY2hlID0ge307XG5cbiAgICBzcHJpbnRmLnBhcnNlID0gZnVuY3Rpb24oZm10KSB7XG4gICAgICAgIHZhciBfZm10ID0gZm10LCBtYXRjaCA9IFtdLCBwYXJzZV90cmVlID0gW10sIGFyZ19uYW1lcyA9IDA7XG4gICAgICAgIHdoaWxlIChfZm10KSB7XG4gICAgICAgICAgICBpZiAoKG1hdGNoID0gL15bXlxceDI1XSsvLmV4ZWMoX2ZtdCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VfdHJlZS5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChtYXRjaCA9IC9eXFx4MjV7Mn0vLmV4ZWMoX2ZtdCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VfdHJlZS5wdXNoKCclJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgobWF0Y2ggPSAvXlxceDI1KD86KFsxLTldXFxkKilcXCR8XFwoKFteXFwpXSspXFwpKT8oXFwrKT8oMHwnW14kXSk/KC0pPyhcXGQrKT8oPzpcXC4oXFxkKykpPyhbYi1mb3N1eFhdKS8uZXhlYyhfZm10KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnX25hbWVzIHw9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZF9saXN0ID0gW10sIHJlcGxhY2VtZW50X2ZpZWxkID0gbWF0Y2hbMl0sIGZpZWxkX21hdGNoID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZmllbGRfbWF0Y2ggPSAvXihbYS16X11bYS16X1xcZF0qKS9pLmV4ZWMocmVwbGFjZW1lbnRfZmllbGQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRfbGlzdC5wdXNoKGZpZWxkX21hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgocmVwbGFjZW1lbnRfZmllbGQgPSByZXBsYWNlbWVudF9maWVsZC5zbGljZShmaWVsZF9tYXRjaFswXS5sZW5ndGgpKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZpZWxkX21hdGNoID0gL15cXC4oW2Etel9dW2Etel9cXGRdKikvaS5leGVjKHJlcGxhY2VtZW50X2ZpZWxkKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRfbGlzdC5wdXNoKGZpZWxkX21hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKGZpZWxkX21hdGNoID0gL15cXFsoXFxkKylcXF0vLmV4ZWMocmVwbGFjZW1lbnRfZmllbGQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZF9saXN0LnB1c2goZmllbGRfbWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coJ1tzcHJpbnRmXSBodWg/Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3coJ1tzcHJpbnRmXSBodWg/Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0gPSBmaWVsZF9saXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnX25hbWVzIHw9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhcmdfbmFtZXMgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3coJ1tzcHJpbnRmXSBtaXhpbmcgcG9zaXRpb25hbCBhbmQgbmFtZWQgcGxhY2Vob2xkZXJzIGlzIG5vdCAoeWV0KSBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VfdHJlZS5wdXNoKG1hdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93KCdbc3ByaW50Zl0gaHVoPycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2ZtdCA9IF9mbXQuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VfdHJlZTtcbiAgICB9O1xuXG4gICAgdmFyIHZzcHJpbnRmID0gZnVuY3Rpb24oZm10LCBhcmd2LCBfYXJndikge1xuICAgICAgICBfYXJndiA9IGFyZ3Yuc2xpY2UoMCk7XG4gICAgICAgIF9hcmd2LnNwbGljZSgwLCAwLCBmbXQpO1xuICAgICAgICByZXR1cm4gc3ByaW50Zi5hcHBseShudWxsLCBfYXJndik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGhlbHBlcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRfdHlwZSh2YXJpYWJsZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhcmlhYmxlKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJfcmVwZWF0KGlucHV0LCBtdWx0aXBsaWVyKSB7XG4gICAgICAgIGZvciAodmFyIG91dHB1dCA9IFtdOyBtdWx0aXBsaWVyID4gMDsgb3V0cHV0Wy0tbXVsdGlwbGllcl0gPSBpbnB1dCkgey8qIGRvIG5vdGhpbmcgKi99XG4gICAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZXhwb3J0IHRvIGVpdGhlciBicm93c2VyIG9yIG5vZGUuanNcbiAgICAgKi9cbiAgICBjdHguc3ByaW50ZiA9IHNwcmludGY7XG4gICAgY3R4LnZzcHJpbnRmID0gdnNwcmludGY7XG59KSh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93KTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiBlc2xpbnQtZW5hYmxlICovXG4vLyBVTUQgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdW1kanMvdW1kXG4oZnVuY3Rpb24oZmFjdG9yeSwgdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJvb3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbDtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgZGVmaW5lKFsnanF1ZXJ5JywgJ3djd2lkdGgnXSwgZnVuY3Rpb24oanF1ZXJ5LCB3Y3dpZHRoKSB7XG4gICAgICAgICAgICBmYWN0b3J5KGpxdWVyeSwgd2N3aWR0aCwgcm9vdCk7XG4gICAgICAgICAgICByZXR1cm4ganF1ZXJ5O1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIC8vIE5vZGUvQ29tbW9uSlNcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyb290LCBqUXVlcnksIHdjd2lkdGgpIHtcbiAgICAgICAgICAgIGlmIChqUXVlcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIHJlcXVpcmUoJ2pRdWVyeScpIHJldHVybnMgYSBmYWN0b3J5IHRoYXQgcmVxdWlyZXMgd2luZG93IHRvXG4gICAgICAgICAgICAgICAgLy8gYnVpbGQgYSBqUXVlcnkgaW5zdGFuY2UsIHdlIG5vcm1hbGl6ZSBob3cgd2UgdXNlIG1vZHVsZXNcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHJlcXVpcmUgdGhpcyBwYXR0ZXJuIGJ1dCB0aGUgd2luZG93IHByb3ZpZGVkIGlzIGEgbm9vcFxuICAgICAgICAgICAgICAgIC8vIGlmIGl0J3MgZGVmaW5lZCAoaG93IGpxdWVyeSB3b3JrcylcbiAgICAgICAgICAgICAgICBpZiAod2luZG93ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jykocm9vdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdjd2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHdjd2lkdGggPSByZXF1aXJlKCd3Y3dpZHRoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmYWN0b3J5KGpRdWVyeSwgd2N3aWR0aCwgcm9vdCk7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5O1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXJcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgZmFjdG9yeShyb290LmpRdWVyeSwgcm9vdC53Y3dpZHRoLCByb290KTtcbiAgICB9XG59KShmdW5jdGlvbigkLCB3Y3dpZHRoLCByb290LCB1bmRlZmluZWQpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiBkZWJ1ZyBmdW5jdGlvbnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qIGVzbGludC1kaXNhYmxlICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBkZWJ1ZyhzdHIpIHtcbiAgICAgICAgaWYgKGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdHIpO1xuICAgICAgICAgICAgLy8kLnRlcm1pbmFsLmFjdGl2ZSgpLmVjaG8oc3RyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiBSZXBsYWNlbWVuZXQgZm9yIGpRdWVyeSAyIGRlZmVycmVkIG9iamVjdHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIERlbGF5UXVldWUoKSB7XG4gICAgICAgIHZhciBjYWxsYmFja3MgPSAkLkNhbGxiYWNrcygpO1xuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYWxsYmFja3MuZmlyZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MuYWRkKGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiBtYXAgb2JqZWN0IHRvIG9iamVjdFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgJC5vbWFwID0gZnVuY3Rpb24obywgZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAkLmVhY2gobywgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgcmVzdWx0W2tdID0gZm4uY2FsbChvLCBrLCB2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAkLmZuLnRleHRfbGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLnRleHQoKS5sZW5ndGg7XG4gICAgICAgIH0pLmdldCgpLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiBEZWVwIGNsb25lIG9mIG9iamVjdHMgYW5kIGFycmF5c1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIENsb25lID0ge1xuICAgICAgICBjbG9uZV9vYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCQuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lX2FycmF5KG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KG9iamVjdFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFtrZXldID0gdGhpcy5jbG9uZV9hcnJheShvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBba2V5XSA9IHRoaXMuY2xvbmVfb2JqZWN0KG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb25lX2FycmF5OiBmdW5jdGlvbihhcnJheSkge1xuICAgICAgICAgICAgaWYgKCFpc19mdW5jdGlvbihBcnJheS5wcm90b3R5cGUubWFwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdXIgYnJvd3NlciBkb24ndCBzdXBwb3J0IEVTNSBhcnJheSBtYXAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndXNlIGVzNS1zaGltJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyYXkuc2xpY2UoMCkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lX29iamVjdChpdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY2xvbmUgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIENsb25lLmNsb25lX29iamVjdChvYmplY3QpO1xuICAgIH07XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gOjogU3RvcmFnZSBwbHVnaW5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBsb2NhbFN0b3JhZ2U7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoYXNMUyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdEtleSA9ICd0ZXN0Jywgc3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKHRlc3RLZXksICcxJyk7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKHRlc3RLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBoYXNDb29raWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gUHJpdmF0ZSBkYXRhXG4gICAgICAgIHZhciBpc0xTID0gaGFzTFMoKTtcbiAgICAgICAgLy8gUHJpdmF0ZSBmdW5jdGlvbnNcbiAgICAgICAgZnVuY3Rpb24gd2xzKG4sIHYpIHtcbiAgICAgICAgICAgIHZhciBjO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Vbbl0gPSB2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjIGluIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4uaGFzT3duUHJvcGVydHkoYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZVtjXSA9IG5bY107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd2Mobiwgdikge1xuICAgICAgICAgICAgdmFyIGR0LCBlLCBjO1xuICAgICAgICAgICAgZHQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgZHQuc2V0VGltZShkdC5nZXRUaW1lKCkgKyAzMTUzNjAwMDAwMCk7XG4gICAgICAgICAgICBlID0gJzsgZXhwaXJlcz0nICsgZHQudG9HTVRTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbiA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gbiArICc9JyArIHYgKyBlICsgJzsgcGF0aD0vJztcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG4gPT09ICdvYmplY3QnICYmIHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGZvciAoYyBpbiBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLmhhc093blByb3BlcnR5KGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjICsgJz0nICsgbltjXSArIGUgKyAnOyBwYXRoPS8nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJscyhuKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlW25dO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJjKG4pIHtcbiAgICAgICAgICAgIHZhciBubiwgY2EsIGksIGM7XG4gICAgICAgICAgICBubiA9IG4gKyAnPSc7XG4gICAgICAgICAgICBjYSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYyA9IGNhW2ldO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBjLnNsaWNlKDEsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihubikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMuc2xpY2Uobm4ubGVuZ3RoLCBjLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGxzKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGUgbG9jYWxTdG9yYWdlW25dO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRjKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3YyhuLCAnJywgLTEpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQdWJsaWMgQVBJXG4gICAgICAgICAqICQuU3RvcmFnZS5zZXQoXCJuYW1lXCIsIFwidmFsdWVcIilcbiAgICAgICAgICogJC5TdG9yYWdlLnNldCh7XCJuYW1lMVwiOlwidmFsdWUxXCIsIFwibmFtZTJcIjpcInZhbHVlMlwiLCBldGN9KVxuICAgICAgICAgKiAkLlN0b3JhZ2UuZ2V0KFwibmFtZVwiKVxuICAgICAgICAgKiAkLlN0b3JhZ2UucmVtb3ZlKFwibmFtZVwiKVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFoYXNDb29raWVzKCkgJiYgIWlzTFMpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZSA9IHt9O1xuICAgICAgICAgICAgJC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIFN0b3JhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0OiB3bHMsXG4gICAgICAgICAgICAgICAgICAgIGdldDogcmxzLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmU6IGRsc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzTFMpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIFN0b3JhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBpc0xTID8gd2xzIDogd2MsXG4gICAgICAgICAgICAgICAgICAgIGdldDogaXNMUyA/IHJscyA6IHJjLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmU6IGlzTFMgPyBkbHMgOiBkY1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDo6IERlYm91bmNlIGZyb20gTG9kYXNoXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHZhciBkZWJvdW5jZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcbiAgICAgICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBub3coKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICAgICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4gICAgICAgICAgICB2YXIgbGFzdEFyZ3MsXG4gICAgICAgICAgICAgICAgbGFzdFRoaXMsXG4gICAgICAgICAgICAgICAgbWF4V2FpdCxcbiAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgdGltZXJJZCxcbiAgICAgICAgICAgICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgICAgICAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2FpdCA9IHdhaXQgfHwgMDtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICAgICAgICAgICAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KG9wdGlvbnMubWF4V2FpdCB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgICAgICAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgICAgICAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgICAgICAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICAgICAgICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICAgICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgICAgICAgICAgICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgICAgICAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF4aW5nXG4gICAgICAgICAgICAgICAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgICAgICAgICAgICAgICAgOiB0aW1lV2FpdGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgICAgICAgICAgICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICAgICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgICAgICAgICAgICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgICAgICAgICAgICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgICAgICAgICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgICAgICAgICAgICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgICAgICAgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICAgICAgICAgICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgICAgICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgICAgICAgICByZXR1cm4gZGVib3VuY2VkO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiBqUXVlcnkgVGltZXJzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgalF1ZXJ5ID0gJDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIChmdW5jdGlvbigkKSB7XG4gICAgICAgIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgICAgICAgICAgZXZlcnlUaW1lOiBmdW5jdGlvbihpbnRlcnZhbCwgbGFiZWwsIGZuLCB0aW1lcywgYmVsYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkudGltZXIuYWRkKHRoaXMsIGludGVydmFsLCBsYWJlbCwgZm4sIHRpbWVzLCBiZWxheSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25lVGltZTogZnVuY3Rpb24oaW50ZXJ2YWwsIGxhYmVsLCBmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS50aW1lci5hZGQodGhpcywgaW50ZXJ2YWwsIGxhYmVsLCBmbiwgMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcFRpbWU6IGZ1bmN0aW9uKGxhYmVsLCBmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS50aW1lci5yZW1vdmUodGhpcywgbGFiZWwsIGZuKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgICAgICAgICB0aW1lcjoge1xuICAgICAgICAgICAgICAgIGd1aWQ6IDEsXG4gICAgICAgICAgICAgICAgZ2xvYmFsOiB7fSxcbiAgICAgICAgICAgICAgICByZWdleDogL14oWzAtOV0rKVxccyooLipzKT8kLyxcbiAgICAgICAgICAgICAgICBwb3dlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gWWVhaCB0aGlzIGlzIG1ham9yIG92ZXJraWxsLi4uXG4gICAgICAgICAgICAgICAgICAgICdtcyc6IDEsXG4gICAgICAgICAgICAgICAgICAgICdjcyc6IDEwLFxuICAgICAgICAgICAgICAgICAgICAnZHMnOiAxMDAsXG4gICAgICAgICAgICAgICAgICAgICdzJzogMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgJ2Rhcyc6IDEwMDAwLFxuICAgICAgICAgICAgICAgICAgICAnaHMnOiAxMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgICdrcyc6IDEwMDAwMDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRpbWVQYXJzZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlZ2V4LmV4ZWMoalF1ZXJ5LnRyaW0odmFsdWUudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0WzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtID0gcGFyc2VJbnQocmVzdWx0WzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXVsdCA9IHRoaXMucG93ZXJzW3Jlc3VsdFsyXV0gfHwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudW0gKiBtdWx0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGludGVydmFsLCBsYWJlbCwgZm4sIHRpbWVzLCBiZWxheSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGxhYmVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzID0gZm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmbiA9IGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBpbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsID0galF1ZXJ5LnRpbWVyLnRpbWVQYXJzZShpbnRlcnZhbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnRlcnZhbCAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTmFOKGludGVydmFsKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcyAmJiB0aW1lcy5jb25zdHJ1Y3RvciAhPT0gTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWxheSA9ICEhdGltZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aW1lcyA9IHRpbWVzIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGJlbGF5ID0gYmVsYXkgfHwgZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LiR0aW1lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuJHRpbWVycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC4kdGltZXJzW2xhYmVsXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC4kdGltZXJzW2xhYmVsXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZuLiR0aW1lcklEID0gZm4uJHRpbWVySUQgfHwgdGhpcy5ndWlkKys7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZWxheSAmJiBoYW5kbGVyLmluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgrK2NvdW50ZXIgPiB0aW1lcyAmJiB0aW1lcyAhPT0gMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKGVsZW1lbnQsIGNvdW50ZXIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS50aW1lci5yZW1vdmUoZWxlbWVudCwgbGFiZWwsIGZuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuaW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuJHRpbWVySUQgPSBmbi4kdGltZXJJRDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQuJHRpbWVyc1tsYWJlbF1bZm4uJHRpbWVySURdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LiR0aW1lcnNbbGFiZWxdW2ZuLiR0aW1lcklEXSA9IHdpbmRvdy5zZXRJbnRlcnZhbChoYW5kbGVyLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2xvYmFsW2xhYmVsXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxbbGFiZWxdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxbbGFiZWxdLnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oZWxlbWVudCwgbGFiZWwsIGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lcnMgPSBlbGVtZW50LiR0aW1lcnMsIHJldDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXJzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsYWIgaW4gdGltZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcnMuaGFzT3duUHJvcGVydHkobGFiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCwgbGFiLCBmbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRpbWVyc1tsYWJlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuLiR0aW1lcklEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aW1lcnNbbGFiZWxdW2ZuLiR0aW1lcklEXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGltZXJzW2xhYmVsXVtmbi4kdGltZXJJRF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZm4gaW4gdGltZXJzW2xhYmVsXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyc1tsYWJlbF0uaGFzT3duUHJvcGVydHkoX2ZuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRpbWVyc1tsYWJlbF1bX2ZuXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRpbWVyc1tsYWJlbF1bX2ZuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocmV0IGluIHRpbWVyc1tsYWJlbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyc1tsYWJlbF0uaGFzT3duUHJvcGVydHkocmV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRpbWVyc1tsYWJlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHJldCBpbiB0aW1lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXJzLmhhc093blByb3BlcnR5KHJldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LiR0aW1lcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKC8obXNpZSkgKFtcXHcuXSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICQod2luZG93KS5vbmUoJ3VubG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBnbG9iYWwgPSBqUXVlcnkudGltZXIuZ2xvYmFsO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGxhYmVsIGluIGdsb2JhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVscyA9IGdsb2JhbFtsYWJlbF0sIGkgPSBlbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKC0taSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS50aW1lci5yZW1vdmUoZWxzW2ldLCBsYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pKGpRdWVyeSk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiBDUk9TUyBCUk9XU0VSIFNQTElUXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIChmdW5jdGlvbih1bmRlZikge1xuICAgICAgICAvLyBwcmV2ZW50IGRvdWJsZSBpbmNsdWRlXG5cbiAgICAgICAgaWYgKCFTdHJpbmcucHJvdG90eXBlLnNwbGl0LnRvU3RyaW5nKCkubWF0Y2goL1xcW25hdGl2ZS8pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmF0aXZlU3BsaXQgPSBTdHJpbmcucHJvdG90eXBlLnNwbGl0LFxuICAgICAgICBjb21wbGlhbnRFeGVjTnBjZyA9IC8oKT8/Ly5leGVjKFwiXCIpWzFdID09PSB1bmRlZiwgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgc2VsZjtcblxuICAgICAgICBzZWxmID0gZnVuY3Rpb24oc3RyLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIGBuYXRpdmVTcGxpdGBcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gXCJbb2JqZWN0IFJlZ0V4cF1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVTcGxpdC5jYWxsKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgK1xuICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lICA/IFwibVwiIDogXCJcIikgK1xuICAgICAgICAgICAgICAgIChzZXBhcmF0b3IuZXh0ZW5kZWQgICA/IFwieFwiIDogXCJcIikgKyAvLyBQcm9wb3NlZCBmb3IgRVM2XG4gICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgICAgID8gXCJ5XCIgOiBcIlwiKSwgLy8gRmlyZWZveCAzK1xuICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgICAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgXCJnXCIpO1xuICAgICAgICAgICAgc3RyICs9IFwiXCI7IC8vIFR5cGUtY29udmVydFxuICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKFwiXlwiICsgc2VwYXJhdG9yLnNvdXJjZSArIFwiJCg/IVxcXFxzKVwiLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyA/IE1hdGgucG93KDIsIDMyKSAtIDEgOiBUb1VpbnQzMihsaW1pdClcbiAgICAgICAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmID8gLTEgPj4+IDAgOiBsaW1pdCA+Pj4gMDtcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHNlcGFyYXRvci5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdW5kZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdChcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBGb3IgY29udmVuaWVuY2VcbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuXG4gICAgfSkoKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDo6IGpRdWVyeSBDYXJldFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAkLmZuLmNhcmV0ID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzWzBdO1xuICAgICAgICB2YXIgaXNDb250ZW50RWRpdGFibGUgPSB0YXJnZXQuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZSc7XG4gICAgICAgIC8vZ2V0XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvL0hUTUw1XG4gICAgICAgICAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vY29udGVudGVkaXRhYmxlXG4gICAgICAgICAgICAgICAgaWYgKGlzQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UxID0gd2luZG93LmdldFNlbGVjdGlvbigpLmdldFJhbmdlQXQoMCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlMiA9IHJhbmdlMS5jbG9uZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlMi5zZWxlY3ROb2RlQ29udGVudHModGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UyLnNldEVuZChyYW5nZTEuZW5kQ29udGFpbmVyLCByYW5nZTEuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlMi50b1N0cmluZygpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy90ZXh0YXJlYVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL0lFPDlcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAvL2NvbnRlbnRlZGl0YWJsZVxuICAgICAgICAgICAgICAgIGlmIChpc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UxID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlMiA9IGRvY3VtZW50LmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlMi5tb3ZlVG9FbGVtZW50VGV4dCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZTIuc2V0RW5kUG9pbnQoJ0VuZFRvRW5kJywgcmFuZ2UxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlMi50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy90ZXh0YXJlYVxuICAgICAgICAgICAgICAgIHZhciBwb3MgPSAwLFxuICAgICAgICAgICAgICAgIHJhbmdlID0gdGFyZ2V0LmNyZWF0ZVRleHRSYW5nZSgpLFxuICAgICAgICAgICAgICAgIHJhbmdlMiA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmR1cGxpY2F0ZSgpLFxuICAgICAgICAgICAgICAgIGJvb2ttYXJrID0gcmFuZ2UyLmdldEJvb2ttYXJrKCk7XG4gICAgICAgICAgICAgICAgcmFuZ2UubW92ZVRvQm9va21hcmsoYm9va21hcmspO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC0xKSAhPT0gMCkgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy9zZXRcbiAgICAgICAgaWYgKHBvcyA9PT0gLTEpXG4gICAgICAgICAgICBwb3MgPSB0aGlzW2lzQ29udGVudEVkaXRhYmxlPyAndGV4dCcgOiAndmFsJ10oKS5sZW5ndGg7XG4gICAgICAgIC8vSFRNTDVcbiAgICAgICAgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIC8vY29udGVudGVkaXRhYmxlXG4gICAgICAgICAgICBpZiAoaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkuY29sbGFwc2UodGFyZ2V0LmZpcnN0Q2hpbGQsIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3RleHRhcmVhXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldFNlbGVjdGlvblJhbmdlKHBvcywgcG9zKTtcbiAgICAgICAgfVxuICAgICAgICAvL0lFPDlcbiAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQuYm9keS5jcmVhdGVUZXh0UmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5tb3ZlVG9FbGVtZW50VGV4dCh0YXJnZXQpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBwb3MpO1xuICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQ29udGVudEVkaXRhYmxlICYmICF0aGlzLmlzKCc6Zm9jdXMnKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDo6IENyb3NzLWJyb3dzZXIgcmVzaXplIGVsZW1lbnQgcGx1Z2luIHVzaW5nIHNlbnRpbmVsIGlmcmFtZSBvclxuICAgIC8vIDo6IHJlc2l6ZU9ic2VydmVyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAkLmZuLnJlc2l6ZXIgPSBmdW5jdGlvbihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwge1xuICAgICAgICAgICAgcHJlZml4OiAnJ1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHRyaWdnZXIgPSBhcmd1bWVudHMubGVuZ3RoID09PSAwO1xuICAgICAgICB2YXIgdW5iaW5kID0gYXJndW1lbnRzWzBdID09PSBcInVuYmluZFwiO1xuICAgICAgICBpZiAoIXRyaWdnZXIgJiYgIXVuYmluZCAmJiAhaXNfZnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQsIGl0IG5lZWQgdG8gYSBmdW5jdGlvbiBvciBzdHJpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1widW5iaW5kXCIgb3Igbm8gYXJndW1lbnRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmJpbmQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gaXNfZnVuY3Rpb24oYXJndW1lbnRzWzFdKSA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICAgICB2YXIgaWZyYW1lO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrcztcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc2l6ZV9oYW5kbGVyKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5maXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJpZ2dlciB8fCB1bmJpbmQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSAkdGhpcy5kYXRhKCdjYWxsYmFja3MnKTtcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MgJiYgY2FsbGJhY2tzLmZpcmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucmVtb3ZlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2tzLmhhcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnJlbW92ZURhdGEoJ2NhbGxiYWNrcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5SZXNpemVPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlciA9ICR0aGlzLmRhdGEoJ29ic2VydmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMucmVtb3ZlRGF0YSgnb2JzZXJ2ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZSA9ICR0aGlzLmZpbmQoJz4gaWZyYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlmcmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBpbiBjYXNlIG9mIG1lbW9yeSBsZWFrcyBpbiBJRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGlmcmFtZVswXS5jb250ZW50V2luZG93KS5vZmYoJ3Jlc2l6ZScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkdGhpcy5pcygnYm9keScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS5yZXNpemVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICgkdGhpcy5kYXRhKCdjYWxsYmFja3MnKSkge1xuICAgICAgICAgICAgICAgICQodGhpcykuZGF0YSgnY2FsbGJhY2tzJykuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzID0gJC5DYWxsYmFja3MoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKCdjYWxsYmFja3MnLCBjYWxsYmFja3MpO1xuICAgICAgICAgICAgICAgIHZhciByZXNpemVyO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5SZXNpemVPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICByZXNpemVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZV9oYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplci5vYnNlcnZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKCdvYnNlcnZlcicsIHJlc2l6ZXIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHRoaXMuaXMoJ2JvZHknKSkge1xuICAgICAgICAgICAgICAgICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZS5yZXNpemVyJywgcmVzaXplX2hhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZSA9ICQoJzxpZnJhbWUvPicpLmFkZENsYXNzKHNldHRpbmdzLnByZWZpeCArICdyZXNpemVyJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh0aGlzKVswXTtcblxuICAgICAgICAgICAgICAgICAgICAkKGlmcmFtZS5jb250ZW50V2luZG93KS5vbigncmVzaXplJywgcmVzaXplX2hhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGpxdWVyeV9yZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuICAgICAgICBkZWZlci5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiB1bnByb21pc2UodmFsdWUsIGNhbGxiYWNrLCBlcnJvcikge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbih2YWx1ZS5jYXRjaCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5jYXRjaChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24odmFsdWUuZG9uZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuZG9uZShjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzX2Z1bmN0aW9uKHZhbHVlLnRoZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRoZW4oY2FsbGJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gOjogYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3pldXNkZXV4L2lzSW5WaWV3cG9ydFxuICAgIC8vIDo6IHdvcmsgb25seSB2ZXJ0aWNhbGx5IGFuZCBvbiBkb20gZWxlbWVudHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICQuZm4uaXNfZnVsbHlfaW5fdmlld3BvcnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIGlzX3Zpc2libGUobm9kZSwgY29udGFpbmVyKSB7XG4gICAgICAgICAgICB2YXIgYm94ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciB2aWV3cG9ydCA9IGNvbnRhaW5lclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciB0b3AgPSBib3gudG9wIC0gdmlld3BvcnQudG9wO1xuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IGJveC5ib3R0b20gLSB2aWV3cG9ydC50b3A7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gY29udGFpbmVyLmhlaWdodCgpO1xuICAgICAgICAgICAgcmV0dXJuIGJvdHRvbSA+IDAgJiYgdG9wIDw9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuICAgICAgICAgICAgICAgIHZhciBpdGVtX29ic2VydmVyID0gbmV3IHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlcihmdW5jdGlvbihlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoZW50cmllc1swXS5pc0ludGVyc2VjdGluZyAmJiBlbnRyaWVzWzBdLnJhdGlvID09PSAxKTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbV9vYnNlcnZlci51bm9ic2VydmUobm9kZSk7XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICByb290OiBjb250YWluZXJbMF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpdGVtX29ic2VydmVyLm9ic2VydmUobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpxdWVyeV9yZXNvbHZlKGlzX3Zpc2libGUodGhpc1swXSwgY29udGFpbmVyKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICB2YXIgZW50aXR5X3JlID0gLygmKD86W2EtelxcZF0rfCNcXGQrfCN4W2EtZlxcZF0rKTspL2k7XG4gICAgLy8gcmVnZXggdGhhdCBtYXRjaCBzaW5nbGUgY2hhcmFjdGVyIGF0IGJlZ2luaW5nIGFuZCBmb2xvd2luZyBjb21iaW5lIGNoYXJhY3RlclxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19jaGFyYWN0ZXJcbiAgICB2YXIgY29tYmluZV9jaHJfcmUgPSAvKC4oPzpbXFx1MDMwMC1cXHUwMzZGXXxbXFx1MUFCMC1cXHUxYWJFXXxbXFx1MURDMC1cXHUxREY5XXxbXFx1MURGQi1cXHUxREZGXXxbXFx1MjBEMC1cXHUyMEYwXXxbXFx1RkUyMC1cXHVGRTJGXSkrKS87XG4gICAgLy8gc291cmNlOiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlXG4gICAgdmFyIGFzdHJhbF9zeW1ib2xzX3JlID0gLyhbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdKS87XG4gICAgLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9lbW9qaS1yZWdleFxuICAgIHZhciBlbW9qaV9yZSA9IC8oXFx1RDgzQ1xcdURGRjQoPzpcXHVEQjQwXFx1REM2N1xcdURCNDBcXHVEQzYyKD86XFx1REI0MFxcdURDNjVcXHVEQjQwXFx1REM2RVxcdURCNDBcXHVEQzY3fFxcdURCNDBcXHVEQzc3XFx1REI0MFxcdURDNkNcXHVEQjQwXFx1REM3M3xcXHVEQjQwXFx1REM3M1xcdURCNDBcXHVEQzYzXFx1REI0MFxcdURDNzQpXFx1REI0MFxcdURDN0Z8XFx1MjAwRFxcdTI2MjBcXHVGRTBGKXxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSkpfFxcdUQ4M0RcXHVEQzY4KD86XFx1MjAwRCg/OlxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRFxcdURDNjh8KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKSl8XFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERCMC1cXHVEREIzXSl8KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQjAtXFx1RERCM10pKXxcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSl8XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERCMC1cXHVEREIzXSl8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8KD86XFx1RDgzRFxcdURDNDFcXHVGRTBGXFx1MjAwRFxcdUQ4M0RcXHVEREU4fFxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNEXFx1REM2OCg/Oig/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdKXwoPzooPzpcXHUyNkY5fFxcdUQ4M0NbXFx1REZDQlxcdURGQ0NdfFxcdUQ4M0RcXHVERDc1KVxcdUZFMEZ8XFx1RDgzRFxcdURDNkZ8XFx1RDgzRVtcXHVERDNDXFx1RERERVxcdUREREZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfCg/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfCg/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREI4XFx1RERCOVxcdURERDYtXFx1RERERF0pKD86KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfFxcdTIwMERbXFx1MjY0MFxcdTI2NDJdKXxcXHVEODNEXFx1REM2OVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XSlcXHVGRTBGfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8XFx1RDgzRFxcdURDNjgoPzpcXHUyMDBEKD86KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHVEODNDXFx1REZGM1xcdUZFMEZcXHUyMDBEXFx1RDgzQ1xcdURGMDh8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjd8XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERCMC1cXHVEREIzXSl8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzQ1xcdURERjZcXHVEODNDXFx1RERFNnxcXHVEODNDXFx1RERGRFxcdUQ4M0NcXHVEREYwfFxcdUQ4M0NcXHVEREY0XFx1RDgzQ1xcdURERjJ8XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0NcXHVEREVEKD86XFx1RDgzQ1tcXHVEREYwXFx1RERGMlxcdURERjNcXHVEREY3XFx1RERGOVxcdURERkFdKXxcXHVEODNDXFx1RERFQyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUVcXHVEREYxLVxcdURERjNcXHVEREY1LVxcdURERkFcXHVEREZDXFx1RERGRV0pfFxcdUQ4M0NcXHVEREVBKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUFcXHVEREVDXFx1RERFRFxcdURERjctXFx1RERGQV0pfFxcdUQ4M0NcXHVEREU4KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERTlcXHVEREVCLVxcdURERUVcXHVEREYwLVxcdURERjVcXHVEREY3XFx1RERGQS1cXHVEREZGXSl8XFx1RDgzQ1xcdURERjIoPzpcXHVEODNDW1xcdURERTZcXHVEREU4LVxcdURERURcXHVEREYwLVxcdURERkZdKXxcXHVEODNDXFx1RERGMyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBLVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjRcXHVEREY1XFx1RERGN1xcdURERkFcXHVEREZGXSl8XFx1RDgzQ1xcdURERkMoPzpcXHVEODNDW1xcdURERUJcXHVEREY4XSl8XFx1RDgzQ1xcdURERkEoPzpcXHVEODNDW1xcdURERTZcXHVEREVDXFx1RERGMlxcdURERjNcXHVEREY4XFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERGMCg/OlxcdUQ4M0NbXFx1RERFQVxcdURERUMtXFx1RERFRVxcdURERjJcXHVEREYzXFx1RERGNVxcdURERjdcXHVEREZDXFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERFRig/OlxcdUQ4M0NbXFx1RERFQVxcdURERjJcXHVEREY0XFx1RERGNV0pfFxcdUQ4M0NcXHVEREY4KD86XFx1RDgzQ1tcXHVEREU2LVxcdURERUFcXHVEREVDLVxcdURERjRcXHVEREY3LVxcdURERjlcXHVEREZCXFx1RERGRC1cXHVEREZGXSl8XFx1RDgzQ1xcdURERUUoPzpcXHVEODNDW1xcdURERTgtXFx1RERFQVxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOV0pfFxcdUQ4M0NcXHVEREZGKD86XFx1RDgzQ1tcXHVEREU2XFx1RERGMlxcdURERkNdKXxcXHVEODNDXFx1RERFQig/OlxcdUQ4M0NbXFx1RERFRS1cXHVEREYwXFx1RERGMlxcdURERjRcXHVEREY3XSl8XFx1RDgzQ1xcdURERjUoPzpcXHVEODNDW1xcdURERTZcXHVEREVBLVxcdURERURcXHVEREYwLVxcdURERjNcXHVEREY3LVxcdURERjlcXHVEREZDXFx1RERGRV0pfFxcdUQ4M0NcXHVEREU5KD86XFx1RDgzQ1tcXHVEREVBXFx1RERFQ1xcdURERUZcXHVEREYwXFx1RERGMlxcdURERjRcXHVEREZGXSl8XFx1RDgzQ1xcdURERjkoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRFxcdURERUYtXFx1RERGNFxcdURERjdcXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZGXSl8XFx1RDgzQ1xcdURERTcoPzpcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVGXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZFXFx1RERGRl0pfFsjXFwqMC05XVxcdUZFMEZcXHUyMEUzfFxcdUQ4M0NcXHVEREYxKD86XFx1RDgzQ1tcXHVEREU2LVxcdURERThcXHVEREVFXFx1RERGMFxcdURERjctXFx1RERGQlxcdURERkVdKXxcXHVEODNDXFx1RERFNig/OlxcdUQ4M0NbXFx1RERFOC1cXHVEREVDXFx1RERFRVxcdURERjFcXHVEREYyXFx1RERGNFxcdURERjYtXFx1RERGQVxcdURERkNcXHVEREZEXFx1RERGRl0pfFxcdUQ4M0NcXHVEREY3KD86XFx1RDgzQ1tcXHVEREVBXFx1RERGNFxcdURERjhcXHVEREZBXFx1RERGQ10pfFxcdUQ4M0NcXHVEREZCKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUFcXHVEREVDXFx1RERFRVxcdURERjNcXHVEREZBXSl8XFx1RDgzQ1xcdURERkUoPzpcXHVEODNDW1xcdURERUFcXHVEREY5XSl8KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdUREQjhcXHVEREI5XFx1RERENi1cXHVEREREXSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpbXFx1MjYxRFxcdTI3MEEtXFx1MjcwRF18XFx1RDgzQ1tcXHVERjg1XFx1REZDMlxcdURGQzddfFxcdUQ4M0RbXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2XFx1REM2N1xcdURDNzBcXHVEQzcyXFx1REM3NC1cXHVEQzc2XFx1REM3OFxcdURDN0NcXHVEQzgzXFx1REM4NVxcdURDQUFcXHVERDc0XFx1REQ3QVxcdUREOTBcXHVERDk1XFx1REQ5NlxcdURFNENcXHVERTRGXFx1REVDMFxcdURFQ0NdfFxcdUQ4M0VbXFx1REQxOC1cXHVERDFDXFx1REQxRVxcdUREMUZcXHVERDMwLVxcdUREMzZcXHVEREI1XFx1RERCNlxcdURERDEtXFx1RERENV0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpbXFx1MjMxQVxcdTIzMUJcXHUyM0U5LVxcdTIzRUNcXHUyM0YwXFx1MjNGM1xcdTI1RkRcXHUyNUZFXFx1MjYxNFxcdTI2MTVcXHUyNjQ4LVxcdTI2NTNcXHUyNjdGXFx1MjY5M1xcdTI2QTFcXHUyNkFBXFx1MjZBQlxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzVcXHUyNkNFXFx1MjZENFxcdTI2RUFcXHUyNkYyXFx1MjZGM1xcdTI2RjVcXHUyNkZBXFx1MjZGRFxcdTI3MDVcXHUyNzBBXFx1MjcwQlxcdTI3MjhcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzk1LVxcdTI3OTdcXHUyN0IwXFx1MjdCRlxcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVdfFxcdUQ4M0NbXFx1REMwNFxcdURDQ0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERFNi1cXHVEREZGXFx1REUwMVxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTM2XFx1REUzOC1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjBcXHVERjJELVxcdURGMzVcXHVERjM3LVxcdURGN0NcXHVERjdFLVxcdURGOTNcXHVERkEwLVxcdURGQ0FcXHVERkNGLVxcdURGRDNcXHVERkUwLVxcdURGRjBcXHVERkY0XFx1REZGOC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REMzRVxcdURDNDBcXHVEQzQyLVxcdURDRkNcXHVEQ0ZGLVxcdUREM0RcXHVERDRCLVxcdURENEVcXHVERDUwLVxcdURENjdcXHVERDdBXFx1REQ5NVxcdUREOTZcXHVEREE0XFx1RERGQi1cXHVERTRGXFx1REU4MC1cXHVERUM1XFx1REVDQ1xcdURFRDAtXFx1REVEMlxcdURFRUJcXHVERUVDXFx1REVGNC1cXHVERUY5XXxcXHVEODNFW1xcdUREMTAtXFx1REQzQVxcdUREM0MtXFx1REQzRVxcdURENDAtXFx1REQ0NVxcdURENDctXFx1REQ3MFxcdURENzMtXFx1REQ3NlxcdUREN0FcXHVERDdDLVxcdUREQTJcXHVEREIwLVxcdUREQjlcXHVEREMwLVxcdUREQzJcXHVEREQwLVxcdURERkZdKXwoPzpbI1xcKjAtOVxceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDRcXHUyNjBFXFx1MjYxMVxcdTI2MTRcXHUyNjE1XFx1MjYxOFxcdTI2MURcXHUyNjIwXFx1MjYyMlxcdTI2MjNcXHUyNjI2XFx1MjYyQVxcdTI2MkVcXHUyNjJGXFx1MjYzOC1cXHUyNjNBXFx1MjY0MFxcdTI2NDJcXHUyNjQ4LVxcdTI2NTNcXHUyNjVGXFx1MjY2MFxcdTI2NjNcXHUyNjY1XFx1MjY2NlxcdTI2NjhcXHUyNjdCXFx1MjY3RVxcdTI2N0ZcXHUyNjkyLVxcdTI2OTdcXHUyNjk5XFx1MjY5QlxcdTI2OUNcXHUyNkEwXFx1MjZBMVxcdTI2QUFcXHUyNkFCXFx1MjZCMFxcdTI2QjFcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM1XFx1MjZDOFxcdTI2Q0VcXHUyNkNGXFx1MjZEMVxcdTI2RDNcXHUyNkQ0XFx1MjZFOVxcdTI2RUFcXHUyNkYwLVxcdTI2RjVcXHUyNkY3LVxcdTI2RkFcXHUyNkZEXFx1MjcwMlxcdTI3MDVcXHUyNzA4LVxcdTI3MERcXHUyNzBGXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjNcXHUyNzY0XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzA0XFx1RENDRlxcdURENzBcXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERFNi1cXHVEREZGXFx1REUwMVxcdURFMDJcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzQVxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERjIxXFx1REYyNC1cXHVERjkzXFx1REY5NlxcdURGOTdcXHVERjk5LVxcdURGOUJcXHVERjlFLVxcdURGRjBcXHVERkYzLVxcdURGRjVcXHVERkY3LVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVEQ0ZEXFx1RENGRi1cXHVERDNEXFx1REQ0OS1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1REQ2RlxcdURENzBcXHVERDczLVxcdUREN0FcXHVERDg3XFx1REQ4QS1cXHVERDhEXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1RERBNFxcdUREQTVcXHVEREE4XFx1RERCMVxcdUREQjJcXHVEREJDXFx1RERDMi1cXHVEREM0XFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERFXFx1RERFMVxcdURERTNcXHVEREU4XFx1RERFRlxcdURERjNcXHVEREZBLVxcdURFNEZcXHVERTgwLVxcdURFQzVcXHVERUNCLVxcdURFRDJcXHVERUUwLVxcdURFRTVcXHVERUU5XFx1REVFQlxcdURFRUNcXHVERUYwXFx1REVGMy1cXHVERUY5XXxcXHVEODNFW1xcdUREMTAtXFx1REQzQVxcdUREM0MtXFx1REQzRVxcdURENDAtXFx1REQ0NVxcdURENDctXFx1REQ3MFxcdURENzMtXFx1REQ3NlxcdUREN0FcXHVERDdDLVxcdUREQTJcXHVEREIwLVxcdUREQjlcXHVEREMwLVxcdUREQzJcXHVEREQwLVxcdURERkZdKVxcdUZFMEZ8KD86W1xcdTI2MURcXHUyNkY5XFx1MjcwQS1cXHUyNzBEXXxcXHVEODNDW1xcdURGODVcXHVERkMyLVxcdURGQzRcXHVERkM3XFx1REZDQS1cXHVERkNDXXxcXHVEODNEW1xcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2Ni1cXHVEQzY5XFx1REM2RVxcdURDNzAtXFx1REM3OFxcdURDN0NcXHVEQzgxLVxcdURDODNcXHVEQzg1LVxcdURDODdcXHVEQ0FBXFx1REQ3NFxcdURENzVcXHVERDdBXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1REU0NS1cXHVERTQ3XFx1REU0Qi1cXHVERTRGXFx1REVBM1xcdURFQjQtXFx1REVCNlxcdURFQzBcXHVERUNDXXxcXHVEODNFW1xcdUREMTgtXFx1REQxQ1xcdUREMUVcXHVERDFGXFx1REQyNlxcdUREMzAtXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERCNVxcdUREQjZcXHVEREI4XFx1RERCOVxcdURERDEtXFx1RERERF0pKS87XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTEzODE2NzMvZGV0ZWN0aW5nLWEtbW9iaWxlLWJyb3dzZXJcbiAgICB2YXIgbW9iaWxlX3JlID0gLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWlub3xhbmRyb2lkfGlwYWR8cGxheWJvb2t8c2lsay9pO1xuICAgIHZhciB0YWJsZXRfcmUgPSAvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaTtcbiAgICB2YXIgZm9ybWF0X3NwbGl0X3JlID0gLyhcXFtcXFsoPzotP1tAIWdiaXVzb10pKjtbXjtdKjtbXlxcXV0qXFxdKD86W15cXF1cXFxcXSooPzpcXFxcXFxcXCkqXFxcXFxcXVteXFxdXSp8W15cXF1dKnxbXltdKlxcW1teXFxdXSopXFxdPykvaTtcbiAgICB2YXIgZm9ybWF0X3BhcnRzX3JlID0gL1xcW1xcWygoPzotP1tAIWdiaXVzb10pKik7KFteO10qKTsoW147XFxdXSopOz8oW147XFxdXSopOz8oW15cXF1dKilcXF0oW15cXF1cXFxcXSpcXFxcXFxdW15cXF1dKnxbXlxcXV0qfFteW10qXFxbW15cXF1dKylcXF0/L2dpO1xuICAgIHZhciBmb3JtYXRfcmUgPSAvXFxbXFxbKCg/Oi0/W0AhZ2JpdXNvXSkqO1teO1xcXV0qO1teO1xcXV0qKD86O3xbXlxcXSgpXSopOz9bXlxcXV0qKVxcXShbXlxcXV0qXFxcXFxcXVteXFxdXSp8W15cXF1dKnxbXltdKlxcW1teXFxdXSopXFxdPy9naTtcbiAgICB2YXIgZm9ybWF0X2V4aXN0X3JlID0gL1xcW1xcWygoPzotP1tAIWdiaXVzb10pKjtbXjtcXF1dKjtbXjtcXF1dKig/Ojt8W15cXF0oKV0qKTs/W15cXF1dKilcXF0oW15cXF1dKlxcXFxcXF1bXlxcXV0qfFteXFxdXSp8W15bXSpcXFtbXlxcXV0qKVxcXS9naTtcbiAgICB2YXIgZm9ybWF0X2Z1bGxfcmUgPSAvXihcXFtcXFsoPzooPzotP1tAIWdiaXVzb10pKjtbXjtcXF1dKjtbXjtcXF1dKig/Ojt8W15cXF0oKV0qKTs/W15cXF1dKilcXF0pKFteXFxdXSpcXFxcXFxdW15cXF1dKnxbXlxcXV0qfFteW10qXFxbW15cXF1dKikoXFxdKSQvaTtcbiAgICB2YXIgZm9ybWF0X2JlZ2luX3JlID0gLyhcXFtcXFsoPzotP1tAIWdiaXVzb10pKjtbXjtdKjtbXlxcXV0qXFxdKS9pO1xuICAgIHZhciBmb3JtYXRfc3RhcnRfcmUgPSAvXihcXFtcXFsoPzotP1tAIWdiaXVzb10pKjtbXjtdKjtbXlxcXV0qXFxdKS9pO1xuICAgIHZhciBmb3JtYXRfZW5kX3JlID0gL1xcW1xcWyg/Oi0/W0AhZ2JpdXNvXSkqO1teO10qO1teXFxdXSpcXF0/JC9pO1xuICAgIHZhciBzZWxmX2Nsb3NpbmdfcmUgPSAvXig/OlxcW1xcWyk/W147XSpAW147XSo7LztcbiAgICB2YXIgY29sb3JfaGV4X3JlID0gL14jKFswLTlhLWZdezN9fFswLTlhLWZdezZ9KSQvaTtcbiAgICB2YXIgdXJsX3JlID0gLyhcXGJodHRwcz86XFwvXFwvKD86KD86KD8hJlteO10rOyl8KD89JmFtcDspKVteXFxzXCInPD5cXF1bKV0pKykvZ2k7XG4gICAgdmFyIHVybF9uZl9yZSA9IC9cXGIoPyFbXlxcc1tcXF1dKl0pKGh0dHBzPzpcXC9cXC8oPzooPzooPyEmW147XSs7KXwoPz0mYW1wOykpW15cXHNcIic8PlxcXVspXSkrKS9naTtcbiAgICB2YXIgZW1haWxfcmUgPSAvKCgoW148PignXCIpW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoXFxbWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcXSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpKS9nO1xuICAgIHZhciB1cmxfZnVsbF9yZSA9IC9eKGh0dHBzPzpcXC9cXC8oPzooPzooPyEmW147XSs7KXwoPz0mYW1wOykpW15cXHNcIic8PlxcXVspXSkrKSQvZ2k7XG4gICAgdmFyIGVtYWlsX2Z1bGxfcmUgPSAvXigoKFtePD4oJ1wiKVtcXF1cXFxcLiw7Olxcc0BcIl0rKFxcLltePD4oKVtcXF1cXFxcLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKFxcW1swLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXF0pfCgoW2EtekEtWlxcLTAtOV0rXFwuKStbYS16QS1aXXsyLH0pKSkkL2c7XG4gICAgdmFyIGNvbW1hbmRfcmUgPSAvKCg/OlwiW15cIlxcXFxdKig/OlxcXFxbXFxTXFxzXVteXCJcXFxcXSopKlwifCdbXidcXFxcXSooPzpcXFxcW1xcU1xcc11bXidcXFxcXSopKid8XFwvW15cXC9cXFxcXSooPzpcXFxcW1xcU1xcc11bXlxcL1xcXFxdKikqXFwvW2dpbXN1eV0qKD89XFxzfCQpfCg/OlxcXFxcXHN8XFxTKSkrKSg/PVxcc3wkKS9naTtcbiAgICB2YXIgZXh0ZW5kZWRfY29tbWFuZF9yZSA9IC9eXFxzKigodGVybWluYWx8Y21kKTo6KFthLXpfXSspXFwoKFtcXHNcXFNdKilcXCkpXFxzKiQvO1xuICAgIHZhciBmb3JtYXRfZXhlY19yZSA9IC8oXFxbXFxbKD86W15cXF1bXXxcXFxcXFxdKStcXF1cXF0pLztcbiAgICB2YXIgZmxvYXRfcmUgPSAvXlstK10/WzAtOV0qXFwuP1swLTldKyhbZUVdWy0rXT9bMC05XSspPyQvO1xuICAgIHZhciByZV9yZSA9IC9eXFwvKCg/OlxcXFxcXC98W14vXXxcXFtbXlxcXV0qXFwvW15cXF1dKlxcXSkrKVxcLyhbZ2ltc3V5XSopJC87XG4gICAgdmFyIHN0cmluZ19yZSA9IC8oXCIoPzpbXlwiXFxcXF18XFxcXCg/OlxcXFxcXFxcKSpcInxcXFxcXFxcXCkqXCJ8Jyg/OlteJ1xcXFxdfFxcXFwoPzpcXFxcXFxcXCkqJ3xcXFxcXFxcXCkqJykvO1xuICAgIHZhciB1bmNsb3NlZF9zdHJpbmdzX3JlID0gL14oPz0oKD86W15cIiddK3xcIlteXCJcXFxcXSooPzpcXFxcW15dW15cIlxcXFxdKikqXCJ8J1teJ1xcXFxdKig/OlxcXFxbXl1bXidcXFxcXSopKicpKikpXFwxLi87XG4gICAgdmFyIGJyb2tlbl9pbWFnZSA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDE2IDE0XCI+PHRpdGxlIGlkPVwidGl0bGUyXCI+cm91bmRlZDwvdGl0bGU+PHBhdGggaWQ9XCJ0ZXJtaW5hbC1icm9rZW4taW1hZ2VcIiBkPVwibSAxNCwxMCBoIDIgdiAxIGEgMywzIDAgMCAxIC0zLDMgSCAzIEEgMywzIDAgMCAxIDAsMTEgSCA0LjUgQSAxLjAwMDEyLDEuMDAwMTIgMCAwIDAgNS4yMDcsMTAuNzA3IEwgNi41LDkuNDE0IDcuNzkzLDEwLjcwNyBhIDAuOTk5NjMsMC45OTk2MyAwIDAgMCAxLjQxNDA2LDAgbCAyLjM2NzE5LC0yLjM2NzE5IDEuODAxMjcsMS40NDA5MiBBIDAuOTk4MDcsMC45OTgwNyAwIDAgMCAxNCwxMCBaIE0gMTYsMyBWIDggSCAxNC4zNTA1OSBMIDEyLjEyNDUxLDYuMjE5MjQgQSAwLjk5ODQ2LDAuOTk4NDYgMCAwIDAgMTAuNzkzLDYuMjkzIEwgOC41LDguNTg2IDcuMjA3LDcuMjkzIGEgMC45OTk2MiwwLjk5OTYyIDAgMCAwIC0xLjQxNDA2LDAgTCA0LjA4NTk0LDkgSCAwIFYgMyBBIDMsMyAwIDAgMSAzLDAgaCAxMCBhIDMsMyAwIDAgMSAzLDMgeiBNIDYsNC41IEEgMS41LDEuNSAwIDEgMCA0LjUsNiAxLjUsMS41IDAgMCAwIDYsNC41IFpcIiAvPjwvc3ZnPic7XG4gICAgdmFyIHVzZV9icm9rZW5faW1hZ2UgPSAnPHN2ZyBjbGFzcz1cInRlcm1pbmFsLWJyb2tlbi1pbWFnZVwiIHJvbGU9XCJwcmVzZW50YXRpb25cIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAxNiAxNFwiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiPjx1c2UgeGxpbms6aHJlZj1cIiN0ZXJtaW5hbC1icm9rZW4taW1hZ2VcIi8+PC9zdmc+JztcbiAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDo6IGZlYXR1cmVzIGZsYWdzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHRha2VuIGZyb20gaHR0cHM6Ly9oYWNrcy5tb3ppbGxhLm9yZy8yMDExLzA5L2RldGVjdGluZy1hbmQtZ2VuZXJhdGluZy1cbiAgICAvLyBjc3MtYW5pbWF0aW9ucy1pbi1qYXZhc2NyaXB0L1xuICAgIHZhciBhbmltYXRpb25fc3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYW5pbWF0aW9uID0gZmFsc2UsXG4gICAgICAgICAgICBkb21QcmVmaXhlcyA9ICdXZWJraXQgTW96IE8gbXMgS2h0bWwnLnNwbGl0KCcgJyksXG4gICAgICAgICAgICBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaWYgKGVsbS5zdHlsZS5hbmltYXRpb25OYW1lKSB7XG4gICAgICAgICAgICBhbmltYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbVByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBkb21QcmVmaXhlc1tpXSArICdBbmltYXRpb25OYW1lJztcbiAgICAgICAgICAgICAgICBpZiAoZWxtLnN0eWxlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsbSA9IG51bGw7XG4gICAgICAgIHJldHVybiBhbmltYXRpb247XG4gICAgfSkoKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIGFnZW50ID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgdmFyIGlzX0lFID0gL01TSUV8VHJpZGVudC8udGVzdChhZ2VudCkgfHwgL3J2OjExLjAvaS50ZXN0KGFnZW50KTtcbiAgICB2YXIgaXNfSUVNb2JpbGUgPSAvSUVNb2JpbGUvLnRlc3QoYWdlbnQpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgaXNfY2hfdW5pdF9zdXBwb3J0ZWQgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChpc19JRSAmJiAhaXNfSUVNb2JpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpdi5zdHlsZS53aWR0aCA9ICcxY2gnO1xuICAgICAgICByZXR1cm4gZGl2LnN0eWxlLndpZHRoID09PSAnMWNoJztcbiAgICB9KSgpO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgaXNfY3NzX3ZhcmlhYmxlc19zdXBwb3J0ZWQgPSB3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1Muc3VwcG9ydHMgJiZcbiAgICAgICAgICAgIHdpbmRvdy5DU1Muc3VwcG9ydHMoJy0tZmFrZS12YXInLCAwKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIGlzX2FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIGlzX2tleV9uYXRpdmUgPSAoZnVuY3Rpb24gaXNfa2V5X25hdGl2ZSgpIHtcbiAgICAgICAgaWYgKCEoJ0tleWJvYXJkRXZlbnQnIGluIHdpbmRvdyAmJiAna2V5JyBpbiB3aW5kb3cuS2V5Ym9hcmRFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3RvID0gd2luZG93LktleWJvYXJkRXZlbnQucHJvdG90eXBlO1xuICAgICAgICB2YXIgZ2V0ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgJ2tleScpLmdldDtcbiAgICAgICAgcmV0dXJuICEhZ2V0LnRvU3RyaW5nKCkubWF0Y2goL1xcW25hdGl2ZSBjb2RlXFxdLyk7XG4gICAgfSkoKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIGlzX21vYmlsZSA9IChmdW5jdGlvbihhKSB7XG4gICAgICAgIHZhciBjaGVjayA9IGZhbHNlO1xuICAgICAgICBpZiAobW9iaWxlX3JlLnRlc3QoYSkgfHwgdGFibGV0X3JlLnRlc3QoYS5zdWJzdHIoMCwgNCkpKSB7XG4gICAgICAgICAgICBjaGVjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmEpO1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIElFIGNoIHVuaXQgYnVnIGRldGVjdGlvbiAtIGJldHRlciB0aGF0IFVzZXJBZ2VudCB0aGF0IGNhbiBiZSBjaGFuZ2VkXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBjaF91bml0X2J1ZyA9IGZhbHNlO1xuICAgICQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIHdpZHRoKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNlID0gJzxzcGFuIHN0eWxlPVwiZm9udC1mYW1pbHk6IG1vbm9zcGFjZTt2aXNpYmlsaXR5OmhpZGRlbjsnO1xuICAgICAgICB2YXIgY2ggPSAkKGJhc2UgKyAnd2lkdGg6MWNoO292ZXJmbG93OiBoaWRkZW5cIj4mbmJzcDs8L3NwYW4+JykuYXBwZW5kVG8oJ2JvZHknKTtcbiAgICAgICAgdmFyIHNwYWNlID0gJChiYXNlICsgJ1wiPiZuYnNwOzwvc3Bhbj4nKS5hcHBlbmRUbygnYm9keScpO1xuICAgICAgICBjaF91bml0X2J1ZyA9IHdpZHRoKGNoKSAhPT0gd2lkdGgoc3BhY2UpO1xuICAgICAgICBjaC5yZW1vdmUoKTtcbiAgICAgICAgc3BhY2UucmVtb3ZlKCk7XG4gICAgfSk7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiBoaWRlIGVsZW1lbnRzIGZyb20gc2NyZWVuIHJlYWRlcnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGExMXlfaGlkZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuYXR0cih7XG4gICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gOjogYWxlcnQgb25seSBmaXJzdCBleGNlcHRpb24gb2YgdHlwZVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBleGNlcGN0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIGFsZXJ0X2V4Y2VwdGlvbihsYWJlbCwgZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgJC50ZXJtaW5hbC5FeGNlcHRpb24pIHtcbiAgICAgICAgICAgIGxhYmVsID0gYXJndW1lbnRzWzBdLnR5cGU7XG4gICAgICAgICAgICBlID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXNzYWdlID0gKGxhYmVsID8gbGFiZWwgKyAnOiAnIDogJycpICsgZXhjZXB0aW9uX21lc3NhZ2UoZSk7XG4gICAgICAgIGlmIChleGNlcGN0aW9ucy5pbmRleE9mKG1lc3NhZ2UpID09PSAtMSkge1xuICAgICAgICAgICAgZXhjZXBjdGlvbnMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgLy9hbGVydChtZXNzYWdlICsgKGUuc3RhY2sgPyAnXFxuJyArIGUuc3RhY2sgOiAnJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDo7IGRldGVjdCBpZiBtb3VzZSBldmVudCBoYXBwZW4gb24gc2Nyb2xsYmFyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gc2Nyb2xsYmFyX2V2ZW50KGUsIG5vZGUpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBub2RlLm9mZnNldCgpLmxlZnQ7XG4gICAgICAgIHJldHVybiBub2RlLm91dGVyV2lkdGgoKSA8PSBlLmNsaWVudFggLSBsZWZ0O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiBSZXR1cm4gZXhjZXB0aW9uIG1lc3NhZ2UgYXMgc3RyaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gZXhjZXB0aW9uX21lc3NhZ2UoZSkge1xuICAgICAgICBpZiAodHlwZW9mIGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZS5maWxlTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmZpbGVOYW1lICsgJzogJyArIGUubWVzc2FnZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiBDWUNMRSBEQVRBIFNUUlVDVFVSRVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQ3ljbGUoKSB7XG4gICAgICAgIHZhciBkYXRhID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgJC5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByb3RhdGU6IGZ1bmN0aW9uKHNraXAsIGluaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBwb3M7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbml0ID09PSBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmluZWQgPSBkYXRhLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGl0ZW0gIT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWZpbmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gZGF0YS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytwb3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW3Bvc10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm90YXRlKHRydWUsIGluaXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YVtpbmRleF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRhdGEubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldID09PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHBvcyA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9udDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFkYXRhW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hcDogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24oaXRlbSwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oaXRlbSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvckVhY2g6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuKGl0ZW0sIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwZW5kOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLypcbiAgICBmdW5jdGlvbiB0aW1lKCkge1xuICAgICAgICAvLyBwZXJmb3JtYW5jZS5ub3cgYWxtb3N0IGVxdWFsIERhdGUubm93KCktIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnRcbiAgICAgICAgLy8gdGhlIGRpZmZlcmVuY2UgY2hlY2sgc2hvdWxkIGJlIGFsbW9zdCB0aGUgc2FtZVxuICAgICAgICByZXR1cm4gcGVyZm9ybWFuY2UgPyBwZXJmb3JtYW5jZS5ub3coKSA6IERhdGUubm93KCk7XG4gICAgfVxuICAgICovXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiBTVEFDSyBEQVRBIFNUUlVDVFVSRVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gU3RhY2soaW5pdCkge1xuICAgICAgICB2YXIgZGF0YSA9IGlzX2FycmF5KGluaXQpID8gaW5pdCA6IGluaXQgPyBbaW5pdF0gOiBbXTtcbiAgICAgICAgJC5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgZGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFwOiBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLm1hcChkYXRhLCBmbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdChbdmFsdWVdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGggPiAwID8gZGF0YVtkYXRhLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFjayhkYXRhLnNsaWNlKDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiBDbGFzcyBmb3IgV29ya2VyIHRoYXQgZG8gc29tZSBjb21wdXRhdGlvbiB3aGVuIG5lZWRlZFxuICAgIC8vIDo6IGlmIHZhbGlkYXRpb24gZnVuY3Rpb24gcmV0dXJuIGZhbHNlIGl0IG1lYW4gdGhhdCBjb25kaXRpb24gY2hhbmdlZFxuICAgIC8vIDo6IGFuZCBjYWNoZSBuZWVkIHRvIGJlIGNsZWFyZWQuIElmIHZhbHVlIHdhcyBub3QgcHJjZXNzZWQgaXQgd2lsbCBydW5cbiAgICAvLyA6OiB0aGUgYWN0aW9uXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFdvcmtlckNhY2hlKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogJC5ub29wLFxuICAgICAgICAgICAgYWN0aW9uOiAkLm5vb3AsXG4gICAgICAgICAgICBvbkNhY2hlOiAkLm5vb3BcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX29uQ2FjaGUgPSBzZXR0aW5ncy5vbkNhY2hlO1xuICAgICAgICB0aGlzLl9hY3Rpb24gPSBzZXR0aW5ncy5hY3Rpb247XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRpb24gPSBzZXR0aW5ncy52YWxpZGF0aW9uO1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIFdvcmtlckNhY2hlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsaWQgPSB0aGlzLl92YWxpZGF0aW9uKCk7XG4gICAgICAgIHZhciB0ZXN0ID0gdmFsaWQgPT09IHVuZGVmaW5lZCB8fCB2YWxpZCA9PT0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXN0O1xuICAgIH07XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIFdvcmtlckNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZSgpICYmIHRoaXMuX2NhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2NhY2hlLmdldChrZXkpO1xuICAgICAgICAgICAgdGhpcy5fb25DYWNoZSh7Y2FoY2U6IHZhbHVlfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB0aGlzLl9hY3Rpb24oa2V5KTtcbiAgICAgICAgdGhpcy5fY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gOjogSElTVE9SWSBDTEFTU1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBIaXN0b3J5KG5hbWUsIHNpemUsIG1lbW9yeSkge1xuICAgICAgICB2YXIgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHZhciBzdG9yYWdlX2tleSA9ICcnO1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIG5hbWUgIT09ICcnKSB7XG4gICAgICAgICAgICBzdG9yYWdlX2tleSA9IG5hbWUgKyAnXyc7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmFnZV9rZXkgKz0gJ2NvbW1hbmRzJztcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChtZW1vcnkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSAkLlN0b3JhZ2UuZ2V0KHN0b3JhZ2Vfa2V5KTtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhID8gSlNPTi5wYXJzZShkYXRhKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb3MgPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICAgICQuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIGFwcGVuZDogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2RhdGEubGVuZ3RoIC0gMV0gIT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplICYmIGRhdGEubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKC1zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVtb3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5TdG9yYWdlLnNldChzdG9yYWdlX2tleSwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24obmV3X2RhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNfYXJyYXkobmV3X2RhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXdfZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZW1vcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuU3RvcmFnZS5zZXQoc3RvcmFnZV9rZXksIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zID09PSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VycmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFbcG9zXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkID0gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPCBkYXRhLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgKytwb3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvbGQgIT09IHBvcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmV2aW91czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZCA9IHBvcztcbiAgICAgICAgICAgICAgICBpZiAocG9zID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAtLXBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9sZCAhPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5wdXJnZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmFibGVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHVyZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghbWVtb3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICQuU3RvcmFnZS5yZW1vdmUoc3RvcmFnZV9rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQgPSAhZW5hYmxlZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDo6IENPTU1BTkQgTElORSBQTFVHSU5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIGNtZF9pbmRleCA9IDA7XG4gICAgJC5jbWQgPSB7XG4gICAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgICAgICBtYXNrOiBmYWxzZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmVTZWFyY2g6IHRydWUsXG4gICAgICAgICAgICBoaXN0b3J5U2l6ZTogNjAsXG4gICAgICAgICAgICBwcm9tcHQ6ICc+ICcsXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgaGlzdG9yeTogdHJ1ZSxcbiAgICAgICAgICAgIG9uUG9zaXRpb25DaGFuZ2U6ICQubm9vcCxcbiAgICAgICAgICAgIG9uQ29tbWFuZENoYW5nZTogJC5ub29wLFxuICAgICAgICAgICAgaW5wdXRTdHlsZTogJ3RleHRhcmVhJyxcbiAgICAgICAgICAgIG1vYmlsZURlbGV0ZTogaXNfbW9iaWxlLFxuICAgICAgICAgICAgb25QYXN0ZTogJC5ub29wLFxuICAgICAgICAgICAgY2xpY2tUaW1lb3V0OiAyMDAsXG4gICAgICAgICAgICBob2xkVGltZW91dDogNDAwLFxuICAgICAgICAgICAgaG9sZFJlcGVhdFRpbWVvdXQ6IDIwMCxcbiAgICAgICAgICAgIG1vYmlsZUluZ29yZUF1dG9TcGFjZTogW10sXG4gICAgICAgICAgICByZXBlYXRUaW1lb3V0S2V5czogW10sXG4gICAgICAgICAgICB0YWJpbmRleDogMSxcbiAgICAgICAgICAgIHRhYnM6IDRcbiAgICAgICAgfVxuICAgIH07XG4gICAgJC5mbi5jbWQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCAkLmNtZC5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgIGZ1bmN0aW9uIG1vYmlsZV9pZ25vcmVfa2V5KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1vYmlsZUluZ29yZUF1dG9TcGFjZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5tb2JpbGVJbmdvcmVBdXRvU3BhY2UuaW5kZXhPZihrZXkpICE9PSAtMSAmJiBpc19hbmRyb2lkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG1heWJlX2RhdGEgPSBzZWxmLmRhdGEoJ2NtZCcpO1xuICAgICAgICBpZiAobWF5YmVfZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG1heWJlX2RhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkID0gY21kX2luZGV4Kys7XG4gICAgICAgIHNlbGYuYWRkQ2xhc3MoJ2NtZCcpO1xuICAgICAgICB2YXIgd3JhcHBlciA9ICQoJzxkaXYgY2xhc3M9XCJjbWQtd3JhcHBlclwiLz4nKS5hcHBlbmRUbyhzZWxmKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmQoJzxzcGFuIGNsYXNzPVwiY21kLXByb21wdFwiPjwvc3Bhbj4nKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmQoJzxkaXYgY2xhc3M9XCJjbWQtY3Vyc29yLWxpbmVcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuPjwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiY21kLWN1cnNvclwiPjxzcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4+Jm5ic3A7PC9zcGFuPjwvc3Bhbj48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICc8c3Bhbj48L3NwYW4+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nKTtcbiAgICAgICAgLy8gYTExeTogZG9uJ3QgcmVhZCBjb21tYW5kIGl0J3MgaW4gdGV4dGFyZWEgdGhhdCdzIGluIGZvY3VzXG4gICAgICAgIGExMXlfaGlkZSh3cmFwcGVyLmZpbmQoJy5jbWQtY3Vyc29yLWxpbmUnKSk7XG4gICAgICAgIC8vIG9uIG1vYmlsZSB0aGUgb25seSB3YXkgdG8gaGlkZSB0ZXh0YXJlYSBvbiBkZXNrdG9wIGl0J3MgbmVlZGVkIGJlY2F1c2VcbiAgICAgICAgLy8gdGV4dGFyZWEgc2hvdyB1cCBhZnRlciBmb2N1c1xuICAgICAgICAvL3NlbGYuYXBwZW5kKCc8c3BhbiBjbGFzcz1cIm1hc2tcIj48L21hc2s+Jyk7XG4gICAgICAgIHZhciBjbGlwID0gJCgnPHRleHRhcmVhPicpLmF0dHIoe1xuICAgICAgICAgICAgYXV0b2NhcGl0YWxpemU6ICdvZmYnLFxuICAgICAgICAgICAgc3BlbGxjaGVjazogJ2ZhbHNlJyxcbiAgICAgICAgICAgIHRhYmluZGV4OiBzZXR0aW5ncy50YWJpbmRleFxuICAgICAgICB9KS5hZGRDbGFzcygnY21kLWNsaXBib2FyZCcpLmFwcGVuZFRvKHNlbGYpO1xuICAgICAgICBpZiAoIWlzX21vYmlsZSkge1xuICAgICAgICAgICAgY2xpcC52YWwoJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3Mud2lkdGgpIHtcbiAgICAgICAgICAgIHNlbGYud2lkdGgoc2V0dGluZ3Mud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1fY2hhcnM7IC8vIGNhbGN1bGF0ZWQgYnkgcmVzaXplXG4gICAgICAgIHZhciBjaGFyX3dpZHRoO1xuICAgICAgICB2YXIgbGFzdF9yZW5kZXJlZF9wcm9tcHQ7XG4gICAgICAgIHZhciBwcm9tcHRfbGFzdF9saW5lO1xuICAgICAgICB2YXIgcHJvbXB0X2xlbjtcbiAgICAgICAgdmFyIHByb21wdF9ub2RlID0gc2VsZi5maW5kKCcuY21kLXByb21wdCcpO1xuICAgICAgICB2YXIgcmV2ZXJzZV9zZWFyY2ggPSBmYWxzZTtcbiAgICAgICAgdmFyIHJldl9zZWFyY2hfc3RyID0gJyc7XG4gICAgICAgIHZhciByZXZlcnNlX3NlYXJjaF9wb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHZhciBiYWNrdXBfcHJvbXB0O1xuICAgICAgICAvLyBUT0RPOiB0cnkgdG8gdXNlIHdvcmtlckNhY2hlIHdpdGggZGF0YSB0aGF0IGRvbid0IGNoYW5nZSBsaWtlIGJhcmVfdGV4dFxuICAgICAgICAvLyBvciBmb3JtYXQgZnVuY3Rpb24uXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB3b3JrZXJDYWNoZSBmb3IgZm9ybWF0dGVycyB0aGV5IHJlcXVpcmUgZHluYW1pY1xuICAgICAgICAvLyB2YWx1ZSBvZiBwb3NpdGlvbiBzbyBkYXRhIGNoYW5nZSB3aGVuIHlvdSBtb3ZlIGN1cnNvclxuICAgICAgICAvKlxuICAgICAgICB2YXIgZm9ybWF0dGVyID0gbmV3IFdvcmtlckNhY2hlKHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mb3JtYXR0ZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3QgPSB0aGlzLl9mb3JtYXR0ZXJzLmV2ZXJ5KGZ1bmN0aW9uKGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLnRlcm1pbmFsLmRlZmF1bHRzLmZvcm1hdHRlcnNbaV0gPT09IGU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlcnMgPSAkLnRlcm1pbmFsLmRlZmF1bHRzLmZvcm1hdHRlcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ2FjaGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY291bnRlciA9IHRoaXMuX2NvdW50ZXIgfHwgMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3VudGVyKys7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lcyA9IHRoaXMuX3RpbWVzIHx8IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0MCA9IHRpbWUoKTtcbiAgICAgICAgICAgICAgICAvLyBzb21lIG9wdGltaXphdGlvbiAtIGRvbid0IGNoYW5nZSBvYmplY3Qgc2hhcGUgYW5kIHJlZlxuICAgICAgICAgICAgICAgIGZvcm1hdF9vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gJC50ZXJtaW5hbC5lc2NhcGVfZm9ybWF0dGluZyhzdHJpbmcpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICQudGVybWluYWwuYXBwbHlfZm9ybWF0dGVycyhzdHJpbmcsIGZvcm1hdF9vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSB0aW1lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZXMucHVzaCh0MSAtIHQwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAqL1xuICAgICAgICB2YXIgY29tbWFuZCA9ICcnO1xuICAgICAgICB2YXIgbGFzdF9jb21tYW5kO1xuICAgICAgICAvLyB0ZXh0IGZyb20gc2VsZWN0aW9uIHVzaW5nIENUUkwrU0hJRlQrQyAoYXMgaW4gWHRlcm0pXG4gICAgICAgIHZhciBraWxsX3RleHQgPSAnJzsgLy8gdGV4dCBmcm9tIGNvbW1hbmQgdGhhdCBraWxsIHBhcnQgb2YgdGhlIGNvbW1hbmRcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICAgICAgdmFyIHByb21wdDtcbiAgICAgICAgdmFyIGVuYWJsZWQ7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRfcG9zaXRpb24gPSAwO1xuICAgICAgICB2YXIgbmFtZSwgaGlzdG9yeTtcbiAgICAgICAgdmFyIGN1cnNvciA9IHNlbGYuZmluZCgnLmNtZC1jdXJzb3InKTtcbiAgICAgICAgdmFyIGFuaW1hdGlvbjtcbiAgICAgICAgdmFyIHJlc3RhcnRfYW5pbWF0aW9uO1xuICAgICAgICB2YXIgcGFzdGVfY291bnQgPSAwO1xuICAgICAgICAvLyB1c2UgXFx1RkZGRiB0byBtYXJrIG5ld2xpbmUgZXh0cmEgY2hhcmFjdGVyXG4gICAgICAgIC8vIHNvIHdlIGNhbiBoaWRlIGl0IGJ5IGNzcyB3aGVuIHVzaW5nIHRleHQgc2VsZWN0aW9uXG4gICAgICAgIHZhciBsaW5lX21hcmtlciA9ICdcXHVGRkZGJztcbiAgICAgICAgdmFyIGxpbmVfbWFya2VyX3JlID0gL1xcdUZGRkYkLztcbiAgICAgICAgZnVuY3Rpb24gZ2V0X2NoYXJfcG9zKGUpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gJChlLnRhcmdldCk7XG4gICAgICAgICAgICBpZiAobm9kZS5pcygnc3BhbixpbWcsYScpKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2xvc2VzdCgnW2RhdGEtdGV4dF0nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5pbmRleCgpICtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQoJ3NwYW4nKS5wcmV2QWxsKCkuZmluZCgnW2RhdGEtdGV4dF0nKS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNsb3Nlc3QoJ1tyb2xlPVwicHJlc2VudGF0aW9uXCJdJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wcmV2VW50aWwoJy5jbWQtcHJvbXB0JykuZmluZCgnW2RhdGEtdGV4dF0nKS5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaXMoJ2Rpdltyb2xlPVwicHJlc2VudGF0aW9uXCJdJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9ICFub2RlLm5leHQoKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZmluZCgnW2RhdGEtdGV4dF0nKS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICBub2RlLnByZXZVbnRpbCgnLmNtZC1wcm9tcHQnKS5maW5kKCdbZGF0YS10ZXh0XScpLmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICAgIChsYXN0ID8gMCA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElFIG1hcHBpbmdcbiAgICAgICAgdmFyIGtleV9tYXBwaW5nID0ge1xuICAgICAgICAgICAgJ1NQQUNFQkFSJzogJyAnLFxuICAgICAgICAgICAgJ1VQJzogJ0Fycm93VVAnLFxuICAgICAgICAgICAgJ0RPV04nOiAnQXJyb3dEb3duJyxcbiAgICAgICAgICAgICdMRUZUJzogJ0Fycm93TGVmdCcsXG4gICAgICAgICAgICAnUklHSFQnOiAnQXJyb3dSaWdodCcsXG4gICAgICAgICAgICAnREVMJzogJ0RlbGV0ZScsXG4gICAgICAgICAgICAnTVVMVElQTFknOiAnKicsXG4gICAgICAgICAgICAnRElWSURFJzogJy8nLFxuICAgICAgICAgICAgJ1NVQlRSQUNUJzogJy0nLFxuICAgICAgICAgICAgJ0FERCc6ICcrJ1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBpZV9rZXlfZml4KGUpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBlLmtleS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGtleV9tYXBwaW5nW2tleV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5X21hcHBpbmdba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0X2tleShlKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gaWVfa2V5X2ZpeChlKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdDT05UUk9MJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0NUUkwnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21ibyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21iby5wdXNoKCdDVFJMJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubWV0YUtleSAmJiBrZXkgIT09ICdNRVRBJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tYm8ucHVzaCgnTUVUQScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5ICYmIGtleSAhPT0gJ1NISUZUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tYm8ucHVzaCgnU0hJRlQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5hbHRLZXkgJiYga2V5ICE9PSAnQUxUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tYm8ucHVzaCgnQUxUJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbWJvLmxlbmd0aCAmJiBrZXkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gJ1NQQUNFQkFSJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbWJvLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tYm8uam9pbignKycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBmb3IgaW52b2tpbmcgc2hvcnRjdXRzIHVzaW5nIHRlcm1pbmFsOjprZXlkb3duXG4gICAgICAgIC8vIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2N2YW4va2V5Ym9hcmRldmVudC1rZXktcG9seWZpbGwvXG4gICAgICAgIHZhciBrZXljb2RlcyA9IHtcbiAgICAgICAgICAgIDM6ICdDYW5jZWwnLFxuICAgICAgICAgICAgNjogJ0hlbHAnLFxuICAgICAgICAgICAgODogJ0JhY2tzcGFjZScsXG4gICAgICAgICAgICA5OiAnVGFiJyxcbiAgICAgICAgICAgIDEyOiAnQ2xlYXInLFxuICAgICAgICAgICAgMTM6ICdFbnRlcicsXG4gICAgICAgICAgICAxNjogJ1NoaWZ0JyxcbiAgICAgICAgICAgIDE3OiAnQ29udHJvbCcsXG4gICAgICAgICAgICAxODogJ0FsdCcsXG4gICAgICAgICAgICAxOTogJ1BhdXNlJyxcbiAgICAgICAgICAgIDIwOiAnQ2Fwc0xvY2snLFxuICAgICAgICAgICAgMjc6ICdFc2NhcGUnLFxuICAgICAgICAgICAgMjg6ICdDb252ZXJ0JyxcbiAgICAgICAgICAgIDI5OiAnTm9uQ29udmVydCcsXG4gICAgICAgICAgICAzMDogJ0FjY2VwdCcsXG4gICAgICAgICAgICAzMTogJ01vZGVDaGFuZ2UnLFxuICAgICAgICAgICAgMzI6ICcgJyxcbiAgICAgICAgICAgIDMzOiAnUGFnZVVwJyxcbiAgICAgICAgICAgIDM0OiAnUGFnZURvd24nLFxuICAgICAgICAgICAgMzU6ICdFbmQnLFxuICAgICAgICAgICAgMzY6ICdIb21lJyxcbiAgICAgICAgICAgIDM3OiAnQXJyb3dMZWZ0JyxcbiAgICAgICAgICAgIDM4OiAnQXJyb3dVcCcsXG4gICAgICAgICAgICAzOTogJ0Fycm93UmlnaHQnLFxuICAgICAgICAgICAgNDA6ICdBcnJvd0Rvd24nLFxuICAgICAgICAgICAgNDE6ICdTZWxlY3QnLFxuICAgICAgICAgICAgNDI6ICdQcmludCcsXG4gICAgICAgICAgICA0MzogJ0V4ZWN1dGUnLFxuICAgICAgICAgICAgNDQ6ICdQcmludFNjcmVlbicsXG4gICAgICAgICAgICA0NTogJ0luc2VydCcsXG4gICAgICAgICAgICA0NjogJ0RlbGV0ZScsXG4gICAgICAgICAgICA0ODogWycwJywgJyknXSxcbiAgICAgICAgICAgIDQ5OiBbJzEnLCAnISddLFxuICAgICAgICAgICAgNTA6IFsnMicsICdAJ10sXG4gICAgICAgICAgICA1MTogWyczJywgJyMnXSxcbiAgICAgICAgICAgIDUyOiBbJzQnLCAnJCddLFxuICAgICAgICAgICAgNTM6IFsnNScsICclJ10sXG4gICAgICAgICAgICA1NDogWyc2JywgJ14nXSxcbiAgICAgICAgICAgIDU1OiBbJzcnLCAnJiddLFxuICAgICAgICAgICAgNTY6IFsnOCcsICcqJ10sXG4gICAgICAgICAgICA1NzogWyc5JywgJygnXSxcbiAgICAgICAgICAgIDkxOiAnT1MnLFxuICAgICAgICAgICAgOTM6ICdDb250ZXh0TWVudScsXG4gICAgICAgICAgICAxNDQ6ICdOdW1Mb2NrJyxcbiAgICAgICAgICAgIDE0NTogJ1Njcm9sbExvY2snLFxuICAgICAgICAgICAgMTgxOiAnVm9sdW1lTXV0ZScsXG4gICAgICAgICAgICAxODI6ICdWb2x1bWVEb3duJyxcbiAgICAgICAgICAgIDE4MzogJ1ZvbHVtZVVwJyxcbiAgICAgICAgICAgIDE4NjogWyc7JywgJzonXSxcbiAgICAgICAgICAgIDE4NzogWyc9JywgJysnXSxcbiAgICAgICAgICAgIDE4ODogWycsJywgJzwnXSxcbiAgICAgICAgICAgIDE4OTogWyctJywgJ18nXSxcbiAgICAgICAgICAgIDE5MDogWycuJywgJz4nXSxcbiAgICAgICAgICAgIDE5MTogWycvJywgJz8nXSxcbiAgICAgICAgICAgIDE5MjogWydgJywgJ34nXSxcbiAgICAgICAgICAgIDIxOTogWydbJywgJ3snXSxcbiAgICAgICAgICAgIDIyMDogWydcXFxcJywgJ3wnXSxcbiAgICAgICAgICAgIDIyMTogWyddJywgJ30nXSxcbiAgICAgICAgICAgIDIyMjogW1wiJ1wiLCAnXCInXSxcbiAgICAgICAgICAgIDIyNDogJ01ldGEnLFxuICAgICAgICAgICAgMjI1OiAnQWx0R3JhcGgnLFxuICAgICAgICAgICAgMjQ2OiAnQXR0bicsXG4gICAgICAgICAgICAyNDc6ICdDclNlbCcsXG4gICAgICAgICAgICAyNDg6ICdFeFNlbCcsXG4gICAgICAgICAgICAyNDk6ICdFcmFzZUVvZicsXG4gICAgICAgICAgICAyNTA6ICdQbGF5JyxcbiAgICAgICAgICAgIDI1MTogJ1pvb21PdXQnXG4gICAgICAgIH07XG4gICAgICAgIHZhciBpO1xuICAgICAgICAvLyBGdW5jdGlvbiBrZXlzIChGMS0yNCkuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCAyNTsgaSsrKSB7XG4gICAgICAgICAgICBrZXljb2Rlc1sxMTEgKyBpXSA9ICdGJyArIGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlcnMuXG4gICAgICAgIHZhciBsZXR0ZXIgPSAnJztcbiAgICAgICAgZm9yIChpID0gNjU7IGkgPCA5MTsgaSsrKSB7XG4gICAgICAgICAgICBsZXR0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgICAgICAga2V5Y29kZXNbaV0gPSBbbGV0dGVyLnRvTG93ZXJDYXNlKCksIGxldHRlci50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV2ZXJzZWRfa2V5Y29kZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoa2V5Y29kZXMpLmZvckVhY2goZnVuY3Rpb24od2hpY2gpIHtcbiAgICAgICAgICAgIGlmIChpc19hcnJheShrZXljb2Rlc1t3aGljaF0pKSB7XG4gICAgICAgICAgICAgICAga2V5Y29kZXNbd2hpY2hdLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VkX2tleWNvZGVzW2tleS50b1VwcGVyQ2FzZSgpXSA9IHdoaWNoO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXZlcnNlZF9rZXljb2Rlc1trZXljb2Rlc1t3aGljaF0udG9VcHBlckNhc2UoKV0gPSB3aGljaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHZhciBrZXltYXA7XG4gICAgICAgIHZhciBkZWZhdWx0X2tleW1hcCA9IHtcbiAgICAgICAgICAgICdBTFQrRCc6IGRlbGV0ZV9mb3J3YXJkKHtjbGlwYm9hcmQ6IHRydWV9KSxcbiAgICAgICAgICAgICdIT0xEK0FMVCtEJzogZGVsZXRlX2ZvcndhcmQoe2NsaXBib2FyZDogdHJ1ZSwgaG9sZDogdHJ1ZX0pLFxuICAgICAgICAgICAgJ0hPTEQrREVMRVRFJzogZGVsZXRlX2ZvcndhcmQoe2NsaXBib2FyZDogZmFsc2UsIGhvbGQ6IHRydWV9KSxcbiAgICAgICAgICAgICdIT0xEK1NISUZUK0RFTEVURSc6IGRlbGV0ZV9mb3J3YXJkKHtjbGlwYm9hcmQ6IGZhbHNlLCBob2xkOiB0cnVlfSksXG4gICAgICAgICAgICAnRU5URVInOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGlzdG9yeSAmJiBjb21tYW5kICYmICFzZXR0aW5ncy5tYXNrICYmXG4gICAgICAgICAgICAgICAgICAgICgoaXNfZnVuY3Rpb24oc2V0dGluZ3MuaGlzdG9yeUZpbHRlcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5oaXN0b3J5RmlsdGVyKGNvbW1hbmQpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzLmhpc3RvcnlGaWx0ZXIgaW5zdGFuY2VvZiBSZWdFeHAgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kLm1hdGNoKHNldHRpbmdzLmhpc3RvcnlGaWx0ZXIpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIXNldHRpbmdzLmhpc3RvcnlGaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpc3RvcnkuYXBwZW5kKGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gY29tbWFuZDtcbiAgICAgICAgICAgICAgICBoaXN0b3J5LnJlc2V0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBmb3IgbmV4dCBpbnB1dCBldmVudCBvbiBmaXJlZm94L2FuZHJvaWQgd2l0aCBnb29nbGUga2V5Ym9hcmRcbiAgICAgICAgICAgICAgICBwcmV2X2NvbW1hbmQgPSAnJztcbiAgICAgICAgICAgICAgICBub19rZXlkb3duID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHNlbGYuc2V0KCcnKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuY29tbWFuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHNldHRpbmdzLmNvbW1hbmRzLmNhbGwoc2VsZiwgdG1wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKHByb21wdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2UgJiYgaXNfZnVuY3Rpb24ocHJvbWlzZS50aGVuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGRyYXdfcHJvbXB0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdfcHJvbXB0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xpcC52YWwoJycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnU0hJRlQrRU5URVInOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmluc2VydCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ0JBQ0tTUEFDRSc6IGJhY2tzcGFjZV9rZXksXG4gICAgICAgICAgICAnU0hJRlQrQkFDS1NQQUNFJzogYmFja3NwYWNlX2tleSxcbiAgICAgICAgICAgICdUQUInOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmluc2VydCgnXFx0Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ0NUUkwrRCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGZbJ2RlbGV0ZSddKDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnREVMRVRFJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZlsnZGVsZXRlJ10oMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ0hPTEQrQVJST1dVUCc6IHVwX2Fycm93LFxuICAgICAgICAgICAgJ0FSUk9XVVAnOiB1cF9hcnJvdyxcbiAgICAgICAgICAgICdDVFJMK1AnOiBwcmV2X2hpc3RvcnksXG4gICAgICAgICAgICAnQVJST1dET1dOJzogZG93bl9hcnJvdyxcbiAgICAgICAgICAgICdIT0xEK0FSUk9XRE9XTic6IGRvd25fYXJyb3csXG4gICAgICAgICAgICAnQ1RSTCtOJzogbmV4dF9oaXN0b3J5LFxuICAgICAgICAgICAgJ0FSUk9XTEVGVCc6IGxlZnQsXG4gICAgICAgICAgICAnSE9MRCtBUlJPV0xFRlQnOiBkZWJvdW5jZShsZWZ0LCAxMCksXG4gICAgICAgICAgICAnQ1RSTCtCJzogbGVmdCxcbiAgICAgICAgICAgICdDVFJMK0FSUk9XTEVGVCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGp1bXAgdG8gb25lIGNoYXJhY3RlciBhZnRlciBsYXN0IHNwYWNlIGJlZm9yZSBwcmV2b2l1cyB3b3JkXG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBvc2l0aW9uIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZFtsZW5dID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgLS1sZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBsZW47IGkgPiAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmRbaV0gPT09ICcgJyAmJiBjb21tYW5kW2kgKyAxXSAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmRbaV0gPT09ICdcXG4nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZFtpICsgMV0gIT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5wb3NpdGlvbihwb3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdDVFJMK1InOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV2ZXJzZV9zZWFyY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZV9oaXN0b3J5X3NlYXJjaCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiYWNrdXBfcHJvbXB0ID0gcHJvbXB0O1xuICAgICAgICAgICAgICAgICAgICBkcmF3X3JldmVyc2VfcHJvbXB0KCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RfY29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2Vfc2VhcmNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdDVFJMK0cnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV2ZXJzZV9zZWFyY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0ID0gYmFja3VwX3Byb21wdDtcbiAgICAgICAgICAgICAgICAgICAgZHJhd19wcm9tcHQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXQobGFzdF9jb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2Vfc2VhcmNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldl9zZWFyY2hfc3RyID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ0FSUk9XUklHSFQnOiByaWdodCxcbiAgICAgICAgICAgICdIT0xEK0FSUk9XUklHSFQnOiBkZWJvdW5jZShyaWdodCwgMTApLFxuICAgICAgICAgICAgJ0NUUkwrRic6IHJpZ2h0LFxuICAgICAgICAgICAgJ0NUUkwrQVJST1dSSUdIVCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGp1bXAgdG8gYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgd29yZFxuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kW3Bvc2l0aW9uXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgICsrcG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZSA9IC9cXFNbXFxuXFxzXXsyLH18W1xcblxcc10rXFxTPy87XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gY29tbWFuZC5zbGljZShwb3NpdGlvbikubWF0Y2gocmUpO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2ggfHwgbWF0Y2hbMF0ubWF0Y2goL15cXHMrJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucG9zaXRpb24odGV4dChjb21tYW5kKS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMF1bMF0gIT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSBtYXRjaC5pbmRleCArIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMF1bbWF0Y2hbMF0ubGVuZ3RoIC0gMV0gIT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWRyYXcoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnRjEyJzogcmV0dXJuX3RydWUsIC8vIEFsbG93IEZpcmVidWdcbiAgICAgICAgICAgICdFTkQnOiBlbmQodHJ1ZSksXG4gICAgICAgICAgICAnQ1RSTCtFTkQnOiBlbmQoKSxcbiAgICAgICAgICAgICdDVFJMK0UnOiBlbmQoKSxcbiAgICAgICAgICAgICdIT01FJzogaG9tZSh0cnVlKSxcbiAgICAgICAgICAgICdDVFJMK0hPTUUnOiBob21lKCksXG4gICAgICAgICAgICAnQ1RSTCtBJzogaG9tZSgpLFxuICAgICAgICAgICAgJ1NISUZUK0lOU0VSVCc6IHBhc3RlX2V2ZW50LFxuICAgICAgICAgICAgJ0NUUkwrU0hJRlQrVCc6IHJldHVybl90cnVlLCAvLyBvcGVuIGNsb3NlZCB0YWJcbiAgICAgICAgICAgICdDVFJMK1cnOiBkZWxldGVfYmFja3dhcmQoe2NsaXBib2FyZDogdHJ1ZSwgaG9sZDogZmFsc2V9KSxcbiAgICAgICAgICAgICdIT0xEK0JBQ0tTUEFDRSc6IGRlbGV0ZV9iYWNrd2FyZCh7Y2xpcGJvYXJkOiBmYWxzZSwgaG9sZDogdHJ1ZX0pLFxuICAgICAgICAgICAgJ0hPTEQrU0hJRlQrQkFDS1NQQUNFJzogZGVsZXRlX2JhY2t3YXJkKHtjbGlwYm9hcmQ6IGZhbHNlLCBob2xkOiB0cnVlfSksXG4gICAgICAgICAgICAnQ1RSTCtIJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQgIT09ICcnICYmIHBvc2l0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmWydkZWxldGUnXSgtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnQ1RSTCtYJzogcmV0dXJuX3RydWUsXG4gICAgICAgICAgICAnQ1RSTCtDJzogcmV0dXJuX3RydWUsXG4gICAgICAgICAgICAnQ1RSTCtUJzogcmV0dXJuX3RydWUsXG4gICAgICAgICAgICAnQ1RSTCtZJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtpbGxfdGV4dCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnNlcnQoa2lsbF90ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ0NUUkwrVic6IHBhc3RlX2V2ZW50LFxuICAgICAgICAgICAgJ01FVEErVic6IHBhc3RlX2V2ZW50LFxuICAgICAgICAgICAgJ0NUUkwrSyc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSB0ZXh0KGNvbW1hbmQpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAga2lsbF90ZXh0ID0gc2VsZlsnZGVsZXRlJ10obGVuIC0gcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0X3RvX2NsaXBib2FyZChjbGlwLCBraWxsX3RleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ0NUUkwrVSc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kICE9PSAnJyAmJiBwb3NpdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBraWxsX3RleHQgPSBzZWxmWydkZWxldGUnXSgtcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0X3RvX2NsaXBib2FyZChjbGlwLCBraWxsX3RleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ0NUUkwrVEFCJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdNRVRBK2AnOiByZXR1cm5fdHJ1ZSwgLy8gQ01EK2Agc3dpdGNoIGJyb3dzZXIgd2luZG93IG9uIE1hY1xuICAgICAgICAgICAgJ01FVEErUic6IHJldHVybl90cnVlLCAvLyBDTUQrUiBwYWdlIHJlbG9hZCBpbiBDaHJvbWUgTWFjXG4gICAgICAgICAgICAnTUVUQStMJzogcmV0dXJuX3RydWUgLy8gQ0xEK0wganVtcCBpbnRvIE9taW5ib3ggb24gQ2hyb21lIE1hY1xuICAgICAgICB9O1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIGRlbGV0ZV9mb3J3YXJkKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaG9sZCAmJiAhc2V0dGluZ3MubW9iaWxlRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGV0ZV9jaGFyYWN0ZXJfZm9yd2FyZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZlsnZGVsZXRlJ10oMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGV0ZV93b3JkX2ZvcndhcmQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlID0gLyAqW14gXSsgKig/PSApfFteIF0rJC87XG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0cmluZyA9IGNvbW1hbmQuc2xpY2UocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHZhciBtID0gc3Vic3RyaW5nLm1hdGNoKHJlKTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBraWxsX3RleHQgPSBtWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jbGlwYm9hcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfdG9fY2xpcGJvYXJkKGNsaXAsIGtpbGxfdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5zZXQoXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQuc2xpY2UoMCwgcG9zaXRpb24pICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQuc2xpY2UocG9zaXRpb24pLnJlcGxhY2UocmUsICcnKSxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gY2hyb21lIGp1bXAgdG8gYWRkcmVzcyBiYXJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gZGVsZXRlX2JhY2t3YXJkKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaG9sZCAmJiAhc2V0dGluZ3MubW9iaWxlRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGV0ZV9jaGFyYWN0ZXJfYmFja3dhcmQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGZbJ2RlbGV0ZSddKC0xKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGV0ZV93b3JkX2JhY2t3YXJkKCkge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IHdvcmsgaW4gQ2hyb21pdW0gKGNhbid0IHByZXZlbnQgY2xvc2UgdGFiKVxuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kICE9PSAnJyAmJiBwb3NpdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGNvbW1hbmQuc2xpY2UoMCwgcG9zaXRpb24pLm1hdGNoKC8oW14gXSogKiQpLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2lsbF90ZXh0ID0gc2VsZlsnZGVsZXRlJ10oLW1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNsaXBib2FyZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfdG9fY2xpcGJvYXJkKGNsaXAsIGtpbGxfdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIHJldHVybl90cnVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBwYXN0ZV9ldmVudCgpIHtcbiAgICAgICAgICAgIGNsaXAudmFsKCcnKTtcbiAgICAgICAgICAgIHBhc3RlX2NvdW50ID0gMDtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzZW5hYmxlZCgpICYmICFjbGlwLmlzKCc6Zm9jdXMnKSkge1xuICAgICAgICAgICAgICAgIGNsaXAudHJpZ2dlcignZm9jdXMnLCBbdHJ1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xpcC5vbmUoJ2lucHV0JywgcGFzdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IFBhc3RlIGNvbnRlbnQgdG8gdGVybWluYWwgdXNpbmcgaGlkZGVuIHRleHRhcmVhXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBwYXN0ZSgpIHtcbiAgICAgICAgICAgIGlmIChwYXN0ZV9jb3VudCsrID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgICAgICAgICBjbGlwLnZhbChjb21tYW5kKTtcbiAgICAgICAgICAgICAgICBmaXhfdGV4dGFyZWEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGluc2VydCh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnNlcnQodGV4dCk7XG4gICAgICAgICAgICAgICAgc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5pc2VuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIC8vd2FpdCB1bnRpbCBCcm93c2VyIGluc2VydCB0ZXh0IHRvIHRleHRhcmVhXG4gICAgICAgICAgICAgICAgc2VsZi5vbmVUaW1lKDEwMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNsaXAudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihzZXR0aW5ncy5vblBhc3RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IHNldHRpbmdzLm9uUGFzdGUuY2FsbChzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBzZWxmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgJiYgaXNfZnVuY3Rpb24ocmV0LnRoZW4gfHwgcmV0LmRvbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXQudGhlbiB8fCByZXQuZG9uZSkuY2FsbChyZXQsIGluc2VydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQocmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gcHJldl9oaXN0b3J5KCkge1xuICAgICAgICAgICAgaWYgKGZpcnN0X3VwX2hpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICBsYXN0X2NvbW1hbmQgPSBjb21tYW5kO1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0KGhpc3RvcnkuY3VycmVudCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXQoaGlzdG9yeS5wcmV2aW91cygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcnN0X3VwX2hpc3RvcnkgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIG5leHRfaGlzdG9yeSgpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0KGhpc3RvcnkuZW5kKCkgPyBsYXN0X2NvbW1hbmQgOiBoaXN0b3J5Lm5leHQoKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBoYXZlX25ld2xpbmVzKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaCgvXFxuLyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBtYXRjaF9jb2x1bW4ocmUsIHN0cmluZywgY29sKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2gocmUpO1xuICAgICAgICAgICAgaWYgKGhhdmVfbmV3bGluZXMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXS5sZW5ndGggPD0gY29sO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0ubGVuZ3RoIDw9IGNvbCAtIHByb21wdF9sZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiB1cF9hcnJvdygpIHtcbiAgICAgICAgICAgIHZhciBiZWZvcmUgPSBjb21tYW5kLnN1YnN0cmluZygwLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgcmUgPSAvXFxuPyhbXlxcbl0rKSQvO1xuICAgICAgICAgICAgdmFyIGNvbCA9IHNlbGYuY29sdW1uKCk7XG4gICAgICAgICAgICBpZiAoaGF2ZV9uZXdsaW5lcyhiZWZvcmUpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGJlZm9yZS5sZW5ndGggLSBjb2wgLSAxOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyID0gYmVmb3JlLnN1YnN0cmluZygwLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoX2NvbHVtbihyZSwgc3RyLCBjb2wpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnBvc2l0aW9uKGkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZfaGlzdG9yeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gZG93bl9hcnJvdygpIHtcbiAgICAgICAgICAgIHZhciBhZnRlciA9IGNvbW1hbmQuc3Vic3RyaW5nKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhciBjb2wgPSBzZWxmLmNvbHVtbigpO1xuICAgICAgICAgICAgaWYgKGhhdmVfbmV3bGluZXMoYWZ0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IGNvbW1hbmQuc3Vic3RyaW5nKDAsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBhZnRlci5tYXRjaCgvXlteXFxuXSpcXG4vKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19wb3MgPSBjb2wgKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGF2ZV9uZXdsaW5lcyhiZWZvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfcG9zICs9IHByb21wdF9sZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wb3NpdGlvbihuZXdfcG9zLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dF9oaXN0b3J5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBiYWNrc3BhY2Vfa2V5KCkge1xuICAgICAgICAgICAgaWYgKHJldmVyc2Vfc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgcmV2X3NlYXJjaF9zdHIgPSByZXZfc2VhcmNoX3N0ci5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgZHJhd19yZXZlcnNlX3Byb21wdCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYW5kICE9PSAnJyAmJiBwb3NpdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmWydkZWxldGUnXSgtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmb3IgbmV4dCBpbnB1dCBhZnRlciBuYWl0dmUgYmFja3NwYWNlXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRpbWVvdXQgYmVjYXVzZSB3ZSBkb24ndCB3YW50IGl0IHRvIHRyaWdnZXJcbiAgICAgICAgICAgIC8vIGZvciBjdXJyZW50IGlucHV0IGJ1dCBuZXh0IG9uZVxuICAgICAgICAgICAgc2VsZi5vbmVUaW1lKDEsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG5vX2tleWRvd24gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBsZWZ0KCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYucG9zaXRpb24oLTEsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gcmlnaHQoKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCBiYXJlX3RleHQoY29tbWFuZCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wb3NpdGlvbigxLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIGhvbWUobGluZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gaG9tZSgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBvc2l0aW9uKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tYW5kLm1hdGNoKC9cXG4vKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IGNvbW1hbmQuc3Vic3RyaW5nKDAsIHNlbGYucG9zaXRpb24oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBvc2l0aW9uKHN0cmluZy5sYXN0SW5kZXhPZignXFxuJykgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBob21lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gZW5kKGxpbmUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBvc2l0aW9uKHRleHQoY29tbWFuZCkubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZC5tYXRjaCgvXFxuLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IGNvbW1hbmQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IHNlbGYucG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSBsaW5lc1tpXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1bSA+IHBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBvc2l0aW9uKHN1bSArIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVuZCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBtb2JpbGVfZm9jdXMoKSB7XG4gICAgICAgICAgICAvL2lmIChpc190b3VjaCkge1xuICAgICAgICAgICAgdmFyIGZvY3VzID0gY2xpcC5pcygnOmZvY3VzJyk7XG4gICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmICghZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jbGlwLnRyaWdnZXIoJ2ZvY3VzJywgW3RydWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5vbmVUaW1lKDEwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGlwLmlzKCc6Zm9jdXMnKSAmJiBlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwLnRyaWdnZXIoJ2ZvY3VzJywgW3RydWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb2N1cyAmJiAoaXNfbW9iaWxlIHx8ICFlbmFibGVkKSkge1xuICAgICAgICAgICAgICAgIGNsaXAudHJpZ2dlcignYmx1cicsIFt0cnVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBmaXggZm9yIC5jdXJzb3Igc3BhbiBhbmltYXRpb24gdGhhdCBzaG91bGQgb25seSBiZSBhcHBsaWVkIHdoZW5cbiAgICAgICAgLy8gYW5pbWF0aW9uIGlzIGVxdWFsIHRvIHRlcm1pbmFsLWJsaW5rXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gZml4X2N1cnNvcigpIHtcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25fc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY3Vyc29yWzBdKTtcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uTmFtZSA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy0tYW5pbWF0aW9uJyk7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uTmFtZSA9IGFuaW1hdGlvbk5hbWUucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xuICAgICAgICAgICAgICAgIHZhciBfY2xhc3MgPSBzZWxmLmF0dHIoJ2NsYXNzJyk7XG4gICAgICAgICAgICAgICAgaWYgKF9jbGFzcy5tYXRjaCgvLWFuaW1hdGlvbi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jbGFzcyA9IF9jbGFzcy5yZXBsYWNlKC9bYS16XSstYW5pbWF0aW9uL2csICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbk5hbWUgJiYgIWFuaW1hdGlvbk5hbWUubWF0Y2goL2JsaW5rLykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGFuaW1hdGlvbk5hbWUucmVwbGFjZSgvdGVybWluYWwtLywgJycpICsgJy1hbmltYXRpb24nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9jbGFzcy5tYXRjaChjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3MgKz0gJyAnICsgY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jbGFzcyA9IF9jbGFzcy5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICAgICAgICAgICAgaWYgKF9jbGFzcyAhPT0gc2VsZi5hdHRyKCdjbGFzcycpLnJlcGxhY2UoL1xccysvZywgJyAnKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmF0dHIoJ2NsYXNzJywgX2NsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBvbiBtb2JpbGUgeW91IGNhbid0IGRlbGV0ZSBjaGFyYWN0ZXIgaWYgaW5wdXQgaXMgZW1wdHkgKGV2ZW50XG4gICAgICAgIC8vIHdpbGwgbm90IGZpcmUpIHNvIHdlIGZha2UgdGV4dCBlbnRyeSwgd2UgY291bGQganVzdCBwdXQgZHVtbXlcbiAgICAgICAgLy8gZGF0YSBidXQgd2UgcHV0IHJlYWwgY29tbWFuZCBhbmQgcG9zaXRpb25cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBmaXhfdGV4dGFyZWEocG9zaXRpb25fb25seSkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzZW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVsYXkgd29ya2VkIHdoaWxlIGV4cGVyaW1lbnRpbmdcbiAgICAgICAgICAgIHNlbGYub25lVGltZSgxMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgdXNlIHNwYWNlIGJlZm9yZSBjb21tYW5kIHRvIHNob3cgc2VsZWN0IGFsbCBjb250ZXh0IG1lbnVcbiAgICAgICAgICAgICAgICAvLyBpZGVhIHRha2VuIGZyb20gQ29kZU1pcnJvclxuICAgICAgICAgICAgICAgIGlmICghaXNfbW9iaWxlICYmIGNsaXAudmFsKCkgIT09IGNvbW1hbmQgJiYgIXBvc2l0aW9uX29ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcC52YWwoJyAnICsgY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25lVGltZSgxMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNoZWNrIGZpcnN0IHRvIGltcHJvdmUgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzX21vYmlsZSAmJiBjbGlwLmNhcmV0KCkgIT09IHBvc2l0aW9uICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwLmNhcmV0KHBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcmVmb3ggdGhyb3cgTlNfRVJST1JfRkFJTFVSRSBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyB0ZXJtaW5hbCBhbmltYXRpb24gZG9uJ3Qgd29yayBvbiBhbmRyb2lkIGJlY2F1c2UgdGhleSBhbmltYXRlXG4gICAgICAgIC8vIDIgcHJvcGVydGllc1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGlmIChhbmltYXRpb25fc3VwcG9ydGVkICYmICFpc19hbmRyb2lkKSB7XG4gICAgICAgICAgICBhbmltYXRpb24gPSBmdW5jdGlvbih0b2dnbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9nZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5hZGRDbGFzcygnY21kLWJsaW5rJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnJlbW92ZUNsYXNzKCdjbWQtYmxpbmsnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdGFydF9hbmltYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3X2N1cnNvciA9IGN1cnNvci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG5ld19jdXJzb3IuaW5zZXJ0QmVmb3JlKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGN1cnNvciA9IG5ld19jdXJzb3I7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgYW5pbWF0aW9uID0gZnVuY3Rpb24odG9nZ2xlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvZ2dsZSAmJiAhYW5pbWF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5hZGRDbGFzcygnY21kLWludmVydGVkIGNtZC1ibGluaycpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmV2ZXJ5VGltZSg1MDAsICdibGluaycsIGJsaW5rKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFuaW1hdGluZyAmJiAhdG9nZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnN0b3BUaW1lKCdibGluaycsIGJsaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnJlbW92ZUNsYXNzKCdjbWQtaW52ZXJ0ZWQgY21kLWJsaW5rJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3RhcnRfYW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24odHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBCbGlua2luZyBjdXJzb3IgZnVuY3Rpb25cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIGJsaW5rKCkge1xuICAgICAgICAgICAgY3Vyc29yLnRvZ2dsZUNsYXNzKCdjbWQtaW52ZXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogU2V0IHByb21wdCBmb3IgcmV2ZXJzZSBzZWFyY2hcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdfcmV2ZXJzZV9wcm9tcHQoKSB7XG4gICAgICAgICAgICBwcm9tcHQgPSAnKHJldmVyc2UtaS1zZWFyY2gpYCcgKyByZXZfc2VhcmNoX3N0ciArIFwiJzogXCI7XG4gICAgICAgICAgICBkcmF3X3Byb21wdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBEaXNhYmxlIHJldmVyc2Ugc2VhcmNoXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBjbGVhcl9yZXZlcnNlX3N0YXRlKCkge1xuICAgICAgICAgICAgcHJvbXB0ID0gYmFja3VwX3Byb21wdDtcbiAgICAgICAgICAgIHJldmVyc2Vfc2VhcmNoID0gZmFsc2U7XG4gICAgICAgICAgICByZXZlcnNlX3NlYXJjaF9wb3NpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXZfc2VhcmNoX3N0ciA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBTZWFyY2ggdGhyb3VnaCBjb21tYW5kIGxpbmUgaGlzdG9yeS4gSWYgbmV4dCBpcyBub3QgZGVmaW5lZCBvclxuICAgICAgICAvLyA6OiBmYWxzZSBpdCBzZWFyY2hlcyBmb3IgdGhlIGZpcnN0IGl0ZW0gZnJvbSB0aGUgZW5kLiBJZiB0cnVlIGl0XG4gICAgICAgIC8vIDo6IHNlYXJjaCBmb3IgdGhlIG5leHQgaXRlbVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gcmV2ZXJzZV9oaXN0b3J5X3NlYXJjaChuZXh0KSB7XG4gICAgICAgICAgICB2YXIgaGlzdG9yeV9kYXRhID0gaGlzdG9yeS5kYXRhKCk7XG4gICAgICAgICAgICB2YXIgcmVnZXgsIHNhdmVfc3RyaW5nO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGhpc3RvcnlfZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiByZXZlcnNlX3NlYXJjaF9wb3NpdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBsZW4gLT0gcmV2ZXJzZV9zZWFyY2hfcG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV2X3NlYXJjaF9zdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSByZXZfc2VhcmNoX3N0ci5sZW5ndGg7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2F2ZV9zdHJpbmcgPSAkLnRlcm1pbmFsLmVzY2FwZV9yZWdleChyZXZfc2VhcmNoX3N0ci5zbGljZSgwLCBqKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5jYXNlU2Vuc2l0aXZlU2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoc2F2ZV9zdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHNhdmVfc3RyaW5nLCAnaScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBsZW47IGktLTspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KGhpc3RvcnlfZGF0YVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlX3NlYXJjaF9wb3NpdGlvbiA9IGhpc3RvcnlfZGF0YS5sZW5ndGggLSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucG9zaXRpb24oaGlzdG9yeV9kYXRhW2ldLmluZGV4T2Yoc2F2ZV9zdHJpbmcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNldChoaXN0b3J5X2RhdGFbaV0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXZfc2VhcmNoX3N0ci5sZW5ndGggIT09IGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2X3NlYXJjaF9zdHIgPSByZXZfc2VhcmNoX3N0ci5zbGljZSgwLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd19yZXZlcnNlX3Byb21wdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXZfc2VhcmNoX3N0ciA9ICcnOyAvLyBjbGVhciBpZiBub3QgZm91bmQgYW55XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IGNhbGN1bGF0ZSB3aWR0aCBvZiBodGUgY2hhcmFjdGVyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBnZXRfY2hhcl93aWR0aCgpIHtcbiAgICAgICAgICAgIHZhciAkcHJvbXB0ID0gc2VsZi5maW5kKCcuY21kLXByb21wdCcpO1xuICAgICAgICAgICAgdmFyIGh0bWwgPSAkcHJvbXB0Lmh0bWwoKTtcbiAgICAgICAgICAgICRwcm9tcHQuaHRtbCgnPHNwYW4+Jm5ic3A7PC9zcGFuPicpO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gJHByb21wdC5maW5kKCdzcGFuJylbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgICAgICAkcHJvbXB0Lmh0bWwoaHRtbCk7XG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IHJldHVybiBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiBjb21tYW5kIGxpbmVcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIGdldF9udW1fY2hhcnMoY2hhcl93aWR0aCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2VsZi53aWR0aCgpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iod2lkdGggLyBjaGFyX3dpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogU3BsaXQgU3RyaW5nIHRoYXQgZml0IGludG8gY29tbWFuZCBsaW5lIHdoZXJlIGZpcnN0IGxpbmUgbmVlZCB0b1xuICAgICAgICAvLyA6OiBmaXQgbmV4dCB0byBwcm9tcHQgKG5lZWQgdG8gaGF2ZSBsZXNzIGNoYXJhY3RlcnMpXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBnZXRfc3BsaXR0ZWRfY29tbWFuZF9saW5lKHN0cmluZykge1xuICAgICAgICAgICAgZnVuY3Rpb24gc3BsaXQoc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQudGVybWluYWwuc3BsaXRfZXF1YWwoc3RyaW5nLCBudW1fY2hhcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc2tpcF9lbXB0eShhcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIHJlbW92ZSBsaW5lcyB0aGF0IGFyZSBsZWZ0b3ZlcnMgYWZ0ZXIgYWRkaW5nIHNwYWNlIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEkLnRlcm1pbmFsLnN0cmlwKGxpbmUpLm1hdGNoKC9eICQvKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaW5lID0gcHJvbXB0X25vZGUuZmluZCgnLmNtZC1saW5lJyk7XG4gICAgICAgICAgICB2YXIgcHJvbXB0O1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcHJvbXB0ID0gbGluZS5uZXh0VW50aWwoJy5jbWQtbGluZScpLnRleHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbXB0ID0gcHJvbXB0X25vZGUudGV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbXB0ID0gJC50ZXJtaW5hbC5lc2NhcGVfYnJhY2tldHMocHJvbXB0KTtcbiAgICAgICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJ14nICsgJC50ZXJtaW5hbC5lc2NhcGVfcmVnZXgocHJvbXB0KSk7XG4gICAgICAgICAgICB2YXIgYXJyYXk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nLm1hdGNoKC9cXG4vKSkge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBzdHJpbmcuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdF9sZW4gPSBudW1fY2hhcnMgLSBwcm9tcHRfbGVuIC0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wW2ldICs9IGxpbmVfbWFya2VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzcGxpdCBmaXJzdCBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKHN0cmxlbih0bXBbMF0pID4gZmlyc3RfbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5ID0gc3BsaXQocHJvbXB0ICsgdG1wWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbMF0gPSBhcnJheVswXS5yZXBsYWNlKHJlLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5ID0gc2tpcF9lbXB0eShhcnJheSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkgPSBbdG1wWzBdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcHJvY2VzcyByZXN0IG9mIHRoZSBsaW5lc1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCB0bXAubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmxlbih0bXBbaV0pID4gbnVtX2NoYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXR0ZWQgPSBzcGxpdCh0bXBbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCB0bXAubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0dGVkID0gc2tpcF9lbXB0eShzcGxpdHRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheSA9IGFycmF5LmNvbmNhdChzcGxpdHRlZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHRtcFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5ID0gc3BsaXQocHJvbXB0ICsgc3RyaW5nLCBudW1fY2hhcnMpO1xuICAgICAgICAgICAgICAgIGFycmF5WzBdID0gYXJyYXlbMF0ucmVwbGFjZShyZSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZml4IGlzc3VlIHdpdGggY3Vyc29yIHRoYXQgd2FzIGN1dCBvZmYgIzM3OVxuICAgICAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA+IDEgJiYgYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV0ubGVuZ3RoID09PSBudW1fY2hhcnMpIHtcbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogdXNlIGN1c3RvbSBmb3JtYXR0aW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBmb3JtYXR0aW5nKHN0cmluZywgc2tpcF9mb3JtYXR0ZWRfcG9zaXRpb24pIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gZm9ybWF0IGNvbW1hbmQgd2hlbiB1c2VyIHR5cGUgZm9ybWF0dGluZyBpblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSAkLnRlcm1pbmFsLmVzY2FwZV9mb3JtYXR0aW5nKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdF9vcHRpb25zID0gJC5leHRlbmQoe30sIHNldHRpbmdzLCB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXhGb3JtYXR0aW5nRXNjYXBlQnJhY2tldHM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZWQgPSAkLnRlcm1pbmFsLmFwcGx5X2Zvcm1hdHRlcnMoc3RyaW5nLCBmb3JtYXRfb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9ICQudGVybWluYWwubm9ybWFsaXplKGZvcm1hdHRlZFswXSk7XG4gICAgICAgICAgICAgICAgdmFyIG1heCA9ICQudGVybWluYWwubGVuZ3RoKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKCFza2lwX2Zvcm1hdHRlZF9wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRfcG9zaXRpb24gPSBmb3JtYXR0ZWRbMV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpeCBpc3N1ZSB3aXRoIG5lc3RlZCBmb3JtYXR0aW5nIHdoZXJlIG1heCBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgY2hlY2tlZCBiZWZvcmUgbmVzdGVkX2Zvcm1hdHRpbmcgZmxhdHRlbiBmb3JtYXR0aW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRfcG9zaXRpb24gPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZF9wb3NpdGlvbiA9IG1heDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAkLnRlcm1pbmFsLm5vcm1hbGl6ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgYWxlcnRfZXhjZXB0aW9uKCdbRm9ybWF0dGluZ10nLCBlLnN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBmb3JtYXQgYW5kIGVuY29kZSB0aGUgc3RyaW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBmb3JtYXQoc3RyaW5nLCBiZWZvcmUpIHtcbiAgICAgICAgICAgIC8vc3RyaW5nID0gJC50ZXJtaW5hbC5ub3JtYWxpemUoc3RyaW5nKTtcbiAgICAgICAgICAgIHZhciBlbmNvZGVkID0gJC50ZXJtaW5hbC5lbmNvZGUod3JhcChzdHJpbmcpLCB7XG4gICAgICAgICAgICAgICAgdGFiczogc2V0dGluZ3MudGFicyxcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGJlZm9yZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdHJpbmcgPSAkLnRlcm1pbmFsLmZvcm1hdChlbmNvZGVkLCB7XG4gICAgICAgICAgICAgICAgY2hhcl93aWR0aDogc2V0dGluZ3MuY2hhcl93aWR0aCxcbiAgICAgICAgICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogc2V0dGluZ3MuYWxsb3dlZEF0dHJpYnV0ZXMgfHwgW11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHJlID0gLyg8c3BhbltePl0rZGF0YS10ZXh0W14+XSs+KSguKj8pKDxcXC9zcGFuPikvZztcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZSwgJyQxPHNwYW4+JDI8L3NwYW4+JDMnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogZnVuY3Rpb24gY3JlYXRlIG5ldyBzdHJpbmcgd2l0aCBhbGwgY2hhcmFjdGVycyBpbiBpdCdzIG93blxuICAgICAgICAvLyA6OiBmb3JtYXR0aW5nIC0gaXQgd2lsbCBvbmx5IGhhdmUgc3R5bGUgaWYgdGhlIGlucHV0IGlzIGZvcm1hdHRpbmdcbiAgICAgICAgLy8gOjogdGhpcyBmdW5jdGlvbiBpcyBub3QgdmVyeSB1c2VmdWxsIHNvIGl0J3Mgbm90IGluICQudGVybWluYWxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIHdyYXAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gJC50ZXJtaW5hbC5wYXJ0aXRpb24oc3RyaW5nKS5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogc2hvcnRjdXQgaGVscGVyc1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gbGVuZ3RoKHN0ciwgcmF3KSB7XG4gICAgICAgICAgICByZXR1cm4gJC50ZXJtaW5hbC5sZW5ndGgoc3RyLCByYXcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBzdWJzdHJpbmcoc3RyLCBzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gJC50ZXJtaW5hbC5zdWJzdHJpbmcoc3RyLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogRnVuY3Rpb24gdGhhdCBkaXNwbGF5cyB0aGUgY29tbWFuZCBsaW5lLiBTcGxpdCBsb25nIGxpbmVzIGFuZFxuICAgICAgICAvLyA6OiBwbGFjZSBjdXJzb3IgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB2YXIgcmVkcmF3ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IGN1cnNvci5wcmV2KCk7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgdmFyIGN1cnNvcl9saW5lID0gY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IERyYXcgbGluZSB3aXRoIHRoZSBjdXJzb3JcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBmdW5jdGlvbiBkcmF3X2N1cnNvcl9saW5lKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBlbmRfbGluZSA9IHN0cmluZy5tYXRjaChsaW5lX21hcmtlcl9yZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZF9saW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGxpbmVfbWFya2VyX3JlLCAnICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3Vyc29yX2VuZF9saW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICBwcm9tcHQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICBsYXN0OiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHNldHRpbmdzLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBsZW5ndGgoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbXB0ID0gc2V0dGluZ3MucHJvbXB0O1xuICAgICAgICAgICAgICAgIGlmIChjaF91bml0X2J1Zykge1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3Iud2lkdGgoY2hhcl93aWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZS5odG1sKGZvcm1hdChzdHJpbmcpKTtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmh0bWwoJzxzcGFuPjxzcGFuPiZuYnNwOzwvc3Bhbj48L3NwYW4+Jyk7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLmh0bWwoJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlLmh0bWwoJycpO1xuICAgICAgICAgICAgICAgICAgICBjID0gc3Vic3RyaW5nKHN0cmluZywgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5odG1sKGZvcm1hdChjKSk7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLmh0bWwoZm9ybWF0KHN1YnN0cmluZyhzdHJpbmcsIDEpLCBwcm9tcHQgKyBjKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJlZm9yZV9zdHIgPSAkLnRlcm1pbmFsLnN1YnN0cmluZyhzdHJpbmcsIDAsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlLmh0bWwoZm9ybWF0KGJlZm9yZV9zdHIsIHByb21wdCkpO1xuICAgICAgICAgICAgICAgICAgICBjID0gc3Vic3RyaW5nKHN0cmluZywgcG9zaXRpb24sIHBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjX2JlZm9yZSA9IChwcm9tcHQgKyBiZWZvcmVfc3RyKS5yZXBsYWNlKC9eLipcXHQvLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5odG1sKGZvcm1hdChjLCBjX2JlZm9yZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcl9lbmRfbGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlci5odG1sKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLm1hdGNoKC9cXHQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNfYmVmb3JlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNfYmVmb3JlICs9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlci5odG1sKGZvcm1hdChzdWJzdHJpbmcoc3RyaW5nLCBwb3NpdGlvbiArIDEpLCBjX2JlZm9yZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnNvci50b2dnbGVDbGFzcygnY21kLWVuZC1saW5lJywgY3Vyc29yX2VuZF9saW5lKTtcbiAgICAgICAgICAgICAgICAvLyBmaXggZm9yIGFuaW1hdGlvbiB3aGVuIGNoYW5naW5nIC0tYW5pbWF0aW9uIGR5bmFtaWNhbGx5XG4gICAgICAgICAgICAgICAgZml4X2N1cnNvcigpO1xuICAgICAgICAgICAgICAgIHZhciBjdXJzb3JfbGVuID0gJC50ZXJtaW5hbC5sZW5ndGgoY3Vyc29yLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvcl9sZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gY3Vyc29yLmZpbmQoJ1tkYXRhLXRleHRdJylbMF07XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoJy0tbGVuZ3RoJywgY3Vyc29yX2xlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHN5bmNocm9uaXplIGNzcyBhbmltYXRpb25zIChpdCdzIG5vdCB0aGF0IGltcG9ydGFudCBiZWNhdXNlIGlmIHVzZXJcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGNoYW5nZSBhbmltYXRpb24gc2hlIHNob3VsZCBkaXNhYmxlIGFuaW1hdGlvbiBvbiBzcGFuLCBidXQgaXRcbiAgICAgICAgICAgICAgICAvLyBsb29rcyBuaWNlciB1bnRpbCBzaGUgZGlzYWJsZSB0aGF0IGlubmVyIGFuaW1hdGlvbilcbiAgICAgICAgICAgICAgICByZXN0YXJ0X2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZGl2KHN0cmluZywgYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZF9saW5lID0gc3RyaW5nLm1hdGNoKGxpbmVfbWFya2VyX3JlKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gJzxkaXYgcm9sZT1cInByZXNlbnRhdGlvblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiJztcbiAgICAgICAgICAgICAgICBpZiAoZW5kX2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobGluZV9tYXJrZXJfcmUsICcgJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnIGNsYXNzPVwiY21kLWVuZC1saW5lXCInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJz4nICsgZm9ybWF0KHN0cmluZywgYmVmb3JlIHx8ICcnKSArICc8L2Rpdj4nO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogRGlzcGxheSBsaW5lcyBhZnRlciB0aGUgY3Vyc29yXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgZnVuY3Rpb24gbGluZXNfYWZ0ZXIobGluZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdF9pbnMgPSBjdXJzb3JfbGluZTtcbiAgICAgICAgICAgICAgICAkLmVhY2gobGluZXMsIGZ1bmN0aW9uKGksIGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9pbnMgPSAkKGRpdihsaW5lKSkuaW5zZXJ0QWZ0ZXIobGFzdF9pbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IERpc3BsYXkgbGluZXMgYmVmb3JlIHRoZSBjdXJzb3JcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBmdW5jdGlvbiBsaW5lc19iZWZvcmUobGluZXMpIHtcbiAgICAgICAgICAgICAgICAkLmVhY2gobGluZXMsIGZ1bmN0aW9uKGksIGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yX2xpbmUuYmVmb3JlKGRpdihsaW5lLCBpID09PSAwID8gcHJvbXB0X2xhc3RfbGluZSA6ICcnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogUmVkcmF3IGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmc7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlb2Ygc2V0dGluZ3MubWFzaykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IHNldHRpbmdzLm1hc2sgPyBjb21tYW5kLnJlcGxhY2UoLy4vZywgJyonKSA6IGNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IGNvbW1hbmQucmVwbGFjZSgvLi9nLCBzZXR0aW5ncy5tYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkID0gZm9ybWF0dGluZyhzdHJpbmcpO1xuICAgICAgICAgICAgICAgIHZhciBwb3M7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aChmb3JtYXR0ZWQpID09PSB0ZXh0KHN0cmluZykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGZvcm1hdHRlZF9wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5maW5kKCdkaXY6bm90KC5jbWQtY3Vyc29yLWxpbmUpJykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgYmVmb3JlLmh0bWwoJycpO1xuICAgICAgICAgICAgICAgIC8vIGxvbmcgbGluZVxuICAgICAgICAgICAgICAgIGlmIChzdHJsZW4odGV4dChmb3JtYXR0ZWQpKSA+IG51bV9jaGFycyAtIHByb21wdF9sZW4gLSAxIHx8XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZC5tYXRjaCgvXFxuLykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYnMgPSBmb3JtYXR0ZWQubWF0Y2goL1xcdC9nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsX3N0cmluZyA9IGZvcm1hdHRlZDtcbiAgICAgICAgICAgICAgICAgICAgLy9xdWljayB0YWJ1bGF0aW9uIGhhY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhYnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKC9cXHQvZywgJ1xceDAwXFx4MDBcXHgwMFxceDAwJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gZ2V0X3NwbGl0dGVkX2NvbW1hbmRfbGluZShmb3JtYXR0ZWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFicykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXkgPSAkLm1hcChhcnJheSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLnJlcGxhY2UoL1xceDAwXFx4MDBcXHgwMFxceDAwL2csICdcXHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdF9sZW4gPSBsZW5ndGgoYXJyYXlbMF0pO1xuICAgICAgICAgICAgICAgICAgICAvL2N1cnNvciBpbiBmaXJzdCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdF9sZW4gPT09IDAgJiYgYXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBza2lwIGVtcHR5IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb3MgPCBmaXJzdF9sZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdfY3Vyc29yX2xpbmUoYXJyYXlbMF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0X2xhc3RfbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lc19hZnRlcihhcnJheS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zID09PSBmaXJzdF9sZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IGNoYXIgYWN0ZXIgb2Ygc2Vjb25kIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcl9saW5lLmJlZm9yZShkaXYoYXJyYXlbMF0sIHByb21wdF9sYXN0X2xpbmUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdfY3Vyc29yX2xpbmUoYXJyYXlbMV0gfHwgJycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0OiBhcnJheS5sZW5ndGggPD0gMlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzX2FmdGVyKGFycmF5LnNsaWNlKDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gYXJyYXkuc2xpY2UoLTEpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGxlbmd0aChvcmlnaW5hbF9zdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21fbGFzdCA9IGxlbiAtIHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0X2xlbiA9IGxlbmd0aChsYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdfcG9zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tX2xhc3QgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbV9sYXN0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tX2xhc3QgPD0gbGFzdF9sZW4pIHsgLy8gaW4gbGFzdCBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNfYmVmb3JlKGFycmF5LnNsaWNlKDAsIC0xKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RfbGVuID09PSBmcm9tX2xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X3BvcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X3BvcyA9IGxhc3RfbGVuIC0gZnJvbV9sYXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3X2N1cnNvcl9saW5lKGxhc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBuZXdfcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgbGluZXMsIGN1cnNvciBpbiB0aGUgbWlkZGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVfaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X3BvcyA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRfbGVuID0gJC50ZXJtaW5hbC5sZW5ndGgoYXJyYXlbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3X3BvcyA+IGN1cnJlbnRfbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfcG9zIC09IGN1cnJlbnRfbGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGFycmF5W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnNvciBvbiBmaXJzdCBjaGFyYWN0ZXIgaW4gbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdfcG9zID09PSBsZW5ndGgoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X3BvcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBhcnJheVsrK2xpbmVfaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Nob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSAkLnRlcm1pbmFsLmRlZmF1bHRzLnN0cmluZ3MucmVkcmF3RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3X2N1cnNvcl9saW5lKGN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBuZXdfcG9zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNfYmVmb3JlKGFycmF5LnNsaWNlKDAsIGxpbmVfaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lc19hZnRlcihhcnJheS5zbGljZShsaW5lX2luZGV4ICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmluZCgnLmNtZC1jdXJzb3ItbGluZSB+IGRpdjpsYXN0LW9mLXR5cGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnPHNwYW4+PC9zcGFuPicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0dGVkID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUuaHRtbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5odG1sKCc8c3Bhbj48c3Bhbj4mbmJzcDs8L3NwYW4+PC9zcGFuPicpO1xuICAgICAgICAgICAgICAgICAgICBhZnRlci5odG1sKCcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkcmF3X2N1cnNvcl9saW5lKGZvcm1hdHRlZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGluX2xpbmUgPSBjdXJzb3JfbGluZS5wcmV2VW50aWwoJy5jbWQtcHJvbXB0JykubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChpc19jc3NfdmFyaWFibGVzX3N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmWzBdLnN0eWxlLnNldFByb3BlcnR5KCctLWN1cnNvci1saW5lJywgaW5fbGluZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcC5jc3MoJ3RvcCcsIGluX2xpbmUgKiAxNCArICdweCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cmFwcGVyLmNzcygndmlzaWJpbGl0eScsICcnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBmaW5kIHBvc2l0aW9uIHRoYXQgbWF0Y2ggZGlzcGxheSBwb3NpdGlvbiBmb3IgY29tbWFuZHMgdGhhdFxuICAgICAgICAvLyA6OiBjaGFuZ2UgbGVuZ3RoIGJ5IGZvcm1hdHRlcnNcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHZhciBmaW5kX3Bvc2l0aW9uID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gbWFrZV9ndWVzcyhzdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdHMgPSAkLmV4dGVuZCh7fSwgc2V0dGluZ3MsIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQudGVybWluYWwuYXBwbHlfZm9ybWF0dGVycyhzdHJpbmcsIG9wdHMpWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gY21wKHNlYXJjaF9wb3MsIHBvcywgc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGd1ZXNzID0gbWFrZV9ndWVzcyhzdHJpbmcsIHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKGd1ZXNzID09PSBzZWFyY2hfcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0X2d1ZXNzID0gbWFrZV9ndWVzcyhzdHJpbmcsIHBvcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dF9ndWVzcyA+IHNlYXJjaF9wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ3Vlc3MgPCBzZWFyY2hfcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nLCBmb3JtYXR0ZWRfcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVkX3Bvc2l0aW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBiYXJlX3RleHQoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICB2YXIgY29kZXBvaW50X2xlbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9ICQudGVybWluYWwuZXNjYXBlX2JyYWNrZXRzKGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBiaW5hcnlfc2VhcmNoKDAsIGNvZGVwb2ludF9sZW4sIGZvcm1hdHRlZF9wb3NpdGlvbiwgY21wLCBbc3RyXSk7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJzID0gJC50ZXJtaW5hbC5zcGxpdF9jaGFyYWN0ZXJzKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVwb2ludF9sZW4gPiBjaGFycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiArPSBjaGFyc1tpXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuID49IHBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBEcmF3IHByb21wdCB0aGF0IGNhbiBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB2YXIgcHJldl9wcm9tcHRfZGF0YTtcbiAgICAgICAgdmFyIGRyYXdfcHJvbXB0ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gc2V0KHByb21wdCkge1xuICAgICAgICAgICAgICAgIHByb21wdCA9ICQudGVybWluYWwuYXBwbHlfZm9ybWF0dGVycyhwcm9tcHQsIHt9KTtcbiAgICAgICAgICAgICAgICBwcm9tcHQgPSAkLnRlcm1pbmFsLm5vcm1hbGl6ZShwcm9tcHQpO1xuICAgICAgICAgICAgICAgIHByb21wdCA9IGNybGYocHJvbXB0KTtcbiAgICAgICAgICAgICAgICBsYXN0X3JlbmRlcmVkX3Byb21wdCA9IHByb21wdDtcbiAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSAkLnRlcm1pbmFsLnNwbGl0X2VxdWFsKHByb21wdCwgbnVtX2NoYXJzKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISQudGVybWluYWwuaGF2ZV9mb3JtYXR0aW5nKGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tbOztdJyArIGxpbmUgKyAnXSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJfd2lkdGg6IHNldHRpbmdzLmNoYXJfd2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHByb21wdF9sYXN0X2xpbmUgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgZW5jb2RlZF9sYXN0X2xpbmUgPSAkLnRlcm1pbmFsLmVuY29kZShsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSwge1xuICAgICAgICAgICAgICAgICAgICB0YWJzOiBzZXR0aW5ncy50YWJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RfbGluZSA9ICQudGVybWluYWwuZm9ybWF0KGVuY29kZWRfbGFzdF9saW5lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkID0gbGluZXMuc2xpY2UoMCwgLTEpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSAkLnRlcm1pbmFsLmVuY29kZShsaW5lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJzOiBzZXR0aW5ncy50YWJzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwiY21kLWxpbmVcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICQudGVybWluYWwuZm9ybWF0KGxpbmUsIG9wdGlvbnMpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L3NwYW4+JztcbiAgICAgICAgICAgICAgICB9KS5jb25jYXQoW2xhc3RfbGluZV0pLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwcm9tcHQgaWYgY2hhbmdlZFxuICAgICAgICAgICAgICAgIGlmIChwcm9tcHRfbm9kZS5odG1sKCkgIT09IGZvcm1hdHRlZCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9tcHRfbm9kZS5odG1sKGZvcm1hdHRlZCk7XG4gICAgICAgICAgICAgICAgICAgIHByb21wdF9sZW4gPSBzdHJsZW4odGV4dChlbmNvZGVkX2xhc3RfbGluZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgZGF0YSBpcyB1c2VkIGFzIGNhbmNlbGFibGUgcmVmZXJlbmNlIGJlY2F1c2Ugd2UgaGF2ZSByZWZcbiAgICAgICAgICAgICAgICAvLyBkYXRhIG9iamVjdCB0aGF0IGlzIGhvbGQgaW4gY2xvc3VyZSBhbmQgd2UgcmVtb3ZlIGBzZXRgIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgLy8gc28gcHJldmlvdXMgY2FsbCB0byBmdW5jdGlvbiBwcm9tcHQgd2lsbCBiZSBpZ25vcmVkXG4gICAgICAgICAgICAgICAgaWYgKHByZXZfcHJvbXB0X2RhdGEgJiYgcHJldl9wcm9tcHRfZGF0YS5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldl9wcm9tcHRfZGF0YS5zZXQgPSAkLm5vb3A7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZm9yIGdhcmJhZ2UgY29sbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgIHByZXZfcHJvbXB0X2RhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBwcm9tcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldChwcm9tcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gcHJldl9wcm9tcHRfZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBwcm9tcHQuY2FsbChzZWxmLCBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNldChzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ICYmIHJldC50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnRoZW4oZGF0YS5zZXQpLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21wdCA9ICQudGVybWluYWwuZXNjYXBlX2JyYWNrZXRzKCdbRVJSXT4gJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2V0KCdbWztyZWQ7XScgKyBwcm9tcHQgKyAnXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydF9leGNlcHRpb24oJ1Byb21wdCcsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIGZpcmVfY2hhbmdlX2NvbW1hbmQoKSB7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oc2V0dGluZ3Mub25Db21tYW5kQ2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uQ29tbWFuZENoYW5nZS5jYWxsKHNlbGYsIGNvbW1hbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBjbGVhbihzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKCg/IVxcXFwpLilcXFxcKD86JiM5Mzt8XSkvZywgJyQxJiM5MzsnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogQ29tbWFuZCBMaW5lIE1ldGhvZHNcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICQuZXh0ZW5kKHNlbGYsIHtcbiAgICAgICAgICAgIG9wdGlvbjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3NbbmFtZV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmFibGVkID0gaGlzdG9yeSAmJiBoaXN0b3J5LmVuYWJsZWQoKSB8fCAhaGlzdG9yeTtcbiAgICAgICAgICAgICAgICAgICAgaGlzdG9yeSA9IG5ldyBIaXN0b3J5KFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmhpc3RvcnlTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaGlzdG9yeSA9PT0gJ21lbW9yeSdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZSBuZXcgaGlzdG9yeSBpZiBvbGQgd2FzIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9yeS5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHB1cmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBoaXN0b3J5LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlzdG9yeTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpc3Rvcnk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKG4sIHN0YXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZCwgc3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtYXkgbG9vayB3ZWlyZCBidXQgaWYgbiBpcyBuZWdhdGl2ZSB3ZSBuZWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byB1c2UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IGNvbW1hbmQuc2xpY2UoMCwgcG9zaXRpb24pLnNsaWNlKG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gYmFyZV90ZXh0KGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDAsIHBvc2l0aW9uICsgbikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZy5zbGljZShwb3NpdGlvbiwgc3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBvc2l0aW9uKHBvc2l0aW9uICsgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IHRleHQoY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSBzdHJpbmcuc2xpY2UocG9zaXRpb24pLnNsaWNlKDAsIG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKDAsIHBvc2l0aW9uKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnNsaWNlKHBvc2l0aW9uICsgbiwgc3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZCA9IGNsZWFuKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICAgICAgICAgIGZpeF90ZXh0YXJlYSgpO1xuICAgICAgICAgICAgICAgIGZpcmVfY2hhbmdlX2NvbW1hbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHN0cmluZywgc3RheSwgc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBjbGVhbihzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucG9zaXRpb24oYmFyZV90ZXh0KGNvbW1hbmQpLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgIGZpeF90ZXh0YXJlYSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZV9jaGFuZ2VfY29tbWFuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleW1hcDogZnVuY3Rpb24obmV3X2tleW1hcCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB3cmFwKGtleSwgZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gZGVmYXVsdF9rZXltYXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKG9yaWdpbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWwgPSBvcmlnaW5hbC5iaW5kKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXcga2V5bWFwIGZ1bmN0aW9uIHdpbGwgZ2V0IGRlZmF1bHQgYXMgMm5kIGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbChzZWxmLCBlLCBvcmlnaW5hbCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3X2tleW1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleW1hcDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdfa2V5bWFwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleW1hcFtuZXdfa2V5bWFwXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXltYXBbbmV3X2tleW1hcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRfa2V5bWFwW25ld19rZXltYXBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRfa2V5bWFwW25ld19rZXltYXBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5bWFwW25ld19rZXltYXBdID0gd3JhcChuZXdfa2V5bWFwLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZXltYXAgPSAkLmV4dGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5bWFwID8ga2V5bWFwIDogZGVmYXVsdF9rZXltYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAkLm9tYXAobmV3X2tleW1hcCB8fCB7fSwgd3JhcClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc2VydDogZnVuY3Rpb24oc3RyaW5nLCBzdGF5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhcmVfY29tbWFuZCA9IGJhcmVfdGV4dChjb21tYW5kKTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gYmFyZV90ZXh0KHN0cmluZykubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gYmFyZV9jb21tYW5kLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBiYXJlX2NvbW1hbmQgKyBzdHJpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcgKyBiYXJlX2NvbW1hbmQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gYmFyZV9jb21tYW5kLnNsaWNlKDAsIHBvc2l0aW9uKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKyBiYXJlX2NvbW1hbmQuc2xpY2UocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21tYW5kID0gY2xlYW4oc3RyaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wb3NpdGlvbihsZW4sIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaXhfdGV4dGFyZWEoKTtcbiAgICAgICAgICAgICAgICByZWRyYXcoKTtcbiAgICAgICAgICAgICAgICBmaXJlX2NoYW5nZV9jb21tYW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21tYW5kczogZnVuY3Rpb24oY29tbWFuZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuY29tbWFuZHMgPSBjb21tYW5kcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkb2MudW5iaW5kKCdrZXlwcmVzcy5jbWQnLCBrZXlwcmVzc19ldmVudCk7XG4gICAgICAgICAgICAgICAgZG9jLnVuYmluZCgna2V5ZG93bi5jbWQnLCBrZXlkb3duX2V2ZW50KTtcbiAgICAgICAgICAgICAgICBkb2MudW5iaW5kKCdpbnB1dC5jbWQnLCBpbnB1dF9ldmVudCk7XG4gICAgICAgICAgICAgICAgc2VsZi5zdG9wVGltZSgnYmxpbmsnLCBibGluayk7XG4gICAgICAgICAgICAgICAgc2VsZi5maW5kKCcuY21kLXdyYXBwZXInKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmZpbmQoJy5jbWQtcHJvbXB0LCAuY21kLWNsaXBib2FyZCcpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoJ2NtZCcpLnJlbW92ZURhdGEoJ2NtZCcpLm9mZignLmNtZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbHVtbjogZnVuY3Rpb24oaW5jbHVkZV9wcm9tcHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmVmb3JlID0gY29tbWFuZC5zdWJzdHJpbmcoMCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCB8fCAhY29tbWFuZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZSA9IC9cXG4/KFteXFxuXSopJC87XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gYmVmb3JlLm1hdGNoKHJlKTtcbiAgICAgICAgICAgICAgICB2YXIgY29sID0gbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICghaGF2ZV9uZXdsaW5lcyhiZWZvcmUpICYmIGluY2x1ZGVfcHJvbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbCArPSBwcm9tcHRfbGVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb21wdDogZnVuY3Rpb24odXNlcl9wcm9tcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlcl9wcm9tcHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RfcmVuZGVyZWRfcHJvbXB0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodXNlcl9wcm9tcHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbXB0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaG91bGRfcmVkcmF3ID0gdXNlcl9wcm9tcHQgIT09IHByb21wdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1c2VyX3Byb21wdCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB1c2VyX3Byb21wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXB0ID0gdXNlcl9wcm9tcHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb21wdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3Igc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZF9yZWRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdfcHJvbXB0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjb3VsZCBjaGVjayBpZiBjb21tYW5kIGlzIGxvbmdlciB0aGVuIG51bWNoYXJzLW5ld1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvbXB0XG4gICAgICAgICAgICAgICAgICAgICAgICByZWRyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2lsbF90ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2lsbF90ZXh0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbihuLCByZWxhdGl2ZSwgc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBiYXJlX3RleHQoY29tbWFuZCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IG47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuID4gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGxlbjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zICE9PSBwb3NpdGlvbiAmJiAhc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWRyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihzZXR0aW5ncy5vblBvc2l0aW9uQ2hhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uUG9zaXRpb25DaGFuZ2UocG9zaXRpb24sIGZvcm1hdHRlZF9wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXhfdGV4dGFyZWEodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZyZXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkcmF3X3Byb21wdCgpO1xuICAgICAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICAgICAgICAgIGZpeF90ZXh0YXJlYSh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBpZiBmb3JtYXR0ZXIgY2hhbmdlIGxlbmd0aCBvZiB0aGUgc3RyaW5ncyAobGlrZSBlbW9qaSBkZW1vKSB3ZSBuZWVkIHRvIGtlZXBcbiAgICAgICAgICAgIC8vIHRyYWNrIG9mIHR3byBkaWZmZXJlbnQgcG9zaXRpb25zIG9uZSBmb3IgY29tbWFuZCBhbmQgb25lIGZvciBkaXNwbGF5XG4gICAgICAgICAgICBkaXNwbGF5X3Bvc2l0aW9uOiBmdW5jdGlvbihuLCByZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZF9wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBkb3VibGUgZXNjYXBlXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSBmb3JtYXR0aW5nKCQudGVybWluYWwuZXNjYXBlX2Zvcm1hdHRpbmcoY29tbWFuZCksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gbGVuZ3RoKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21tYW5kX2xlbiA9IGJhcmVfdGV4dChjb21tYW5kKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdfZm9ybWF0dGVkX3BvcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfZm9ybWF0dGVkX3BvcyA9IGZvcm1hdHRlZF9wb3NpdGlvbiArIG47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobiA+IGxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2Zvcm1hdHRlZF9wb3MgPSBsZW47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfZm9ybWF0dGVkX3BvcyA9IG47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQoc3RyaW5nKS5sZW5ndGggPT09IGxlbmd0aChjb21tYW5kLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkX3Bvc2l0aW9uID0gbmV3X2Zvcm1hdHRlZF9wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wb3NpdGlvbihuZXdfZm9ybWF0dGVkX3Bvcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA9PT0gbmV3X2Zvcm1hdHRlZF9wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZF9wb3NpdGlvbiA9IG5ld19mb3JtYXR0ZWRfcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucG9zaXRpb24oY29tbWFuZF9sZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBmaW5kX3Bvc2l0aW9uKGNvbW1hbmQsIG5ld19mb3JtYXR0ZWRfcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZF9wb3NpdGlvbiA9IG5ld19mb3JtYXR0ZWRfcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wb3NpdGlvbihwb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpYmxlOiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpc2libGUgPSBzZWxmLnZpc2libGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlLmFwcGx5KHNlbGYsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdfcHJvbXB0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSgpLFxuICAgICAgICAgICAgc2hvdzogKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzaG93ID0gc2VsZi5zaG93O1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdy5hcHBseShzZWxmLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICBkcmF3X3Byb21wdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkoKSxcbiAgICAgICAgICAgIHJlc2l6ZTogZnVuY3Rpb24obnVtKSB7XG4gICAgICAgICAgICAgICAgY2hhcl93aWR0aCA9IGdldF9jaGFyX3dpZHRoKCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld19udW1fY2hhcnM7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld19udW1fY2hhcnMgPSBudW07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3X251bV9jaGFycyA9IGdldF9udW1fY2hhcnMoY2hhcl93aWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChudW1fY2hhcnMgIT09IG5ld19udW1fY2hhcnMgfHwgYXJndW1lbnRzWzBdID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bV9jaGFycyA9IG5ld19udW1fY2hhcnM7XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICBkcmF3X3Byb21wdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnZva2Vfa2V5OiBmdW5jdGlvbihzaG9ydGN1dCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gc2hvcnRjdXQudG9VcHBlckNhc2UoKS5zcGxpdCgnKycpO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHZhciBjdHJsID0ga2V5cy5pbmRleE9mKCdDVFJMJykgIT09IC0xO1xuICAgICAgICAgICAgICAgIHZhciBzaGlmdCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgdmFyIGFsdCA9IGtleXMuaW5kZXhPZignQUxUJykgIT09IC0xO1xuICAgICAgICAgICAgICAgIHZhciBtZXRhID0ga2V5cy5pbmRleE9mKCdNRVRBJykgIT09IC0xO1xuICAgICAgICAgICAgICAgIHZhciBlID0gJC5FdmVudChcImtleWRvd25cIiwge1xuICAgICAgICAgICAgICAgICAgICBjdHJsS2V5OiBjdHJsLFxuICAgICAgICAgICAgICAgICAgICBzaGlmdEtleTogc2hpZnQsXG4gICAgICAgICAgICAgICAgICAgIGFsdEtleTogYWx0LFxuICAgICAgICAgICAgICAgICAgICBtZXRhS2V5OiBtZXRhLFxuICAgICAgICAgICAgICAgICAgICB3aGljaDogcmV2ZXJzZWRfa2V5Y29kZXNba2V5XSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gJChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgd2luZG93KTtcbiAgICAgICAgICAgICAgICBkb2MudHJpZ2dlcihlKTtcbiAgICAgICAgICAgICAgICBlID0gJC5FdmVudChcImtleXByZXNzXCIpO1xuICAgICAgICAgICAgICAgIGUua2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIGUud2hpY2ggPSBlLmtleUNvZGUgPSAwO1xuICAgICAgICAgICAgICAgIGRvYy50cmlnZ2VyKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuYWJsZTogZnVuY3Rpb24oc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZENsYXNzKCdlbmFibGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpcC5pcygnOm5vdCg6Zm9jdXMpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwLmNhcmV0KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyZWZveCB0aHJvdyBOU19FUlJPUl9GQUlMVVJFIC0gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNpbGVudCAmJiBpc19mdW5jdGlvbihwcm9tcHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3X3Byb21wdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpeF9jdXJzb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZml4X3RleHRhcmVhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vYmlsZV9mb2N1cygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzZW5hYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oZm9jdXMpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVDbGFzcygnZW5hYmxlZCcpO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb2N1cykge1xuICAgICAgICAgICAgICAgICAgICBtb2JpbGVfZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFzazogZnVuY3Rpb24obmV3X21hc2spIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld19tYXNrID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MubWFzaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5tYXNrID0gbmV3X21hc2s7XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogSU5JVFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgc2VsZi5uYW1lKHNldHRpbmdzLm5hbWUgfHwgc2V0dGluZ3MucHJvbXB0IHx8ICcnKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLnByb21wdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHByb21wdCA9IHNldHRpbmdzLnByb21wdDtcbiAgICAgICAgICAgIGRyYXdfcHJvbXB0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHNlbGYuZW5hYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hhcl93aWR0aCA9IGdldF9jaGFyX3dpZHRoKCk7XG4gICAgICAgIG51bV9jaGFycyA9IGdldF9udW1fY2hhcnMoY2hhcl93aWR0aCk7XG4gICAgICAgIGlmICghc2V0dGluZ3MuaGlzdG9yeSkge1xuICAgICAgICAgICAgaGlzdG9yeS5kaXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0X3VwX2hpc3RvcnkgPSB0cnVlO1xuICAgICAgICAvLyBza2lwX2tleXByZXNzIC0gaGFjayBmb3IgQW5kcm9pZCB0aGF0IHdhcyBpbnNlcnRpbmcgY2hhcmFjdGVycyBvblxuICAgICAgICAvLyBiYWNrc3BhY2VcbiAgICAgICAgdmFyIHNraXBfa2V5cHJlc3MgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRlYWRfa2V5ID0gZmFsc2U7XG4gICAgICAgIHZhciBzaW5nbGVfa2V5ID0gZmFsc2U7XG4gICAgICAgIHZhciBub19rZXlwcmVzcyA9IGZhbHNlO1xuICAgICAgICB2YXIgbm9fa2V5ID0gZmFsc2U7XG4gICAgICAgIHZhciBub19rZXlkb3duID0gdHJ1ZTtcbiAgICAgICAgdmFyIGJhY2tzcGFjZSA9IGZhbHNlO1xuICAgICAgICB2YXIgcHJvY2VzcyA9IGZhbHNlO1xuICAgICAgICB2YXIgaG9sZCA9IGZhbHNlO1xuICAgICAgICB2YXIgaG9sZF9wYXVzZSA9IGZhbHNlO1xuICAgICAgICB2YXIgc2tpcF9pbnNlcnQ7XG4gICAgICAgIC8vIHdlIGhvbGQgdGV4dCBiZWZvcmUga2V5ZG93biB0byBmaXggYmFja3NwYWNlIGZvciBBbmRyb2lkL0Nocm9tZS9Td2lmdEtleVxuICAgICAgICAvLyBrZXlib2FyZCB0aGF0IGdlbmVyYXRlIGtleWNvZGUgMjI5IGZvciBhbGwga2V5cyAjMjk2XG4gICAgICAgIHZhciBwcmV2X2NvbW1hbmQgPSAnJztcbiAgICAgICAgdmFyIHByZXZfa2V5O1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogS2V5ZG93biBFdmVudCBIYW5kbGVyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBpc19iYWNrc3BhY2UoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUua2V5LnRvVXBwZXJDYXNlKCkgPT09ICdCQUNLU1BBQ0UnIHx8IGUud2hpY2ggPT09IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIGlzX3NpbmdsZShlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS5rZXkgJiYgZS5rZXkubGVuZ3RoID09PSAxICYmICFlLmN0cmxLZXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIGlzX2RlbGF5X2tleShrZXkpIHtcbiAgICAgICAgICAgIHZhciBzcGVjaWFscyA9IFsnSE9MRCtTSElGVCtCQUNLU1BBQ0UnLCAnSE9MRCtCQUNLU1BBQ0UnXTtcbiAgICAgICAgICAgIHJldHVybiBzcGVjaWFscy5pbmRleE9mKGtleSkgIT09IC0xICYmIHNldHRpbmdzLm1vYmlsZURlbGV0ZSB8fFxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnJlcGVhdFRpbWVvdXRLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIGNsZWFyX3JldmVyc2Vfc2VhcmNoX2tleShlKSB7XG4gICAgICAgICAgICAvLyBhcnJvd3MgLyBIb21lIC8gRW5kIC8gRU5URVJcbiAgICAgICAgICAgIHJldHVybiBlLndoaWNoID09PSAzNSB8fCBlLndoaWNoID09PSAzNiB8fFxuICAgICAgICAgICAgICAgIGUud2hpY2ggPT09IDM3IHx8IGUud2hpY2ggPT09IDM4IHx8XG4gICAgICAgICAgICAgICAgZS53aGljaCA9PT0gMzkgfHwgZS53aGljaCA9PT0gNDAgfHxcbiAgICAgICAgICAgICAgICBlLndoaWNoID09PSAxMyB8fCBlLndoaWNoID09PSAyNztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2tpcF9rZXlkb3duID0gZmFsc2U7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBmdW5jdGlvbiBjb21wbGV4aWNpdHkgaXMgMzUgd2hlbiBhZGRpbmcgdGhpcyBleGNlcHRpb25cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICAgICAgZnVuY3Rpb24ga2V5ZG93bl9ldmVudChlKSB7XG4gICAgICAgICAgICBkZWJ1Zygna2V5ZG93biBcIicgKyBlLmtleSArICdcIiAnICsgZS5mYWtlICsgJyAnICsgZS53aGljaCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcHJvY2VzcyA9IChlLmtleSB8fCAnJykudG9Mb3dlckNhc2UoKSA9PT0gJ3Byb2Nlc3MnIHx8IGUud2hpY2ggPT09IDA7XG4gICAgICAgICAgICBkZWFkX2tleSA9IG5vX2tleXByZXNzICYmIHNpbmdsZV9rZXkgJiYgIWlzX2JhY2tzcGFjZShlKTtcbiAgICAgICAgICAgIC8vIHNwZWNpYWwga2V5cyBkb24ndCB0cmlnZ2VyIGtleXByZXNzIGZpeCAjMjkzXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghZS5mYWtlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZV9rZXkgPSBpc19zaW5nbGUoZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNocm9tZSBvbiBhbmRyb2lkIHN1cHBvcnQga2V5IHByb3BlcnR5IGJ1dCBpdCdzIFwiVW5pZGVudGlmaWVkXCJcbiAgICAgICAgICAgICAgICAgICAgbm9fa2V5ID0gU3RyaW5nKGUua2V5KS50b0xvd2VyQ2FzZSgpID09PSAndW5pZGVudGlmaWVkJztcbiAgICAgICAgICAgICAgICAgICAgYmFja3NwYWNlID0gaXNfYmFja3NwYWNlKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgIC8vIGtleWRvd24gY3JlYXRlZCBpbiBpbnB1dCB3aWxsIGhhdmUgdGV4dCBhbHJlYWR5IGluc2VydGVkIGFuZCB3ZVxuICAgICAgICAgICAgLy8gd2FudCB0ZXh0IGJlZm9yZSBpbnB1dFxuICAgICAgICAgICAgaWYgKGUua2V5ID09PSBcIlVuaWRlbnRpZmllZFwiKSB7XG4gICAgICAgICAgICAgICAgbm9fa2V5ZG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gYW5kcm9pZCBzd2lmdCBrZXlib2FyZCBoYXZlIGFsd2F5cyB3aGljaCA9PSAyMjkgd2Ugd2lsbCB0cmlnZXIgcHJvcGVyXG4gICAgICAgICAgICAgICAgLy8gZXZlbnQgaW4gaW5wdXQgd2l0aCBlLmZha2UgPT0gdHJ1ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZS5mYWtlKSB7XG4gICAgICAgICAgICAgICAgbm9fa2V5ZG93biA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9fa2V5cHJlc3MgPSB0cnVlO1xuICAgICAgICAgICAgLy8gTWV0YStWIGRpZCBiaW5kIGlucHV0IGJ1dCBpdCBkaWRpbid0IGhhcHBlbiBiZWNhdXNlIHRlcm1pbmFsIHBhc3RlXG4gICAgICAgICAgICAvLyBwcmV2ZW50IG5hdGl2ZSBpbnNlcnQgYWN0aW9uXG4gICAgICAgICAgICBjbGlwLm9mZignaW5wdXQnLCBwYXN0ZSk7XG4gICAgICAgICAgICB2YXIga2V5ID0gZ2V0X2tleShlKTtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihzZXR0aW5ncy5rZXlkb3duKSkge1xuICAgICAgICAgICAgICAgIGUua2V5ID0gaWVfa2V5X2ZpeChlKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXR0aW5ncy5rZXlkb3duLmNhbGwoc2VsZiwgZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vc2tpcF9rZXlwcmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwX2luc2VydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBwcmV2X2tleSkge1xuICAgICAgICAgICAgICAgIGNsZWFyX2hvbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENUUkwrQyBoYW5sZGluZyBpcyBvbmx5IGV4Y2VwdGlvbiBvZiBjbWQgYXdhcmUgdGVybWluYWwgbG9naWNcbiAgICAgICAgICAgIC8vIGNtZCBuZWVkIHRvIGNhbGwgQ1RSTCtDIGtleW1hcCB3aGVuIHRlcm1pbmFsIGlzIG5vdCBlbmFibGVkXG4gICAgICAgICAgICBpZiAoZW5hYmxlZCB8fCAoa2V5ID09PSAnQ1RSTCtDJyAmJiBpc190ZXJtaW5hbF9zZWxlY3RlZChzZWxmKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2X2tleSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gJ0hPTEQrJyArIGtleTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRfcGF1c2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuaG9sZFJlcGVhdFRpbWVvdXQgPiAwICYmIGlzX2RlbGF5X2tleShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkX3BhdXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25lVGltZShzZXR0aW5ncy5ob2xkUmVwZWF0VGltZW91dCwgJ2RlbGF5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZF9wYXVzZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uZVRpbWUoc2V0dGluZ3MuaG9sZFRpbWVvdXQsICdob2xkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZfa2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBlLmZha2UgaWdub3JlIG9mIHNwYWNlIGlzIGhhbmRsZWQgaW4gaW5wdXQgYW5kIG5leHQga2V5ZG93blxuICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0cmlnZ2VyZWQgdGhpcyBpcyBqdXN0IGluIGNhc2UgY29kZSBzaW5jZSBvbiBBbmRyb2lkXG4gICAgICAgICAgICAgICAgLy8ga2V5ZG93biBpcyBub3QgdHJpZ2dlcmVkIG9ubHkgaW5wdXQgc28gZXZlbnQgaXMgYWx3YXlzIGZha2Ugb24gQW5kcm9pZFxuICAgICAgICAgICAgICAgIGlmICghZS5mYWtlICYmIGlzX2FuZHJvaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBfa2V5ZG93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfaG9sZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcF9rZXlkb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vYmlsZV9pZ25vcmVfa2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBfa2V5ZG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9iaWxlX2lnbm9yZV9rZXkocHJldl9rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGluIGNhc2UgbmV4dCBrZXkgaXMgZGlmZmVyZW50IHRoZW4gc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBfa2V5ZG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3RhcnRfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gQ1RSTCtWIGRvbid0IGZpcmUga2V5cHJlc3MgaW4gSUUxMVxuICAgICAgICAgICAgICAgIHNraXBfaW5zZXJ0ID0gWydDVFJMK1YnLCAnTUVUQStWJ10uaW5kZXhPZihrZXkpICE9PSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoZS53aGljaCAhPT0gMzggJiYgIShlLndoaWNoID09PSA4MCAmJiBlLmN0cmxLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X3VwX2hpc3RvcnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmV2ZXJzZV9zZWFyY2ggJiYgY2xlYXJfcmV2ZXJzZV9zZWFyY2hfa2V5KGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyX3JldmVyc2Vfc3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgZHJhd19wcm9tcHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDI3KSB7IC8vIEVTQ1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXQoJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleWRvd25fZXZlbnQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNfZnVuY3Rpb24oa2V5bWFwW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGtleW1hcFtrZXldKGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLmFsdEtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcF9rZXlwcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBwcmV2ZW50IGZvciBpbnN0YW5jZSBiYWNrc3BhY2UgdG8gZ28gYmFjayBvbmUgcGFnZVxuICAgICAgICAgICAgICAgIC8vc2tpcF9rZXlwcmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy9lLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xlYXJfaG9sZCgpIHtcbiAgICAgICAgICAgIHNlbGYuc3RvcFRpbWUoJ2hvbGQnKTtcbiAgICAgICAgICAgIHNlbGYuc3RvcFRpbWUoJ2RlbGF5Jyk7XG4gICAgICAgICAgICBob2xkX3BhdXNlID0gaG9sZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkb2MgPSAkKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCB3aW5kb3cpO1xuICAgICAgICBzZWxmLmtleW1hcChzZXR0aW5ncy5rZXltYXAgfHwge30pO1xuICAgICAgICBmdW5jdGlvbiBrZXlwcmVzc19ldmVudChlKSB7XG4gICAgICAgICAgICBkZWJ1Zygna2V5cHJlc3MgXCInICsgZS5rZXkgKyAnXCIgJyArIGUuZmFrZSk7XG4gICAgICAgICAgICBjbGVhcl9ob2xkKCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKCFlLmZha2UpIHtcbiAgICAgICAgICAgICAgICBub19rZXlwcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSAmJiAhZS5hbHRLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2tpcF9rZXlwcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihzZXR0aW5ncy5rZXlwcmVzcykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXR0aW5ncy5rZXlwcmVzcy5jYWxsKHNlbGYsIGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcF9pbnNlcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5mYWtlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50IGNyZWF0ZWQgaW4gaW5wdXQsIHdlIHByZXZlbnQgaW5zZXJ0aW5nIHRleHRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gZGlmZmVyZW50IGludGVycHJldGVyIHdoZW4ga2V5ZG93biBjYWxsZWQgcG9wXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8ga2V5IHBvbHlmaWxsIGlzIG5vdCBjb3JyZWN0IGZvciBrZXlwcmVzc1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jdmFuL2tleWJvYXJkZXZlbnQta2V5LXBvbHlmaWxsL2lzc3Vlcy8xNVxuICAgICAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICAgICAgaWYgKGlzX2tleV9uYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gZS5rZXk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpeGluZyBJRSBpbmNvbnNpc3RlbmN5ICMzNjJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBrZXkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleV9tYXBwaW5nW25vcm1hbGl6ZWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlfbWFwcGluZ1tub3JtYWxpemVkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWtleSB8fCBub19rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZShlLndoaWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheShlLndoaWNoLCBbMTMsIDAsIDhdKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDEyMykgeyAvLyBmb3IgRjEyIHdoaWNoID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCA9PT0gMTAwIC0gZFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ICYmICghZS5jdHJsS2V5IHx8IChlLmN0cmxLZXkgJiYgZS5jdHJsS2V5KSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICghKGUuYWx0S2V5ICYmIGUud2hpY2ggPT09IDEwMCkgfHwgZS5hbHRLZXkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAhZGVhZF9rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVhZF9rZXkgYXJlIGhhbmRsZWQgYnkgaW5wdXQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldmVyc2Vfc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZfc2VhcmNoX3N0ciArPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlX2hpc3Rvcnlfc2VhcmNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3X3JldmVyc2VfcHJvbXB0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnNlcnQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBldmVudCh0eXBlLCBjaHIsIHdoaWNoKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSAkLkV2ZW50KHR5cGUpO1xuICAgICAgICAgICAgZXZlbnQud2hpY2ggPSB3aGljaDtcbiAgICAgICAgICAgIGV2ZW50LmtleSA9IGNocjtcbiAgICAgICAgICAgIGV2ZW50LmZha2UgPSB0cnVlO1xuICAgICAgICAgICAgZG9jLnRyaWdnZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBza2lwX2lucHV0ID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIGlucHV0X2V2ZW50KCkge1xuICAgICAgICAgICAgZGVidWcoJ2lucHV0ICcgKyBub19rZXlkb3duICsgJyB8fCAnICsgcHJvY2VzcyArICcgKCgnICsgbm9fa2V5cHJlc3MgK1xuICAgICAgICAgICAgICAgICAgJyB8fCAnICsgZGVhZF9rZXkgKyAnKSAmJiAhJyArIHNraXBfaW5zZXJ0ICsgJyAmJiAoJyArIHNpbmdsZV9rZXkgK1xuICAgICAgICAgICAgICAgICAgJyB8fCAnICsgbm9fa2V5ICsgJykgJiYgIScgKyBiYWNrc3BhY2UgKyAnKScpO1xuICAgICAgICAgICAgLy8gY29ycmVjdCBmb3IgZmFrZSBzcGFjZSB1c2VkIGZvciBzZWxlY3QgYWxsIGNvbnRleHQgbWVudSBoYWNrXG4gICAgICAgICAgICB2YXIgdmFsID0gY2xpcC52YWwoKTtcbiAgICAgICAgICAgIGlmICghaXNfbW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL14gLywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZSBBbmRyb2lkcyBkb24ndCBmaXJlIGtleXByZXNzIC0gIzM5XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBkZWFkX2tleSB3ZSBhbHNvIG5lZWQgdG8gZ3JhYiByZWFsIGNoYXJhY3RlciAjMTU4XG4gICAgICAgICAgICAvLyBGaXJlZm94L0FuZHJvaWQgd2l0aCBnb29nbGUga2V5Ym9hcmQgZG9uJ3QgZmlyZSBrZXlkb3duIGFuZCBrZXl1cCAjMzE5XG4gICAgICAgICAgICBpZiAoKG5vX2tleWRvd24gfHwgcHJvY2VzcyB8fCAoKG5vX2tleXByZXNzIHx8IGRlYWRfa2V5KSAmJiAhc2tpcF9pbnNlcnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzaW5nbGVfa2V5IHx8IG5vX2tleSkgJiYgIWJhY2tzcGFjZSkpICYmXG4gICAgICAgICAgICAgICAgdmFsICE9PSBjb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIC8vIGJhY2tzcGFjZSBpcyBzZXQgaW4ga2V5ZG93biBpZiBubyBrZXlkb3duIHdlIG5lZWQgdG8gZ2V0IG5ldyBvbmVcbiAgICAgICAgICAgICAgICBpZiAobm9fa2V5ZG93bikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY21kID0gcHJldl9jb21tYW5kO1xuICAgICAgICAgICAgICAgICAgICBiYWNrc3BhY2UgPSBjbWQuc2xpY2UoMCwgY21kLmxlbmd0aCAtIDEpLmxlbmd0aCA9PT0gdmFsLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNraXBfaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcF9pbnB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjbGlwLnZhbChjb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmV2ZXJzZV9zZWFyY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2X3NlYXJjaF9zdHIgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VfaGlzdG9yeV9zZWFyY2goKTtcbiAgICAgICAgICAgICAgICAgICAgZHJhd19yZXZlcnNlX3Byb21wdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSB2YWwuc2xpY2UocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMSB8fCBiYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIG5vdCBvcHRpbWl6ZWQgZnVuY3Rpb24gY2FsbGVkIG9uY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHIgPSBnZXRfbmV4dF9jaGFyYWN0ZXIoc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2JpbGVfaWdub3JlX2tleShjaHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcF9pbnB1dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB0cmlnZ2VyIGV2ZW50cyBzbyBrZXlwcmVzcyBhbmQga2V5ZG93biBjYWxsYmFjayB3b3JrXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9fa2V5ZG93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXljb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5Y29kZSA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5Y29kZSA9IHN0ci50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50KCdrZXlkb3duJywgYmFja3NwYWNlID8gJ0JhY2tzcGFjZScgOiBzdHIsIGtleWNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vX2tleXByZXNzICYmICFiYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudCgna2V5cHJlc3MnLCBjaHIsIHN0ci5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYmFja3NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2X2NvbW1hbmQgPSBjb21tYW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIgcmV0dXJuIGZhbHNlIGluIGtleWRvd24gd2UgZG9uJ3Qgd2FudCB0byBpbnNlcnQgdGV4dFxuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcF9pbnNlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBfaW5zZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXQodmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJhY2tzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnBvc2l0aW9uKHBvcyAtIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZXIgZW50ZXIgbW9yZSB0aGVuIG9uZSBjaGFyYWN0ZXIgaWYgY2xpY2sgb24gY29tcGxldGUgd29yZFxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBhbmRyb2lkXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucG9zaXRpb24ocG9zICsgTWF0aC5hYnModmFsLmxlbmd0aCAtIHByZXZfY29tbWFuZC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2X2NvbW1hbmQgPSBjb21tYW5kO1xuICAgICAgICAgICAgc2tpcF9pbnNlcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIG5vX2tleWRvd24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGRvYy5iaW5kKCdrZXlwcmVzcy5jbWQnLCBrZXlwcmVzc19ldmVudCk7XG4gICAgICAgIGRvYy5iaW5kKCdrZXlkb3duLmNtZCcsIGtleWRvd25fZXZlbnQpO1xuICAgICAgICBkb2MuYmluZCgna2V5dXAuY21kJywgY2xlYXJfaG9sZCk7XG4gICAgICAgIGRvYy5iaW5kKCdpbnB1dC5jbWQnLCBpbnB1dF9ldmVudCk7XG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB3YXNfZG93biA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHNlbGYub24oJ21vdXNlZG93bi5jbWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3YXNfZG93biA9IHRydWU7XG4gICAgICAgICAgICB9KS5vbignbW91c2V1cC5jbWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdHJpZ2dlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzX3Byb21wdCA9ICR0YXJnZXQuaXMoJy5jbWQtcHJvbXB0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNfcHJvbXB0ICYmIGRvd24gJiYgZ2V0X3NlbGVjdGVkX2h0bWwoKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR0YXJnZXQuaXMoJy5jbWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBvc2l0aW9uKHRleHQoY29tbWFuZCkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc3BsYXlfcG9zaXRpb24oZ2V0X2NoYXJfcG9zKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB3ZSBnZXQgYnV0dG9uIGZyb20gZXZlbnQgZm9yIHRlc3Rpbmcgbm9ybWFsbHkgaXQncyBvbiBvcmlnaW5hbEV2ZW50XG4gICAgICAgICAgICAgICAgdmFyIGJ1dHRvbjtcbiAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gZS5idXR0b247XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gZS5vcmlnaW5hbEV2ZW50LmJ1dHRvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJ1dHRvbiA9PT0gMCAmJiBnZXRfc2VsZWN0ZWRfaHRtbCgpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9ICdjbGlja18nICsgaWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG93biA9IHdhc19kb3duO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuY2xpY2tUaW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9uZVRpbWUoc2V0dGluZ3MuY2xpY2tUaW1lb3V0LCBuYW1lLCB0cmlnZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc3RvcFRpbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2FzX2Rvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgICBzZWxmLmRhdGEoJ2NtZCcsIHNlbGYpO1xuICAgICAgICBpZiAoISgnS2V5Ym9hcmRFdmVudCcgaW4gd2luZG93ICYmICdrZXknIGluIHdpbmRvdy5LZXlib2FyZEV2ZW50LnByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXkgZXZlbnQgcHJvcGVydHkgbm90IHN1cHBvcnRlZCB0cnkgaHR0cHM6Ly9naXRodWIuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb20vaW5leG9yYWJsZXRhc2gvcG9seWZpbGwvYmxvYi9tYXN0ZXIva2V5Ym9hcmQuanMnKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07IC8vIGNtZCBwbHVnaW5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIHN0cmxlbiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3Y3dpZHRoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLnRlcm1pbmFsLmxlbmd0aChzdHJpbmcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB3Y3dpZHRoO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gY291bnRfc2VsZmNsb3NpbmdfZm9ybWF0dGluZyhzdHJpbmcpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgaWYgKCQudGVybWluYWwuaGF2ZV9mb3JtYXR0aW5nKHN0cmluZykpIHtcbiAgICAgICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoZm9ybWF0X3BhcnRzX3JlLCAnaScpO1xuICAgICAgICAgICAgJC50ZXJtaW5hbC5mb3JtYXRfc3BsaXQoc3RyaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgIGlmICgkLnRlcm1pbmFsLmlzX2Zvcm1hdHRpbmcoc3RyKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHN0ci5tYXRjaChyZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtICYmIG1bMV0ubWF0Y2goL0AvKSAmJiBtWzZdID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGJhcmVfdGV4dChzdHJpbmcpIHtcbiAgICAgICAgaWYgKCFzdHJpbmcubWF0Y2goLyYvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJCgnPHNwYW4+JyArIHNhZmUoc3RyaW5nKSArICc8L3NwYW4+JykudGV4dCgpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gdGV4dChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGJhcmVfdGV4dCgkLnRlcm1pbmFsLnN0cmlwKHN0cmluZykpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gc2FmZShzdHJpbmcpIHtcbiAgICAgICAgaWYgKCFzdHJpbmcubWF0Y2goL1s8PiZdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8mKD8hW147XSs7KS9nLCAnJmFtcDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBjcmxmKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcci9nLCAnJyk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBjaGFyX2xlbihjaHIpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eV9yZS50ZXN0KGNocikgPyAxIDogY2hyLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIG1ha2VfcmVfZm4ocmUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIG0gPSBzdHJpbmcubWF0Y2gocmUpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0c193aXRoKG0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBzdGFydHNfd2l0aChtYXRjaCkge1xuICAgICAgICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2guaW5kZXggPT09IDA7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiBvcHRpbWl6ZWQgaGlnaGVyIG9yZGVyIGZ1bmN0aW9uIHRoYXQgaXQgY2hlY2sgY29tcGxleCByZWdleGVzXG4gICAgLy8gOjogb25seSB3aGVuIGJpZ2dlciBzdHJpbmcgbWF0Y2ggdGhvc2UgcmVnZXhlcywgZnVuY3Rpb24gaXMgYWx3YXlzXG4gICAgLy8gOjogdXNlZCBpbiBsb29wIHdoZW4geW91IHByb2Nlc3Mgd2hvbGUgc3RyaW5nLCBpdCdzIHVzZWQgdG8gY3JlYXRlIGxvY2FsXG4gICAgLy8gOjogZ2V0X25leHRfY2hhcmFjdGVyIGZ1bmN0aW9uIG9ubHkgY21kIGluIGlucHV0IHVzZSBvcmlnaW5hbFxuICAgIC8vIDo6IG5vdCBvcHRpbWl6ZWQgZnVuY3Rpb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gbWFrZV9uZXh0X2NoYXJfZnVuKHN0cmluZykge1xuICAgICAgICB2YXIgdGVzdHMgPSBbXTtcbiAgICAgICAgW1xuICAgICAgICAgICAgZW50aXR5X3JlLFxuICAgICAgICAgICAgZW1vamlfcmUsXG4gICAgICAgICAgICBjb21iaW5lX2Nocl9yZVxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24ocmUpIHtcbiAgICAgICAgICAgIGlmIChzdHJpbmcubWF0Y2gocmUpKSB7XG4gICAgICAgICAgICAgICAgdGVzdHMucHVzaChtYWtlX3JlX2ZuKHJlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RyaW5nLm1hdGNoKGFzdHJhbF9zeW1ib2xzX3JlKSkge1xuICAgICAgICAgICAgdGVzdHMucHVzaChmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbTEgPSBzdHJpbmcubWF0Y2goYXN0cmFsX3N5bWJvbHNfcmUpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydHNfd2l0aChtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0yID0gc3RyaW5nLm1hdGNoKGNvbWJpbmVfY2hyX3JlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0yICYmIG0yLmluZGV4ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIDMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtMVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlc3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlc3QgPSB0ZXN0c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gdGVzdChzdHJpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nWzBdO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gOjogZnVuY3Rpb24gdGhhdCByZXR1cm4gY2hhcmFjdGVyIGZyb20gYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmdcbiAgICAvLyA6OiBjb3VudGluZyBlbW9qaSwgc3Vyb2dnYXRlIHBhaXJzIGFuZCBjb21iaW5lIGNoYXJhY3RlcnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gZ2V0X25leHRfY2hhcmFjdGVyKHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hfZW50aXR5ID0gc3RyaW5nLm1hdGNoKGVudGl0eV9yZSk7XG4gICAgICAgIGlmIChzdGFydHNfd2l0aChtYXRjaF9lbnRpdHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hfZW50aXR5WzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaF9jb21ibyA9IHN0cmluZy5tYXRjaChjb21iaW5lX2Nocl9yZSk7XG4gICAgICAgIGlmIChzdGFydHNfd2l0aChtYXRjaF9jb21ibykpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaF9jb21ib1sxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hfZW1vamkgPSBzdHJpbmcubWF0Y2goZW1vamlfcmUpO1xuICAgICAgICBpZiAoc3RhcnRzX3dpdGgobWF0Y2hfZW1vamkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hfZW1vamlbMV07XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPCAyNTUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXN0cmFsX21hdGNoID0gc3RyaW5nLm1hdGNoKGFzdHJhbF9zeW1ib2xzX3JlKTtcbiAgICAgICAgICAgIGlmIChzdGFydHNfd2l0aChhc3RyYWxfbWF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hfY29tYm8gPSBzdHJpbmcubWF0Y2goY29tYmluZV9jaHJfcmUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaF9jb21ibyAmJiBtYXRjaF9jb21iby5pbmRleCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBub3JtYWxpemUgcG9zaXRpb24gZm9yIGNvdW50aW5nIGVtb2ppIGFuZCBleHRyYSBjaGFyc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVfcG9zaXRpb24oc3RyaW5nLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmcgPSAkLnRlcm1pbmFsLnN0cmlwKHN0cmluZyk7XG4gICAgICAgIHZhciByZXN1bHQgPSAkLnRlcm1pbmFsLnNwbGl0X2NoYXJhY3RlcnMoc3RyaW5nKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBjaHIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWNjID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gYWNjLmxlbmd0aCArIGNoYXJfbGVuKGNocik7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID49IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYy5wb3NpdGlvbiArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBhY2MucG9zaXRpb24gKyAxLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7cG9zaXRpb246IDAsIGxlbmd0aDogMH0pO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBjaGFyX3dpZHRoX3Byb3AobGVuLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChpc19jaF91bml0X3N1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuICd3aWR0aDogJyArIGxlbiArICdjaCc7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzX2Nzc192YXJpYWJsZXNfc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFyX3dpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd3aWR0aDogJyArIChvcHRpb25zLmNoYXJfd2lkdGggKiBsZW4pICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnLS1sZW5ndGg6ICcgKyBsZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gb3B0aW9ucyB7Y2hhcl93aWR0aH1cbiAgICBmdW5jdGlvbiBleHRyYV9jc3ModGV4dCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIHdjd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgYmFyZSA9IGJhcmVfdGV4dCh0ZXh0KTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBzdHJsZW4oYmFyZSk7XG4gICAgICAgICAgICBpZiAobGVuICE9PSAkLnRlcm1pbmFsLmxlbmd0aChiYXJlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFyX3dpZHRoX3Byb3AobGVuLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiB3aWRlX2NoYXJhY3RlcnModGV4dCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIHdjd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgYmFyZSA9IGJhcmVfdGV4dCh0ZXh0KTtcbiAgICAgICAgICAgIHZhciBjaGFycyA9ICQudGVybWluYWwuc3BsaXRfY2hhcmFjdGVycyhiYXJlKTtcbiAgICAgICAgICAgIGlmIChjaGFycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzcGVjcyA9IGNoYXJzLm1hcChmdW5jdGlvbihjaHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsZW46IHN0cmxlbihjaHIpLFxuICAgICAgICAgICAgICAgICAgICBjaHI6IGNoclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24oYXJyLCBzcGVjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0LmxlbiAhPT0gc3BlYy5sZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnIuY29uY2F0KFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtOiBzcGVjLmxlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW46IHNwZWMubGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNzOiBbc3BlY11cbiAgICAgICAgICAgICAgICAgICAgICAgIH1dKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnIuY29uY2F0KFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtOiBsYXN0LnN1bSArIHNwZWMubGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbjogbGFzdC5sZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlY3M6IGxhc3Quc3BlY3MuY29uY2F0KHNwZWMpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgIHN1bTogc3BlYy5sZW4sXG4gICAgICAgICAgICAgICAgICAgIHNwZWNzOiBbc3BlY10sXG4gICAgICAgICAgICAgICAgICAgIGxlbjogc3BlYy5sZW5cbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBzcGVjcy5tYXAoZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjLmxlbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BlYy5jaHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGNoYXJfd2lkdGhfcHJvcChzcGVjLnN1bSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMuc3VtID09PSBjaGFycy5sZW5ndGggfHwgIXN0eWxlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxzcGFuPicgKyBtYWtlX3N0cmluZyhzcGVjKSArICc8L3NwYW4+JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWMuc3BlY3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcChzdHlsZSwgc3BlYy5zcGVjcy5tYXAoZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXAoY2hhcl93aWR0aF9wcm9wKHNwZWMubGVuKSwgc3BlYy5jaHIpO1xuICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXAoc3R5bGUsIG1ha2Vfc3RyaW5nKHNwZWMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlX3N0cmluZyhzcGVjKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlYy5zcGVjcy5tYXAoZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjLmNocjtcbiAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdyYXAoc3R5bGUsIHN0cikge1xuICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBzdHlsZT1cIicgKyBzdHlsZSArICdcIj4nICsgc3RyICsgJzwvc3Bhbj4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiBCaW5hcnkgc2VhcmNoIHV0aWxpdHlcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBiaW5hcnlfc2VhcmNoKHN0YXJ0LCBlbmQsIHNlYXJjaF9wb3MsIGNvbXBhcmVfZm4sIG1vcmVfYXJncykge1xuICAgICAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgIHZhciBtaWQgPSBzdGFydCArIE1hdGguZmxvb3IobGVuIC8gMik7XG4gICAgICAgIHZhciBhcmdzID0gW3NlYXJjaF9wb3MsIG1pZF0uY29uY2F0KG1vcmVfYXJncyk7XG4gICAgICAgIHZhciBjbXAgPSBjb21wYXJlX2ZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICB9IGVsc2UgaWYgKGNtcCA+IDAgJiYgbGVuID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmFyeV9zZWFyY2goXG4gICAgICAgICAgICAgICAgbWlkLFxuICAgICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgICAgICBzZWFyY2hfcG9zLFxuICAgICAgICAgICAgICAgIGNvbXBhcmVfZm4sXG4gICAgICAgICAgICAgICAgbW9yZV9hcmdzXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKGNtcCA8IDAgJiYgbGVuID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmFyeV9zZWFyY2goXG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgbWlkLFxuICAgICAgICAgICAgICAgIHNlYXJjaF9wb3MsXG4gICAgICAgICAgICAgICAgY29tcGFyZV9mbixcbiAgICAgICAgICAgICAgICBtb3JlX2FyZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiBzZWxlY3Rpb24gdXRpbGl0aWVzIC0gc2hvdWxkIHdvcmsgaW4gbW9kZXJuIGJyb3dzZXIgaW5jbHVkaW5nIElFOVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gaXNfdGVybWluYWxfc2VsZWN0ZWQoY21kKSB7XG4gICAgICAgIGlmIChpc19mdW5jdGlvbih3aW5kb3cuZ2V0U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24udG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCkuc3RhcnRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB2YXIgdGVybSA9ICQobm9kZSkuY2xvc2VzdCgnLnRlcm1pbmFsJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlcm0ubGVuZ3RoICYmIChjbWQgJiYgdGVybS5maW5kKCcuY21kJykuaXMoY21kKSB8fCAhY21kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGdldF9zZWxlY3RlZF9odG1sKCkge1xuICAgICAgICB2YXIgaHRtbCA9ICcnO1xuICAgICAgICBpZiAoaXNfZnVuY3Rpb24od2luZG93LmdldFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoc2VsLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbC5yYW5nZUNvdW50OyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHNlbC5nZXRSYW5nZUF0KGkpLmNsb25lQ29udGVudHMoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGh0bWwgPSBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIHdpdGhfc2VsZWN0aW9uKGZuKSB7XG4gICAgICAgIHZhciBodG1sID0gJyc7XG4gICAgICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKHdpbmRvdy5nZXRTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGVjdGlvbi5yYW5nZUNvdW50OyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoaSkuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyYW5nZS5jbG9uZUNvbnRlbnRzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBodG1sID0gY29udGFpbmVyLmlubmVySFRNTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmbihodG1sKTtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodG1sICE9PSAnJztcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBwcm9jZXNzX3NlbGVjdGVkX2xpbmUoKSB7XG4gICAgICAgIHZhciAkc2VsZiA9ICQodGhpcyk7XG4gICAgICAgIHZhciByZXN1bHQgPSAkc2VsZi50ZXh0KCk7XG4gICAgICAgIGlmICgkc2VsZi5oYXNDbGFzcygnY21kLWVuZC1saW5lJykpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NfZGl2KGVsZW1lbnQpIHtcbiAgICAgICAgLy8gc3BhbiBpcyBlbXB0eSBsaW5lLCBkaXYgaXMgZGVmYXVsdCBjYXNlIHdpdGggdGV4dFxuICAgICAgICByZXR1cm4gJChlbGVtZW50KS5maW5kKCc+IGRpdiwgPiBzcGFuJylcbiAgICAgICAgICAgIC5tYXAocHJvY2Vzc19zZWxlY3RlZF9saW5lKS5nZXQoKS5qb2luKCdcXG4nKS5yZXBsYWNlKC9cXG4kLywgJycpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIHByb2Nlc3Nfc2VsZWN0ZWRfaHRtbChodG1sKSB7XG4gICAgICAgIHZhciBzdGRvdXQ7XG4gICAgICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgICAgIHZhciAkaHRtbCA9ICQoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XG4gICAgICAgIGlmIChodG1sLm1hdGNoKC88XFwvZGl2Pi8pKSB7XG4gICAgICAgICAgICAvLyBtYXRjaCBtdWx0aXBsZSBlY2hvIG91dHB1dFxuICAgICAgICAgICAgc3Rkb3V0ID0gJGh0bWwuZmluZCgnZGl2W2RhdGEtaW5kZXhdJykubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzX2Rpdih0aGlzKTtcbiAgICAgICAgICAgIH0pLmdldCgpLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgLy8gbWF0Y2ggaW5zaWRlIHNpbmdsZSBlY2hvIG91dHB1dFxuICAgICAgICAgICAgaWYgKCFzdGRvdXQgJiYgaHRtbC5tYXRjaCgvc3R5bGU9XCJ3aWR0aDogMTAwJTs/XCIvKSkge1xuICAgICAgICAgICAgICAgIHN0ZG91dCA9IHByb2Nlc3NfZGl2KCRodG1sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgPSBzdGRvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyICRwcm9tcHQgPSAkaHRtbC5maW5kKCcuY21kLXByb21wdCcpO1xuICAgICAgICBpZiAoJHByb21wdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ICs9ICRwcm9tcHQudGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAkY21kX2xpbmVzID0gJGh0bWwuZmluZCgnW3JvbGU9XCJwcmVzZW50YXRpb25cIl0nKTtcbiAgICAgICAgaWYgKCRjbWRfbGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0ZXh0ICs9ICRjbWRfbGluZXMubWFwKHByb2Nlc3Nfc2VsZWN0ZWRfbGluZSkuZ2V0KCkuam9pbignJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0ZXh0Lmxlbmd0aCAmJiBodG1sKSB7XG4gICAgICAgICAgICB0ZXh0ID0gJGh0bWwudGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xceEEwL2csICcgJyk7IC8vIGZpeCAmbmJzcDsgc3BhY2VcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gOjogY29weSBnaXZlbiBET00gZWxlbWVudCB0ZXh0IHRvIGNsaXBib2FyZFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciB0ZXh0X3RvX2NsaXBib2FyZDtcbiAgICBpZiAoaXNfZnVuY3Rpb24oZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkKSAmJlxuICAgICAgICBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQoJ2NvcHknKSkge1xuICAgICAgICB0ZXh0X3RvX2NsaXBib2FyZCA9IGZ1bmN0aW9uIHRleHRfdG9fY2xpcGJvYXJkKCR0ZXh0YXJlYSwgdGV4dCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9ICR0ZXh0YXJlYS52YWwoKTtcbiAgICAgICAgICAgIHZhciBoYWRfZm9jdXMgPSAkdGV4dGFyZWEuaXMoJzpmb2N1cycpO1xuICAgICAgICAgICAgdmFyIHBvcyA9ICR0ZXh0YXJlYS5jYXJldCgpO1xuICAgICAgICAgICAgJHRleHRhcmVhLnZhbCh0ZXh0KS5mb2N1cygpO1xuICAgICAgICAgICAgJHRleHRhcmVhWzBdLnNlbGVjdCgpO1xuICAgICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2NvcHknKTtcbiAgICAgICAgICAgICR0ZXh0YXJlYS52YWwodmFsKTtcbiAgICAgICAgICAgIGlmIChoYWRfZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAkdGV4dGFyZWEuY2FyZXQocG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHRfdG9fY2xpcGJvYXJkID0gJC5ub29wO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgZ2V0X3RleHRhcmVhX3NlbGVjdGlvbiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gJ3NlbGVjdGlvblN0YXJ0JyBpbiB0ZXh0YXJlYTtcbiAgICAgICAgdGV4dGFyZWEgPSBudWxsO1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0ZXh0YXJlYSkge1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB0ZXh0YXJlYS5zZWxlY3Rpb25FbmQgLSB0ZXh0YXJlYS5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dGFyZWEudmFsdWUuc3Vic3RyKHRleHRhcmVhLnNlbGVjdGlvblN0YXJ0LCBsZW5ndGgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UudGV4dCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBjbGVhcl90ZXh0YXJlYV9zZWxlY3Rpb24odGV4dGFyZWEpIHtcbiAgICAgICAgdGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQgPSB0ZXh0YXJlYS5zZWxlY3Rpb25FbmQgPSAwO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA6OiByZXR1cm4gc3RyaW5nIHRoYXQgYXJlIGNvbW1vbiBpbiBhbGwgZWxlbWVudHMgb2YgdGhlIGFycmF5XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gY29tbW9uX3N0cmluZyhzdHJpbmcsIGFycmF5LCBtYXRjaENhc2UpIHtcbiAgICAgICAgaWYgKCFhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZSA9IHN0cmluZ19jYXNlKHN0cmluZyk7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IHN0cmluZy5sZW5ndGg7IGogPCBhcnJheVswXS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdmFyIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSBhcnJheVswXS5jaGFyQXQoaiksXG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlTG93ZXIgPSBjYW5kaWRhdGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IGFycmF5W2ldLmNoYXJBdChqKSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExvd2VyID0gY3VycmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoQ2FzZSB8fCB0eXBlID09PSAnbWl4ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYW5kaWRhdGVMb3dlciA9PT0gY3VycmVudExvd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2xvd2VyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndXBwZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gY2FuZGlkYXRlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHB1c2gpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjYW5kaWRhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nICsgcmVzdWx0LmpvaW4oJycpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiB0cmlnZ2VyX3Rlcm1pbmFsX2NoYW5nZShuZXh0KSB7XG4gICAgICAgIHRlcm1pbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHRlcm0pIHtcbiAgICAgICAgICAgIHRlcm0uc2V0dGluZ3MoKS5vblRlcm1pbmFsQ2hhbmdlLmNhbGwodGVybSwgbmV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgc2VsZWN0ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uc2V0QmFzZUFuZEV4dGVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRCYXNlQW5kRXh0ZW50KHN0YXJ0LCAwLCBlbmQsIDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGVuZCwgZW5kLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJC5ub29wO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gcHJvY2Vzc19jb21tYW5kKHN0cmluZywgZm4pIHtcbiAgICAgICAgdmFyIGFycmF5ID0gc3RyaW5nLm1hdGNoKGNvbW1hbmRfcmUpIHx8IFtdO1xuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGFycmF5LnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgYXJncyA9ICQubWFwKGFycmF5LCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnLm1hdGNoKC9eW1wiJ10vKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcucmVwbGFjZSgvXFxuL2csICdcXFxcdTAwMDBcXFxcdTAwMDBcXFxcdTAwMDBcXFxcdTAwMDAnKTtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gZm4oYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5yZXBsYWNlKC9cXHgwMFxceDAwXFx4MDBcXHgwMC9nLCAnXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmbihhcmcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcXVvdGVzID0gJC5tYXAoYXJyYXksIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgIHZhciBtID0gYXJnLm1hdGNoKC9eKFsnXCJdKS4qXFwxJC8pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtICYmIG1bMV0gfHwgJyc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciByZXN0ID0gc3RyaW5nLnNsaWNlKG5hbWUubGVuZ3RoKS50cmltKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IHN0cmluZyxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgICAgICAgYXJnc19xdW90ZXM6IHF1b3RlcyxcbiAgICAgICAgICAgICAgICByZXN0OiByZXN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgbmFtZTogJycsXG4gICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICAgICAgYXJnc19xdW90ZXM6IHF1b3RlcyxcbiAgICAgICAgICAgICAgICByZXN0OiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgJC50ZXJtaW5hbCA9IHtcbiAgICAgICAgdmVyc2lvbjogJzIuMTIuMCcsXG4gICAgICAgIGRhdGU6ICdXZWQsIDAxIEphbiAyMDIwIDE3OjAzOjE2ICswMDAwJyxcbiAgICAgICAgLy8gY29sb3JzIGZyb20gaHR0cHM6Ly93d3cudzMub3JnL3dpa2kvQ1NTL1Byb3BlcnRpZXMvY29sb3Iva2V5d29yZHNcbiAgICAgICAgY29sb3JfbmFtZXM6IFtcbiAgICAgICAgICAgICd0cmFuc3BhcmVudCcsICdjdXJyZW50Y29sb3InLCAnYmxhY2snLCAnc2lsdmVyJywgJ2dyYXknLCAnd2hpdGUnLFxuICAgICAgICAgICAgJ21hcm9vbicsICdyZWQnLCAncHVycGxlJywgJ2Z1Y2hzaWEnLCAnZ3JlZW4nLCAnbGltZScsICdvbGl2ZScsXG4gICAgICAgICAgICAneWVsbG93JywgJ25hdnknLCAnYmx1ZScsICd0ZWFsJywgJ2FxdWEnLCAnYWxpY2VibHVlJyxcbiAgICAgICAgICAgICdhbnRpcXVld2hpdGUnLCAnYXF1YScsICdhcXVhbWFyaW5lJywgJ2F6dXJlJywgJ2JlaWdlJywgJ2Jpc3F1ZScsXG4gICAgICAgICAgICAnYmxhY2snLCAnYmxhbmNoZWRhbG1vbmQnLCAnYmx1ZScsICdibHVldmlvbGV0JywgJ2Jyb3duJyxcbiAgICAgICAgICAgICdidXJseXdvb2QnLCAnY2FkZXRibHVlJywgJ2NoYXJ0cmV1c2UnLCAnY2hvY29sYXRlJywgJ2NvcmFsJyxcbiAgICAgICAgICAgICdjb3JuZmxvd2VyYmx1ZScsICdjb3Juc2lsaycsICdjcmltc29uJywgJ2N5YW4nLCAnZGFya2JsdWUnLFxuICAgICAgICAgICAgJ2RhcmtjeWFuJywgJ2Rhcmtnb2xkZW5yb2QnLCAnZGFya2dyYXknLCAnZGFya2dyZWVuJywgJ2RhcmtncmV5JyxcbiAgICAgICAgICAgICdkYXJra2hha2knLCAnZGFya21hZ2VudGEnLCAnZGFya29saXZlZ3JlZW4nLCAnZGFya29yYW5nZScsXG4gICAgICAgICAgICAnZGFya29yY2hpZCcsICdkYXJrcmVkJywgJ2RhcmtzYWxtb24nLCAnZGFya3NlYWdyZWVuJyxcbiAgICAgICAgICAgICdkYXJrc2xhdGVibHVlJywgJ2RhcmtzbGF0ZWdyYXknLCAnZGFya3NsYXRlZ3JleScsICdkYXJrdHVycXVvaXNlJyxcbiAgICAgICAgICAgICdkYXJrdmlvbGV0JywgJ2RlZXBwaW5rJywgJ2RlZXBza3libHVlJywgJ2RpbWdyYXknLCAnZGltZ3JleScsXG4gICAgICAgICAgICAnZG9kZ2VyYmx1ZScsICdmaXJlYnJpY2snLCAnZmxvcmFsd2hpdGUnLCAnZm9yZXN0Z3JlZW4nLCAnZnVjaHNpYScsXG4gICAgICAgICAgICAnZ2FpbnNib3JvJywgJ2dob3N0d2hpdGUnLCAnZ29sZCcsICdnb2xkZW5yb2QnLCAnZ3JheScsICdncmVlbicsXG4gICAgICAgICAgICAnZ3JlZW55ZWxsb3cnLCAnZ3JleScsICdob25leWRldycsICdob3RwaW5rJywgJ2luZGlhbnJlZCcsICdpbmRpZ28nLFxuICAgICAgICAgICAgJ2l2b3J5JywgJ2toYWtpJywgJ2xhdmVuZGVyJywgJ2xhdmVuZGVyYmx1c2gnLCAnbGF3bmdyZWVuJyxcbiAgICAgICAgICAgICdsZW1vbmNoaWZmb24nLCAnbGlnaHRibHVlJywgJ2xpZ2h0Y29yYWwnLCAnbGlnaHRjeWFuJyxcbiAgICAgICAgICAgICdsaWdodGdvbGRlbnJvZHllbGxvdycsICdsaWdodGdyYXknLCAnbGlnaHRncmVlbicsICdsaWdodGdyZXknLFxuICAgICAgICAgICAgJ2xpZ2h0cGluaycsICdsaWdodHNhbG1vbicsICdsaWdodHNlYWdyZWVuJywgJ2xpZ2h0c2t5Ymx1ZScsXG4gICAgICAgICAgICAnbGlnaHRzbGF0ZWdyYXknLCAnbGlnaHRzbGF0ZWdyZXknLCAnbGlnaHRzdGVlbGJsdWUnLCAnbGlnaHR5ZWxsb3cnLFxuICAgICAgICAgICAgJ2xpbWUnLCAnbGltZWdyZWVuJywgJ2xpbmVuJywgJ21hZ2VudGEnLCAnbWFyb29uJyxcbiAgICAgICAgICAgICdtZWRpdW1hcXVhbWFyaW5lJywgJ21lZGl1bWJsdWUnLCAnbWVkaXVtb3JjaGlkJywgJ21lZGl1bXB1cnBsZScsXG4gICAgICAgICAgICAnbWVkaXVtc2VhZ3JlZW4nLCAnbWVkaXVtc2xhdGVibHVlJywgJ21lZGl1bXNwcmluZ2dyZWVuJyxcbiAgICAgICAgICAgICdtZWRpdW10dXJxdW9pc2UnLCAnbWVkaXVtdmlvbGV0cmVkJywgJ21pZG5pZ2h0Ymx1ZScsICdtaW50Y3JlYW0nLFxuICAgICAgICAgICAgJ21pc3R5cm9zZScsICdtb2NjYXNpbicsICduYXZham93aGl0ZScsICduYXZ5JywgJ29sZGxhY2UnLCAnb2xpdmUnLFxuICAgICAgICAgICAgJ29saXZlZHJhYicsICdvcmFuZ2UnLCAnb3JhbmdlcmVkJywgJ29yY2hpZCcsICdwYWxlZ29sZGVucm9kJyxcbiAgICAgICAgICAgICdwYWxlZ3JlZW4nLCAncGFsZXR1cnF1b2lzZScsICdwYWxldmlvbGV0cmVkJywgJ3BhcGF5YXdoaXAnLFxuICAgICAgICAgICAgJ3BlYWNocHVmZicsICdwZXJ1JywgJ3BpbmsnLCAncGx1bScsICdwb3dkZXJibHVlJywgJ3B1cnBsZScsICdyZWQnLFxuICAgICAgICAgICAgJ3Jvc3licm93bicsICdyb3lhbGJsdWUnLCAnc2FkZGxlYnJvd24nLCAnc2FsbW9uJywgJ3NhbmR5YnJvd24nLFxuICAgICAgICAgICAgJ3NlYWdyZWVuJywgJ3NlYXNoZWxsJywgJ3NpZW5uYScsICdzaWx2ZXInLCAnc2t5Ymx1ZScsICdzbGF0ZWJsdWUnLFxuICAgICAgICAgICAgJ3NsYXRlZ3JheScsICdzbGF0ZWdyZXknLCAnc25vdycsICdzcHJpbmdncmVlbicsICdzdGVlbGJsdWUnLCAndGFuJyxcbiAgICAgICAgICAgICd0ZWFsJywgJ3RoaXN0bGUnLCAndG9tYXRvJywgJ3R1cnF1b2lzZScsICd2aW9sZXQnLCAnd2hlYXQnLFxuICAgICAgICAgICAgJ3doaXRlJywgJ3doaXRlc21va2UnLCAneWVsbG93JywgJ3llbGxvd2dyZWVuJywgJ3JlYmVjY2FwdXJwbGUnXSxcbiAgICAgICAgLy8gZm9yIHVuaXQgdGVzdHNcbiAgICAgICAgQ3ljbGU6IEN5Y2xlLFxuICAgICAgICBIaXN0b3J5OiBIaXN0b3J5LFxuICAgICAgICBTdGFjazogU3RhY2ssXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBWYWxpZGF0ZSBodG1sIGNvbG9yIChpdCBjYW4gYmUgbmFtZSBvciBoZXgpXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB2YWxpZF9jb2xvcjogZnVuY3Rpb24gdmFsaWRfY29sb3IoY29sb3IpIHtcbiAgICAgICAgICAgIGlmIChjb2xvci5tYXRjaChjb2xvcl9oZXhfcmUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLmluQXJyYXkoY29sb3IudG9Mb3dlckNhc2UoKSwgJC50ZXJtaW5hbC5jb2xvcl9uYW1lcykgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogZnVuY3Rpb24gY2hlY2sgaWYgZ2l2ZW4gc3RyaW5nIGNvbnRhaW4gaW52YWxpZCBzdHJpbmdzXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB1bmNsb3NlZF9zdHJpbmdzOiBmdW5jdGlvbiB1bmNsb3NlZF9zdHJpbmdzKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuICEhc3RyaW5nLm1hdGNoKHVuY2xvc2VkX3N0cmluZ3NfcmUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogRXNjYXBlIGFsbCBzcGVjaWFsIHJlZ2V4IGNoYXJhY3RlcnMsIHNvIGl0IGNhbiBiZSB1c2UgYXMgcmVnZXggdG9cbiAgICAgICAgLy8gOjogbWF0Y2ggZXhhY3Qgc3RyaW5nIHRoYXQgY29udGFpbiB0aG9zZSBjaGFyYWN0ZXJzXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBlc2NhcGVfcmVnZXg6IGZ1bmN0aW9uIGVzY2FwZV9yZWdleChzdHIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBzcGVjaWFsID0gLyhbLVxcXFxeJFtcXF0oKSt7fT8qLnxdKS9nO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZShzcGVjaWFsLCAnXFxcXCQxJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiB0ZXN0IGlmIHN0cmluZyBjb250YWluIGZvcm1hdHRpbmdcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGhhdmVfZm9ybWF0dGluZzogZnVuY3Rpb24gaGF2ZV9mb3JtYXR0aW5nKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmICEhc3RyLm1hdGNoKGZvcm1hdF9leGlzdF9yZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzX2Zvcm1hdHRpbmc6IGZ1bmN0aW9uIGlzX2Zvcm1hdHRpbmcoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgISFzdHIubWF0Y2goZm9ybWF0X2Z1bGxfcmUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogcmV0dXJuIGFycmF5IG9mIGZvcm1hdHRpbmcgYW5kIHRleHQgYmV0d2VlbiB0aGVtXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmb3JtYXRfc3BsaXQ6IGZ1bmN0aW9uIGZvcm1hdF9zcGxpdChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3BsaXQoZm9ybWF0X3NwbGl0X3JlKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiByZXBsYWNlIHRoYXQgcmV0dXJuIHBvc2l0aW9uIGFmdGVyIHJlcGxhY2UgZm9yIHdvcmtpbmcgd2l0aFxuICAgICAgICAvLyA6OiByZXBsYWNlbWVudCB0aGF0IGNoYW5nZSBsZW5ndGggb2YgdGhlIHN0cmluZ1xuICAgICAgICAvLyA6OiBzb3VyY2UgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ2NzU2MDc3LzM4NzE5NFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdHJhY2tpbmdfcmVwbGFjZTogZnVuY3Rpb24gdHJhY2tpbmdfcmVwbGFjZShzdHJpbmcsIHJleCwgcmVwbGFjZW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIShyZXggaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFja2luZ19yZXBsYWNlOiBTZWNvbmQgYXJndW1lbnQgbmVlZCB0byBiZSBSZWdFeHAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN1YnN0cmluZyhzdHJpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbGVuZ3RoKHN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLnRlcm1pbmFsLnN0cmlwKHN0cmluZykubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld19zdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhciByZXBfc3RyaW5nO1xuICAgICAgICAgICAgdmFyIG5ld19wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICAgICAgcmV4Lmxhc3RJbmRleCA9IDA7IC8vIEp1c3QgdG8gYmUgc3VyZVxuICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJleC5leGVjKHN0cmluZykpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgcmVnZXggZG9uJ3QgaGF2ZSBnIGZsYWcgbGFzdEluZGV4IHdpbGwgbm90IHdvcmtcbiAgICAgICAgICAgICAgICBpZiAocmV4Lmdsb2JhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYW55IG9mIHRoZSBvcmlnaW5hbCBzdHJpbmcgd2UganVzdCBza2lwcGVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0X2luZGV4ID0gbGVuZ3RoKHN1YnN0cmluZyhzdHJpbmcsIDAsIHJleC5sYXN0SW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBsYXN0X2luZGV4IC0gbGVuZ3RoKG1hdGNoWzBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBsYXN0X2luZGV4ID0gc3RhcnQgKyBsZW5ndGgobWF0Y2hbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdfc3RyaW5nICs9IHN1YnN0cmluZyhzdHJpbmcsIGluZGV4LCBzdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gbGFzdF9pbmRleDtcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCB0aGUgcmVwbGFjZW1lbnQgc3RyaW5nLiBUaGlzIGp1c3QgaGFuZGxlcyAkJCBhbmQgJG4sXG4gICAgICAgICAgICAgICAgLy8geW91IG1heSB3YW50IHRvIGFkZCBoYW5kbGluZyBmb3IgJGAsICQnLCBhbmQgJCYuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXBfc3RyaW5nID0gcmVwbGFjZW1lbnQuYXBwbHkobnVsbCwgbWF0Y2gpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcF9zdHJpbmcgPSByZXBsYWNlbWVudC5yZXBsYWNlKC9cXCQoXFwkfFxcZCkvZywgZnVuY3Rpb24obSwgYzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjMCA9PT0gXCIkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hbYzBdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIG9uIHRoZSByZXBsYWNlbWVudFxuICAgICAgICAgICAgICAgIG5ld19zdHJpbmcgKz0gcmVwX3N0cmluZztcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcG9zaXRpb24gaXMgYWZmZWN0ZWQuLi5cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCBwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi4gdXBkYXRlIGl0OlxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVwX2xlbiA9IGxlbmd0aChyZXBfc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcmVwX2xlbiArPSBjb3VudF9zZWxmY2xvc2luZ19mb3JtYXR0aW5nKHJlcF9zdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF9pbmRleCA8IHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIGFmdGVyIHRoZSByZXBsYWNlbWVudCwgbW92ZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X3Bvc2l0aW9uID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfcG9zaXRpb24gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcF9sZW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aChtYXRjaFswXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzICppbiogdGhlIHJlcGxhY2VtZW50LCBwdXQgaXQganVzdCBhZnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X3Bvc2l0aW9uICs9IHJlcF9sZW4gLSAocG9zaXRpb24gLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBkb2Vzbid0IGhhdmUgdGhlIGcgZmxhZywgYnJlYWsgaGVyZSBzb1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvIGp1c3Qgb25lIHJlcGxhY2VtZW50IChhbmQgc28gd2UgZG9uJ3QgaGF2ZSBhbiBlbmRsZXNzIGxvb3AhKVxuICAgICAgICAgICAgICAgIGlmICghcmV4Lmdsb2JhbCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgb24gYW55IHRyYWlsaW5nIHRleHQgaW4gdGhlIHN0cmluZ1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICBuZXdfc3RyaW5nICs9IHN1YnN0cmluZyhzdHJpbmcsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgc3RyaW5nIGFuZCB0aGUgdXBkYXRlZCBwb3NpdGlvblxuICAgICAgICAgICAgaWYgKHN0cmluZyA9PT0gbmV3X3N0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbc3RyaW5nLCBwb3NpdGlvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW25ld19zdHJpbmcsIG5ld19wb3NpdGlvbl07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBoZWxwZXIgZnVuY3Rpb24gdXNlZCBieSBzdWJzdHJpbmcgYW5kIHNwbGl0X2VxdWFsIGl0IGxvb3Agb3ZlclxuICAgICAgICAvLyA6OiBzdHJpbmcgYW5kIGV4ZWN1dGUgY2FsbGJhY2sgd2l0aCB0ZXh0IGNvdW50IGFuZCBvdGhlciBkYXRhXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBpdGVyYXRlX2Zvcm1hdHRpbmc6IGZ1bmN0aW9uIGl0ZXJhdGVfZm9ybWF0dGluZyhzdHJpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBpc19zcGFjZShpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShpIC0gNiwgaSkgPT09ICcmbmJzcDsnIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5zbGljZShpIC0gMSwgaSkubWF0Y2goL1xccy8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2hfZW50aXR5KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShpbmRleCkubWF0Y2goZW50aXR5X3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzX29wZW5fZm9ybWF0dGluZyhpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1tpXSA9PT0gJ1snICYmIHN0cmluZ1tpICsgMV0gPT09ICdbJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzX2VzY2FwZV9icmFja2V0KGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nW2kgLSAxXSAhPT0gJ1xcXFwnICYmIHN0cmluZ1tpXSA9PT0gJ1xcXFwnICYmXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1tpICsgMV0gPT09ICddJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzX3RleHQoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RfZm9ybWF0dGluZyAmJiAoc3RyaW5nW2ldICE9PSAnXScgfHwgIWhhdmVfZm9ybWF0dGluZylcbiAgICAgICAgICAgICAgICAgICAgJiYgIW9wZW5pbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBmdW5jdGlvbiB3aWxsIHNraXAgdG8gbmV4dCBjaGFyYWN0ZXIgaW4gbWFpbiBsb29wXG4gICAgICAgICAgICAvLyA6OiBUT0RPOiBpbXByb3ZlIHBlcmZvcm1hbmNlIG9mIGVtb2ppIHJlZ2V4IGFuZCBjaGVjayB3aG9sZVxuICAgICAgICAgICAgLy8gOjogc3RyaW5nIGl0J3MgY29tcGxleCBzdHJpbmcgaWYgbm90IHVzZSBzaW1wbGUgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHZhciBnZXRfbmV4dF9jaGFyYWN0ZXIgPSBtYWtlX25leHRfY2hhcl9mdW4oc3RyaW5nKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIG5leHRfaXRlcmF0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGFyID0gZ2V0X25leHRfY2hhcmFjdGVyKHN1YnN0cmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXIubGVuZ3RoID4gMSAmJiAkLnRlcm1pbmFsLmxlbmd0aChzdWJzdHJpbmcpID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhci5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzX25leHRfc3BhY2UoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc19zcGFjZShpKSAmJiAobm90X2Zvcm1hdHRpbmcgfHwgb3BlbmluZykpICYmXG4gICAgICAgICAgICAgICAgICAgIChzcGFjZSA9PT0gLTEgJiYgcHJldl9zcGFjZSAhPT0gaSB8fCBzcGFjZSAhPT0gLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogbGFzdCBpdGVyYXRpb24gb3Igb25lIGJlZm9yZSBjbG9zaW5nIGZvcm1hdHRpbmdcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHZhciBsYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICBmdW5jdGlvbiBpc19sYXN0KCkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBzdHJpbmcubGVuZ3RoIC0gMSAmJiAhbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gISFzdWJzdHJpbmcubWF0Y2goL14uXSQvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICB2YXIgaGF2ZV9mb3JtYXR0aW5nID0gJC50ZXJtaW5hbC5oYXZlX2Zvcm1hdHRpbmcoc3RyaW5nKTtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0aW5nID0gJyc7XG4gICAgICAgICAgICB2YXIgaW5fdGV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgICAgIHZhciBzcGFjZSA9IC0xO1xuICAgICAgICAgICAgdmFyIHNwYWNlX2NvdW50ID0gLTE7XG4gICAgICAgICAgICB2YXIgcHJldl9zcGFjZTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgcmVfZW50ID0gLygmW147XSspOyQvO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3RyaW5nID0gc3RyaW5nLnNsaWNlKGkpO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gc3Vic3RyaW5nLm1hdGNoKGZvcm1hdF9zdGFydF9yZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmcgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgaW5fdGV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0dGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nW2ldID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbl90ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluX3RleHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5fdGV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbl90ZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5vdF9mb3JtYXR0aW5nID0gKGZvcm1hdHRpbmcgJiYgaW5fdGV4dCkgfHwgIWZvcm1hdHRpbmc7XG4gICAgICAgICAgICAgICAgdmFyIG9wZW5pbmcgPSBpc19vcGVuX2Zvcm1hdHRpbmcoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzX25leHRfc3BhY2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBzcGFjZSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlX2NvdW50ID0gY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBicmFrZXQgPSBzdHJpbmdbaV0ubWF0Y2goL1tbXFxdXS8pO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKG5vdF9mb3JtYXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyZWF0IGVudGl0eSBhcyBvbmUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmdbaV0gPT09ICcmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaF9lbnRpdHkoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IG1hdGNoWzFdLmxlbmd0aCAtIDI7IC8vIDIgYmVjYXVzZSBjb250aW51ZSBhZGRzIDEgdG8gaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKytjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzX2VzY2FwZV9icmFja2V0KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgXFxdIGFuZCBcXFxcIGNvdW50cyBhcyBvbmUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICArK2NvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgKytsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFicmFrZXQgfHwgIWhhdmVfZm9ybWF0dGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc190ZXh0KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJsZW4oc3RyaW5nW2ldKSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXIgPSBnZXRfbmV4dF9jaGFyYWN0ZXIoc3Vic3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSBjaGFyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVnaW5pbmcgb2YgZW5pdHkgdGhhdCB3ZSd2ZSBza2lwcGVkLCB3ZSBhcmUgYXQgdGhlIGVuZFxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJzsnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHN0cmluZy5zbGljZSgwLCBpICsgMSkubWF0Y2gocmVfZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3Q6IGlzX2xhc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpIC0gb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGluZzogZm9ybWF0dGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogaW5fdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZTogc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZV9jb3VudDogc3BhY2VfY291bnRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0LmNvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IHJldC5jb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSByZXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldC5zcGFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldl9zcGFjZSA9IHNwYWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlID0gcmV0LnNwYWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldC5pbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHJldC5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gc3RyaW5nLmxlbmd0aCAtIDEgJiYgIWxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFzdCBpdGVyYXRpb24sIGlmIGZvcm1hdHRpbmcgaGF2ZSBsYXN0IGJyYWNrZXQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGZyb20gZm9ybWF0dGluZywgdGhlbiBsYXN0IGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyB3YXMgYWxyZWFkeSBjYWxsZWQgKGluIGlmKSAjNTUwXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRpbmc6IGZvcm1hdHRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBpbl90ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2U6IHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZW1vamksIHN1cm9nZ2F0ZSBwYWlycyBhbmQgY29tYmluZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgaWYgKGluX3RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaSArPSBuZXh0X2l0ZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IGZ1bmN0aW9uIHJldHVybiBzdHJpbmcgc3BsaXR0ZWQgaW50byBzaW5nbGUgY2hhcmFjdGVyc1xuICAgICAgICAvLyA6OiBlYWNoIGNoYXJhY3RlciBpcyB3cmFwcGVkIGludG8gZm9ybWF0dGluZyBmcm9tIGlucHV0IHN0cmluZ1xuICAgICAgICAvLyA6OiBvciBlbXB0eSBmb3JtYXR0aW5nIHNvIGl0IHdpbGwgY3JlYXRlIHNwYW4gd2hlbiB1c2luZyB3aXRoIDo6Zm9ybWF0XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBwYXJ0aXRpb246IGZ1bmN0aW9uIHBhcnRpdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICghJC50ZXJtaW5hbC5oYXZlX2Zvcm1hdHRpbmcoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGFycyA9ICQudGVybWluYWwuc3BsaXRfY2hhcmFjdGVycyhzdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFycy5tYXAod3JhcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmdW5jdGlvbiB3cmFwKHN0cmluZykge1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcubWF0Y2goL1xcXFwkLykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbWzs7XScgKyBzdHJpbmcgKyAnXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXR0aW5nKHN0cmluZykge1xuICAgICAgICAgICAgICAgIGlmICgkLnRlcm1pbmFsLmlzX2Zvcm1hdHRpbmcoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nLm1hdGNoKC9cXFxcXSQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1xcXFxdL2csICdcXFxcXFxcXF0nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IHdyYXAoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQudGVybWluYWwuaXRlcmF0ZV9mb3JtYXR0aW5nKHN0cmluZywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZm9ybWF0dGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKGRhdGEuZm9ybWF0dGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKHN0cmluZy5zdWJzdHJpbmcoZGF0YS5pbmRleCwgZGF0YS5pbmRleCArIGRhdGEuc2l6ZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5mb3JtYXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LnB1c2goJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmb3JtYXR0aW5nKHRleHQuam9pbignJykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBmb3JtYXR0aW5nIGF3YXJlIHN1YnN0cmluZyBmdW5jdGlvblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgc3Vic3RyaW5nOiBmdW5jdGlvbiBzdWJzdHJpbmcoc3RyaW5nLCBzdGFydF9pbmRleCwgZW5kX2luZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2hhcnMgPSAkLnRlcm1pbmFsLnNwbGl0X2NoYXJhY3RlcnMoc3RyaW5nKTtcbiAgICAgICAgICAgIGlmICghY2hhcnMuc2xpY2Uoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEkLnRlcm1pbmFsLmhhdmVfZm9ybWF0dGluZyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJzLnNsaWNlKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpLmpvaW4oJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHZhciBlbmQ7XG4gICAgICAgICAgICB2YXIgc3RhcnRfZm9ybWF0dGluZyA9ICcnO1xuICAgICAgICAgICAgdmFyIGVuZF9mb3JtYXR0aW5nID0gJyc7XG4gICAgICAgICAgICB2YXIgcHJldl9pbmRleDtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgJC50ZXJtaW5hbC5pdGVyYXRlX2Zvcm1hdHRpbmcoc3RyaW5nLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0X2luZGV4ICYmIGRhdGEuY291bnQgPT09IHN0YXJ0X2luZGV4ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGEuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmZvcm1hdHRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X2Zvcm1hdHRpbmcgPSBkYXRhLmZvcm1hdHRpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVuZF9pbmRleCAmJiBkYXRhLmNvdW50ID09PSBlbmRfaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kX2Zvcm1hdHRpbmcgPSBkYXRhLmZvcm1hdHRpbmc7XG4gICAgICAgICAgICAgICAgICAgIHByZXZfaW5kZXggPSBkYXRhLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBkYXRhLnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmNvdW50ID09PSBlbmRfaW5kZXggKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGRhdGEuaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmZvcm1hdHRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHByZXZfaW5kZXggKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzdGFydF9pbmRleCAmJiAhc3RhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nID0gc3RhcnRfZm9ybWF0dGluZyArIHN0cmluZy5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIGlmIChlbmRfZm9ybWF0dGluZykge1xuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC8oXFxbXFxbXlxcXV0rKT9cXF0kLywgJycpO1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSAnXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICB9LFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogYWRkIGZvcm1hdCB0ZXh0IGFzIDV0aCBwYXJhbXRlciB0byBmb3JtYXR0aW5nIGl0J3MgdXNlZCBmb3JcbiAgICAgICAgLy8gOjogZGF0YSBhdHRyaWJ1dGUgaW4gZm9ybWF0IGZ1bmN0aW9uIC0gYW5kIGZpeCB1bmNsb3NlZCAmXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZShzdHJpbmcpIHtcbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGZvcm1hdF9yZSwgZnVuY3Rpb24oXywgZm9ybWF0LCB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdC5tYXRjaChzZWxmX2Nsb3NpbmdfcmUpICYmIHRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW1snICsgZm9ybWF0ICsgJ10gXSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNhZmUoc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxcXFxcXS9nLCAnJiM5MzsnKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mbmJzcDsvZywgJyAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gc2FmZShmb3JtYXQpO1xuICAgICAgICAgICAgICAgIHZhciBzZW1pY29sb25zID0gZm9ybWF0Lm1hdGNoKC87L2cpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBtaXNzaW5nIHNlbWljb2xvbnNcbiAgICAgICAgICAgICAgICBpZiAoc2VtaWNvbG9ucyA+PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gZm9ybWF0LnNwbGl0KC87Lyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGFyZ3Muc2xpY2UoMCwgNCkuam9pbignOycpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gYXJncy5zbGljZSg0KS5qb2luKCc7Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW1snICsgc3RhcnQgKyAnOycgKyAoYXJnIHx8IHRleHQpICsgJ10nICsgdGV4dCArICddJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbWljb2xvbnMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VtaWNvbG9ucyA9ICc7Oyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZW1pY29sb25zID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbWljb2xvbnMgPSAnOyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJldHVybiAnW1snICsgZm9ybWF0ICsgJ10nICsgdGV4dCArICddJztcbiAgICAgICAgICAgICAgICAvLyBjbG9zaW5nIGJyYWtldCB3aWxsIGJyZWFrIGZvcm1hdHRpbmcgc28gd2UgbmVlZCB0byBlc2NhcGVcbiAgICAgICAgICAgICAgICAvLyB0aG9zZSB1c2luZyBodG1sIGVudGl0eSBlcXV2YWxlbnRcbiAgICAgICAgICAgICAgICAvLyBzcGFjZSBpcyBoYWNrIGZvciBpbWFnZXMgdGhhdCBicmVhayBpdGVyYXRlX2Zvcm1hdHRpbmdcbiAgICAgICAgICAgICAgICBmb3JtYXQgKz0gc2VtaWNvbG9ucyArIHNhZmUodGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbWycgKyBmb3JtYXQgKyAnXScgKyB0ZXh0ICsgJ10nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gJC50ZXJtaW5hbC5hbXAoc3RyaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IHNwbGl0IHRleHQgaW50byBsaW5lcyB3aXRoIGVxdWFsIGxlbmd0aCBzbyBlYWNoIGxpbmUgY2FuIGJlXG4gICAgICAgIC8vIDo6IHJlbmRlcmVkIHNlcGFyYXRlbHkgKHRleHQgZm9ybWF0dGluZyBjYW4gYmUgbG9uZ2VyIHRoZW4gYSBsaW5lKS5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHNwbGl0X2VxdWFsOiBmdW5jdGlvbiBzcGxpdF9lcXVhbChzdHIsIGxlbmd0aCwga2VlcF93b3Jkcykge1xuICAgICAgICAgICAgdmFyIHByZXZfZm9ybWF0ID0gJyc7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSAkLnRlcm1pbmFsLm5vcm1hbGl6ZShzdHIpLnNwbGl0KC9cXG4vZyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgdmFyIGdldF9uZXh0X2NoYXJhY3RlciA9IG1ha2VfbmV4dF9jaGFyX2Z1bihsaW5lKTtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RfaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVfbGVuZ3RoID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RfYnJhY2tldCA9ICEhbGluZS5tYXRjaCgvXFxbXFxbW15cXF1dK1xcXSg/OlteXFxdW118XFxcXFxcXSkrXFxdJC8pO1xuICAgICAgICAgICAgICAgICQudGVybWluYWwuaXRlcmF0ZV9mb3JtYXR0aW5nKGxpbmUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNociwgc3Vic3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPj0gbGVuZ3RoIHx8IGRhdGEubGFzdCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGEubGVuZ3RoID09PSBsZW5ndGggLSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgc3RybGVuKGxpbmVbZGF0YS5pbmRleCArIDFdKSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5fYnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgbmVlZCB3b3JrXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2VlcF93b3JkcyAmJiBkYXRhLnNwYWNlICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgaHRtbCBlbnRpdGllcyB3aXRoIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyaXBwZWQgPSB0ZXh0KGxpbmUpLnN1YnN0cmluZyhkYXRhLnNwYWNlX2NvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWFsIGxlbmd0aCwgbm90IGNvdW50aW5nIGZvcm1hdHRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpcHBlZCA9IHN0cmlwcGVkLnNsaWNlKDAsIGxlbmd0aCkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0X2xlbiA9IHN0cmxlbihzdHJpcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmlwcGVkLm1hdGNoKC9cXHMvKSB8fCB0ZXh0X2xlbiA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5fYnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdvcmRzIGlzIHRydWUgd2Ugc3BsaXQgYXQgbGFzdCBzcGFjZSBhbmQgbWFrZSBuZXh0IGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIHdoZXJlIHRoZSBzcGFjZSB3aGVyZSBsb2NhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWZ0ZXJfaW5kZXggPSBkYXRhLmluZGV4ICsgZGF0YS5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RfYnJhY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyX2luZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X2luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtlZXBfd29yZHMgJiYgZGF0YS5zcGFjZSAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlcl9pbmRleCAhPT0gbGluZV9sZW5ndGggJiYgY2FuX2JyZWFrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gbGluZS5zbGljZShmaXJzdF9pbmRleCwgZGF0YS5zcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2luZGV4ID0gZGF0YS5zcGFjZSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnN0cmluZyA9IGxpbmUuc2xpY2UoZGF0YS5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hyID0gZ2V0X25leHRfY2hhcmFjdGVyKHN1YnN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gbGluZS5zbGljZShmaXJzdF9pbmRleCwgZGF0YS5pbmRleCkgKyBjaHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubGFzdCAmJiBsYXN0X2JyYWNrZXQgJiYgY2hyICE9PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9ICddJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2luZGV4ID0gZGF0YS5pbmRleCArIGNoci5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtlZXBfd29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvXigmbmJzcDt8XFxzKSt8KCZuYnNwO3xcXHMpKyQvZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RfaW5kZXggPSAobmV3X2luZGV4IHx8IGRhdGEuaW5kZXgpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2X2Zvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZWRfZm9ybWF0dGluZyA9IG91dHB1dC5tYXRjaCgvXlteXFxdXSpcXF0vKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBwcmV2X2Zvcm1hdCArIG91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VkX2Zvcm1hdHRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldl9mb3JtYXQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IG91dHB1dC5tYXRjaChmb3JtYXRfcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFtsYXN0Lmxlbmd0aCAtIDFdICE9PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldl9mb3JtYXQgPSBsYXN0Lm1hdGNoKGZvcm1hdF9iZWdpbl9yZSlbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSAnXSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvdXRwdXQubWF0Y2goZm9ybWF0X2VuZF9yZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoZm9ybWF0X2VuZF9yZSwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2X2Zvcm1hdCA9IGxhc3QubWF0Y2goZm9ybWF0X2JlZ2luX3JlKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW9kaWZ5IGxvb3AgYnkgcmV0dXJpbmcgbmV3IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IG5ld19pbmRleCwgbGVuZ3RoOiAwLCBzcGFjZTogLTF9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogRXNjYXBlICYgdGhhdCdzIG5vdCBwYXJ0IG9mIGVudGl0eVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgYW1wOiBmdW5jdGlvbiBhbXAoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYoPyEjWzAtOV0rO3wjeFswLTlhLWZdKzt8W2Etel0rOykvZ2ksICcmYW1wOycpO1xuICAgICAgICB9LFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogRW5jb2RlIGZvcm1hdGluZyBhcyBodG1sIGZvciBpbnNlcnRpb24gaW50byBET01cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlKHN0ciwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIHRhYnM6IDQsXG4gICAgICAgICAgICAgICAgYmVmb3JlOiAnJ1xuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gJC50ZXJtaW5hbC5hbXAoc3RyKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyAvZywgJyZuYnNwOycpLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXR0ZWQgPSBsaW5lLnNwbGl0KC8oKD86XFxbXFxbW15cXF1dK1xcXSk/XFx0KD86XFxdKT8pLyk7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0dGVkID0gc3BsaXR0ZWQuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BsaXR0ZWQubWFwKGZ1bmN0aW9uKHN0ciwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci5tYXRjaCgvXFx0LykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcdChbXlxcdF0qKSQvLCBmdW5jdGlvbihfLCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IDAgJiYgc3BsaXR0ZWRbaSAtIDFdLm1hdGNoKC9cXHRcXF0/JC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3AgPSBuZXcgQXJyYXkoc2V0dGluZ3MudGFicyArIDEpLmpvaW4oJyZuYnNwOycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwICsgZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHNwbGl0dGVkLnNsaWNlKGkgLSAxLCBpKS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5iZWZvcmUgJiYgaSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlID0gc2V0dGluZ3MuYmVmb3JlICsgYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9ICQudGVybWluYWwubGVuZ3RoKGJlZm9yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcnMgPSBzZXR0aW5ncy50YWJzIC0gKGxlbiAlIHNldHRpbmdzLnRhYnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnMgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheShjaGFycyArIDEpLmpvaW4oJyZuYnNwOycpICsgZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogRGVmYXVsdCBmb3JtYXR0ZXIgdGhhdCBhbGxvdyBmb3IgbmVzdGVkIGZvcm1hdHRpbmcsIGV4YW1wbGU6XG4gICAgICAgIC8vIDo6IFtbOzsjMDAwXWhlbGxvIFtbOyNmMDA7XXJlZF0gd29ybGRdXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIG5lc3RlZF9mb3JtYXR0aW5nOiBmdW5jdGlvbiBuZXN0ZWRfZm9ybWF0dGluZyhzdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICghJC50ZXJtaW5hbC5oYXZlX2Zvcm1hdHRpbmcoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgICAgICAgIHZhciByZSA9IC8oKD86XFxbXFxbKD86W15cXF1bXXxcXFxcXFxdKStcXF0pPyg/OlteXFxdW118XFxcXFxcXSkqXFxdPykvO1xuICAgICAgICAgICAgdmFyIGZvcm1hdF9yZSA9IC9cXFtcXFsoW15cXF1bXSspXFxdW1xcc1xcU10qLztcbiAgICAgICAgICAgIHZhciBmb3JtYXRfc3BsaXRfcmUgPSAvXlxcW1xcWyhbXjtdKik7KFteO10qKTsoW15cXF1dKilcXF0vO1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0X2luaGVyaXRfc3R5bGUoc3RhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gW1tdLCAnJywgJyddO1xuICAgICAgICAgICAgICAgIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRpbmcgPSBzdGFja1tpXS5zcGxpdCgnOycpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBmb3JtYXR0aW5nWzBdLnNwbGl0KC8oLT9bQCFnYml1c29dKS9nKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dFswXS5pbmRleE9mKHMpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFswXS5wdXNoKHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBvdXRwdXQubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGZvcm1hdHRpbmdbal0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmICFvdXRwdXRbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbal0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaWdub3JlID0gb3V0cHV0WzBdLmZpbHRlcihmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzWzBdID09PSAnLSc7XG4gICAgICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNbMV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0WzBdID0gb3V0cHV0WzBdLmZpbHRlcihmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZ25vcmUuaW5kZXhPZihzKSA9PT0gLTEgJiYgaWdub3JlLmluZGV4T2Yoc1sxXSkgPT09IC0xO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQuam9pbignOycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdChyZSkuZmlsdGVyKEJvb2xlYW4pLm1hcChmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGU7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZy5tYXRjaCgvXlxcW1xcWy8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0aW5nID0gc3RyaW5nLnJlcGxhY2UoZm9ybWF0X3JlLCAnJDEnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzX2Zvcm1hdHRpbmcgPSAkLnRlcm1pbmFsLmlzX2Zvcm1hdHRpbmcoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoZm9ybWF0X3NwbGl0X3JlLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goZm9ybWF0dGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkLnRlcm1pbmFsLm5lc3RlZF9mb3JtYXR0aW5nLl9faW5oZXJpdF9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IGdldF9pbmhlcml0X3N0eWxlKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0gZm9ybWF0dGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzX2Zvcm1hdHRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSAnXSc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSAnW1snICsgc3R5bGUgKyAnXScgKyBzdHJpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nLm1hdGNoKC9cXF0vKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC50ZXJtaW5hbC5uZXN0ZWRfZm9ybWF0dGluZy5fX2luaGVyaXRfXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlID0gZ2V0X2luaGVyaXRfc3R5bGUoc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gJ1tbJyArIHN0eWxlICsgJ10nICsgc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9ICddJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBzYWZlIGZ1bmN0aW9uIHRoYXQgd2lsbCByZW5kZXIgdGV4dCBhcyBpdCBpc1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZXNjYXBlX2Zvcm1hdHRpbmc6IGZ1bmN0aW9uIGVzY2FwZV9mb3JtYXR0aW5nKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuICQudGVybWluYWwuZXNjYXBlX2JyYWNrZXRzKHN0cmluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBhcHBseSBjdXN0b20gZm9ybWF0dGVycyBvbmx5IHRvIHRleHRcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGFwcGx5X2Zvcm1hdHRlcnM6IGZ1bmN0aW9uIGFwcGx5X2Zvcm1hdHRlcnMoc3RyaW5nLCBzZXR0aW5ncykge1xuICAgICAgICAgICAgaWYgKHN0cmluZyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncyAmJiB0eXBlb2Ygc2V0dGluZ3MucG9zaXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJcIiwgc2V0dGluZ3MucG9zaXRpb25dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRlc3RfbGVuZ3Rocyhmb3JtYXR0ZXIsIGluZGV4LCByZXQsIHN0cmluZykge1xuICAgICAgICAgICAgICAgIGlmICghZm9ybWF0dGVyLl9fbm9fd2Fybl9fICYmXG4gICAgICAgICAgICAgICAgICAgICQudGVybWluYWwubGVuZ3RoKHJldCkgIT09ICQudGVybWluYWwubGVuZ3RoKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybignWW91ciBmb3JtYXR0ZXJbJyArIGluZGV4ICsgJ10gY2hhbmdlIGxlbmd0aCBvZiB0aGUgc3RyaW5nLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAneW91IHNob3VsZCB1c2UgW3JlZ2V4LCByZXBsYWNlbWVudF0gZm9ybWF0dGVyIG9yIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICcgdGhhdCByZXR1cm4gW3JlcGxhY2VtZW50LCBwb3NpdGlvbl0gaW5zdGVhZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZXJzID0gJC50ZXJtaW5hbC5kZWZhdWx0cy5mb3JtYXR0ZXJzO1xuICAgICAgICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFwcGx5X2Z1bmN0aW9uX2Zvcm1hdHRlcihmb3JtYXR0ZXIsIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgc2V0dGluZ3MsIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGlucHV0WzFdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IGZvcm1hdHRlcihpbnB1dFswXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RfbGVuZ3Rocyhmb3JtYXR0ZXIsIGkgLSAxLCByZXQsIGlucHV0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3JldCwgb3B0aW9ucy5wb3NpdGlvbl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNfYXJyYXkocmV0KSAmJiByZXQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbnB1dDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MucG9zaXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBbc3RyaW5nLCBzZXR0aW5ncy5wb3NpdGlvbl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gW3N0cmluZywgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBmb3JtYXR0ZXJzLnJlZHVjZShmdW5jdGlvbihpbnB1dCwgZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgLy8gX19tZXRhX18gaXMgZm9yIHNhZmUgZm9ybWF0dGVyIHRoYXQgY2FuIGhhbmRsZSBmb3JtYXR0ZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIGluc2lkZSBmb3JtYXR0ZXJzLiBmb3Igb3RoZXIgdXNhZ2Ugd2UgdXNlIGZvcm1hdF9zcGxpdCBzbyBvbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9ybWF0dGVyIGRvbid0IG1lc3Mgd2l0aCBmb3JtYXR0ZXIgdGhhdCB3YXMgcHJldmlvdXNcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicgJiYgZm9ybWF0dGVyLl9fbWV0YV9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlfZnVuY3Rpb25fZm9ybWF0dGVyKGZvcm1hdHRlciwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmRfcG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGxpdHRlZCA9ICQudGVybWluYWwuZm9ybWF0X3NwbGl0KGlucHV0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFscyA9IHNwbGl0dGVkLm1hcChmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNfbGVuID0gdGV4dChzdHJpbmcpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBwb3NpdGlvbiB0aGF0IG1hdGNoIGlzIHVzZWQgZm9yIHRoaXMgcGFydGlhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFsxXSA8PSBsZW5ndGggKyB0aGlzX2xlbiAmJiAhZm91bmRfcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBpbnB1dFsxXSAtIGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRfcG9zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIGluZGljYXRlIHRoYXQgd2Ugd2lsbCBub3QgdHJhY2sgcG9zaXRpb24gYmVjYXVzZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXMgaW4gb25lIG9mIHRoZSBwcmV2aW91cyBwYXJpYWwgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZW5ndGggaXMgdXNlZCB0byBjb3JyZWN0IHBvc2l0aW9uIGFmdGVyIHJlcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoX2JlZm9yZSA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0aGlzX2xlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC50ZXJtaW5hbC5pc19mb3JtYXR0aW5nKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzdHJpbmcsIC0xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfYXJyYXkoZm9ybWF0dGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBmb3JtYXR0ZXJbMl0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbc3RyaW5nLCBwb3NpdGlvbiA8IDAgPyAwIDogcG9zaXRpb25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFswXS5tYXRjaChmb3JtYXR0ZXJbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9vcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVzdWx0WzBdLm1hdGNoKGZvcm1hdHRlclswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICQudGVybWluYWwudHJhY2tpbmdfcmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlclsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAkLnRlcm1pbmFsLnRyYWNraW5nX3JlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXJbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXJbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtyZXN1bHRbMF0sIC0xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhcHBseV9mdW5jdGlvbl9mb3JtYXR0ZXIoZm9ybWF0dGVyLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nLCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IHBvc2l0aW9uIGJlY3Vhc2UgaXQncyByZWxhdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gcGFydGlhbCBhbmQgd2UgbmVlZCBnbG9iYWwgZm9yIHdob2xlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFsxXSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbMV0gKz0gbGVuZ3RoX2JlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzdHJpbmcsIC0xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbl9wYXJ0aWFsID0gcGFydGlhbHMuZmlsdGVyKGZ1bmN0aW9uKHBhcnRpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydGlhbFsxXSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSBwYXJ0aWFscy5tYXAoZnVuY3Rpb24ocGFydGlhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvc2l0aW9uX3BhcnRpYWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBpbnB1dFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbl9wYXJ0aWFsWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIHRoYXQgb3V0cHV0IHBvc2l0aW9uIGlzIG5vdCBvdXRzaWRlIHRoZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSB0ZXh0KHN0cmluZykubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ICs9IGNvdW50X3NlbGZjbG9zaW5nX2Zvcm1hdHRpbmcoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gbWF4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZyA9PT0gaW5wdXRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3N0cmluZywgcG9zaXRpb25dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MucG9zaXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2RlcG9pbnRfbGVuID0gJC50ZXJtaW5hbC5zdHJpcChyZXN1bHRbMF0pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQudGVybWluYWwubGVuZ3RoKHJlc3VsdFswXSkgPCBjb2RlcG9pbnRfbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSByZXN1bHRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZV9wb3NpdGlvbihyZXN1bHRbMF0sIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSAkLnRlcm1pbmFsLmxlbmd0aChyZXN1bHRbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBtYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbMV0gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnRXJyb3IgaW4gZm9ybWF0dGVyIFsnICsgKGkgLSAxKSArICddJztcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXJzLnNwbGljZShpIC0gMSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3ICQudGVybWluYWwuRXhjZXB0aW9uKCdmb3JtYXR0aW5nJywgbXNnLCBlLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IFJlcGxhY2UgdGVybWluYWwgZm9ybWF0dGluZyB3aXRoIGh0bWxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24gZm9ybWF0KHN0ciwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQoe30sIHtcbiAgICAgICAgICAgICAgICBsaW5rc05vUmVmZXJyZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxpbmtzTm9Gb2xsb3c6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBbXSxcbiAgICAgICAgICAgICAgICBjaGFyX3dpZHRoOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZXNjYXBlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGFueUxpbmtzOiBmYWxzZVxuICAgICAgICAgICAgfSwgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgZnVuY3Rpb24gZmlsdGVyX2F0dHJfbmFtZXMobmFtZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXMubGVuZ3RoICYmIHNldHRpbmdzLmFsbG93ZWRBdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZXMuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnZGF0YS10ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbGxvd2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVycyA9IHNldHRpbmdzLmFsbG93ZWRBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcnNbaV0gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcnNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsdGVyc1tpXSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbG93ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYW5fZGF0YShkYXRhLCB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnJlcGxhY2UoLyYjOTM7L2csICddJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRfYXR0cnMoYXR0cnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBmaWx0ZXJfYXR0cl9uYW1lcyhPYmplY3Qua2V5cyhhdHRycykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnICcgKyBrZXlzLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbbmFtZV0ucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lICsgJz1cIicgKyB2YWx1ZSArICdcIic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbF9hdHRyKCkge1xuICAgICAgICAgICAgICAgIHZhciByZWwgPSBbXCJub29wZW5lclwiXTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubGlua3NOb1JlZmVycmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbC51bnNoaWZ0KFwibm9yZWZlcnJlclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmxpbmtzTm9Gb2xsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsLnVuc2hpZnQoXCJub2ZvbGxvd1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyB0ZXN0IGlmIHRoaXMgaXMgdmFsaWQgUGF0aFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzX3BhdGgodXJsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybC5tYXRjaCgvXlxcLnsxLDJ9XFwvLykgfHxcbiAgICAgICAgICAgICAgICAgICAgdXJsLm1hdGNoKC9eXFwvLykgfHxcbiAgICAgICAgICAgICAgICAgICAgISh1cmwubWF0Y2goL1xcLy8pIHx8IHVybC5tYXRjaCgvXlteOl0rOi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBmdW5jdGlvbiB3aXRoX3VybF92YWxpZGF0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYW55TGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0ID0gZm4odXJsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIFVSTCAnICsgdXJsICsgJyBvbmx5IGh0dHBzIGZ0cCBhbmQgUGF0aCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FyZSBhbGxvd2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlc3Q7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICB2YXIgdmFsaWRfaHJlZiA9IHdpdGhfdXJsX3ZhbGlkYXRpb24oZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybC5tYXRjaCgvXigoaHR0cHM/fGZ0cCk6XFwvXFwvfFxcLnswLDJ9XFwvKS8pIHx8IGlzX3BhdGgodXJsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHZhciB2YWxpZF9zcmMgPSB3aXRoX3VybF92YWxpZGF0aW9uKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmwubWF0Y2goL14oaHR0cHM/OnxibG9iOnxkYXRhOikvKSB8fCBpc19wYXRoKHVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXQocywgc3R5bGUsIGNvbG9yLCBiYWNrZ3JvdW5kLCBfY2xhc3MsIGRhdGFfdGV4dCwgdGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRycztcbiAgICAgICAgICAgICAgICBpZiAoZGF0YV90ZXh0Lm1hdGNoKC87LykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGxpdHRlZCA9IGRhdGFfdGV4dC5zcGxpdCgnOycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9IHNwbGl0dGVkLnNsaWNlKDEpLmpvaW4oJzsnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mbmJzcDsvZywgJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mbHQ7L2csICc8JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJmd0Oy9nLCAnPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci5tYXRjaCgvXlxccypcXHtbXn1dKlxcfVxccyokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRycyA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhX3RleHQgPSBzcGxpdHRlZFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZXh0ID09PSAnJyAmJiAhc3R5bGUubWF0Y2goL0AvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7IC8vJzxzcGFuPiZuYnNwOzwvc3Bhbj4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXh0ID0gc2FmZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXFxcXFxdL2csICcmIzkzOycpO1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lc2NhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zaWRlIGZvcm1hdHRpbmcgd2UgbmVlZCB0byB1bmVzY2FwZSBlc2NhcGVkIHNsYXNoZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgZXNjYXBlIGlzIG5vdCBuZWVkZWQgd2hlbiBlY2hvIC0gZG9uJ3Qga25vdyB3aHlcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlX3N0ciA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5pbmRleE9mKCdiJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlX3N0ciArPSAnZm9udC13ZWlnaHQ6Ym9sZDsnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdGV4dF9kZWNvcmF0aW9uID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmluZGV4T2YoJ3UnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dF9kZWNvcmF0aW9uLnB1c2goJ3VuZGVybGluZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaW5kZXhPZigncycpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0X2RlY29yYXRpb24ucHVzaCgnbGluZS10aHJvdWdoJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5pbmRleE9mKCdvJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRfZGVjb3JhdGlvbi5wdXNoKCdvdmVybGluZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dF9kZWNvcmF0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZV9zdHIgKz0gJ3RleHQtZGVjb3JhdGlvbjonICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfZGVjb3JhdGlvbi5qb2luKCcgJykgKyAnOyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5pbmRleE9mKCdpJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlX3N0ciArPSAnZm9udC1zdHlsZTppdGFsaWM7JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCQudGVybWluYWwudmFsaWRfY29sb3IoY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlX3N0ciArPSAnY29sb3I6JyArIGNvbG9yICsgJzsnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICctLWNvbG9yOicgKyBjb2xvciArICc7JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlLmluZGV4T2YoJyEnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlX3N0ciArPSAnLS1saW5rLWNvbG9yOicgKyBjb2xvciArICc7JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaW5kZXhPZignZycpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVfc3RyICs9ICd0ZXh0LXNoYWRvdzowIDAgNXB4ICcgKyBjb2xvciArICc7JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJC50ZXJtaW5hbC52YWxpZF9jb2xvcihiYWNrZ3JvdW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZV9zdHIgKz0gJ2JhY2tncm91bmQtY29sb3I6JyArIGJhY2tncm91bmQgKyAnOyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gY2xlYW5fZGF0YShkYXRhX3RleHQsIHRleHQpO1xuICAgICAgICAgICAgICAgIHZhciBleHRyYSA9IGV4dHJhX2Nzcyh0ZXh0LCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB3aWRlX2NoYXJhY3RlcnModGV4dCwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZV9zdHIgKz0gZXh0cmE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmluZGV4T2YoJyEnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubWF0Y2goZW1haWxfcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAnPGEgaHJlZj1cIm1haWx0bzonICsgZGF0YSArICdcIic7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGh0dHAgYW5kIGZ0cCBsaW5rcyAocHJldmVudCBqYXZhc2NyaXB0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5sZXNzIHVzZXIgZm9yY2UgaXQgd2l0aCBhbnlMaW5rcyBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsaWRfaHJlZihkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICc8YSB0YXJnZXQ9XCJfYmxhbmtcIic7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnIGhyZWY9XCInICsgZGF0YSArICdcIic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyByZWw9XCInICsgcmVsX2F0dHIoKS5qb2luKCcgJykgKyAnXCInO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgZm9jdXMgdG8gdGVybWluYWwgdGV4dGFyZWEgdGhhdCB3aWxsIGVuYWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyB0ZXJtaW5hbCB3aGVuIHByZXNzaW5nIHRhYiBhbmQgdGVybWluYWwgaXMgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgdGFiaW5kZXg9XCIxMDAwXCInO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUuaW5kZXhPZignQCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAnPGltZyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZF9zcmMoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnIHNyYz1cIicgKyBkYXRhICsgJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICc8c3Bhbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBhZGRfYXR0cnMoYXR0cnMpO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZV9zdHIgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnIHN0eWxlPVwiJyArIHN0eWxlX3N0ciArICdcIic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfY2xhc3MgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnIGNsYXNzPVwiJyArIF9jbGFzcyArICdcIic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGxpbmtzIGFuZCBpbWFnZSBuZWVkIGRhdGEtdGV4dCBhdHRyaWJ1dGUgY21kIGNsaWNrIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgLy8gZm9ybWF0dGVyIGNhbiByZXR1cm4gbGlua3MuXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmluZGV4T2YoJyEnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgZGF0YS10ZXh0PicgKyB0ZXh0ICsgJzwvYT4nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUuaW5kZXhPZignQCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyBkYXRhLXRleHQvPic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgZGF0YS10ZXh0PVwiJyArIGRhdGEucmVwbGFjZSgvXCIvZywgJyZxdW90OycpICsgJ1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArICc8L3NwYW4+JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIGZvcm1hdGluZyBmb29bW3U7O11iYXJdYmF6W1tiOyNmZmY7XXF1dXhdenp6XG4gICAgICAgICAgICAgICAgdmFyIHNwbGl0dGVkID0gJC50ZXJtaW5hbC5mb3JtYXRfc3BsaXQoc3RyKTtcbiAgICAgICAgICAgICAgICBzdHIgPSAkLm1hcChzcGxpdHRlZCwgZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCQudGVybWluYWwuaXNfZm9ybWF0dGluZyh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4ICZuYnNwOyBpbnNpZGUgZm9ybWF0dGluZyBiZWNhdXNlIGVuY29kZSBpcyBjYWxsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlZm9yZSBmb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcW1xcW1teXFxdXStcXF0vLCBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvJm5ic3A7L2csICcgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoZm9ybWF0X3BhcnRzX3JlLCBmb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHNhZmUodGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXFxcXFxdLywgJyYjOTM7Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmEgPSBleHRyYV9jc3ModGV4dCwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB3aWRlX2NoYXJhY3RlcnModGV4dCwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnPHNwYW4gc3R5bGU9XCInICsgZXh0cmEgKyAnXCI+JyArIHRleHQgKyAnPC9zcGFuPic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnPHNwYW4+JyArIHRleHQgKyAnPC9zcGFuPic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLzxzcGFuPjxiclxccypcXC8/PjxcXC9zcGFuPi9naSwgJzxici8+Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IFJlcGxhY2UgYnJhY2tldHMgd2l0aCBodG1sIGVudGl0aWVzXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBlc2NhcGVfYnJhY2tldHM6IGZ1bmN0aW9uIGVzY2FwZV9icmFja2V0cyhzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxbL2csICcmIzkxOycpLnJlcGxhY2UoL1xcXS9nLCAnJiM5MzsnKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IGNvbXBsbWVudGFyeSBmdW5jdGlvblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdW5lc2NhcGVfYnJhY2tldHM6IGZ1bmN0aW9uIHVuZXNjYXBlX2JyYWNrZXRzKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8mIzkxOy9nLCAnWycpLnJlcGxhY2UoLyYjOTM7L2csICddJyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiByZXR1cm4gbnVtYmVyIG9mIGNoYXJhY3RlcnMgd2l0aG91dCBmb3JtYXR0aW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uKHN0cmluZywgcmF3KSB7XG4gICAgICAgICAgICByZXR1cm4gJC50ZXJtaW5hbC5zcGxpdF9jaGFyYWN0ZXJzKHJhdyA/IHN0cmluZyA6IHRleHQoc3RyaW5nKSkubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogc3BsaXQgY2hhcmFjdGVycyBoYW5kbGluZyBlbW9qaSwgc3Vyb2dhdGUgcGFpcnMgYW5kIGNvbWJpbmUgY2hhcnNcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHNwbGl0X2NoYXJhY3RlcnM6IGZ1bmN0aW9uIHNwbGl0X2NoYXJhY3RlcnMoc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgZ2V0X25leHRfY2hhcmFjdGVyID0gbWFrZV9uZXh0X2NoYXJfZnVuKHN0cmluZyk7XG4gICAgICAgICAgICB3aGlsZSAoc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjaHIgPSBnZXRfbmV4dF9jaGFyYWN0ZXIoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoY2hyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiByZXR1cm4gc3RyaW5nIHdoZXJlIGFycmF5IGl0ZW1zIGFyZSBpbiBjb2x1bW5zIHBhZGRlZCBzcGFjZXNcbiAgICAgICAgLy8gOjogYWZ0ZXIgYWRkaW5nIGFsaWduIHRhYnMgYXJyLmpvaW4oJ1xcdFxcdCcpIGxvb2tzIG11Y2ggYmV0dGVyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBjb2x1bW5zOiBmdW5jdGlvbihhcnJheSwgY29scywgc3BhY2UpIHtcbiAgICAgICAgICAgIHZhciBub19mb3JtYXR0aW5nID0gYXJyYXkubWFwKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLnRlcm1pbmFsLnN0cmlwKHN0cmluZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBsZW5ndGhzID0gbm9fZm9ybWF0dGluZy5tYXAoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmxlbihzdHJpbmcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwYWNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHNwYWNlID0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1heC5hcHBseShudWxsLCBsZW5ndGhzKSArIHNwYWNlO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB2YWx1ZSAtIDEgYmVjYXVzZSBpbmRleCBzdGFydHMgZnJvbSAwXG4gICAgICAgICAgICB2YXIgY29sdW1uX2xpbWl0ID0gTWF0aC5mbG9vcihjb2xzIC8gbGVuZ3RoKSAtIDE7XG4gICAgICAgICAgICBpZiAoY29sdW1uX2xpbWl0IDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSArPSBjb2x1bW5fbGltaXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGFycmF5LnNsaWNlKGksIGkgKyBjb2x1bW5fbGltaXQpO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gbGluZS5wb3AoKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUucmVkdWNlKGZ1bmN0aW9uKGFjYywgc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJpcHBlZCA9ICQudGVybWluYWwuc3RyaXAoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZCA9IG5ldyBBcnJheShsZW5ndGggLSBzdHJpcHBlZC5sZW5ndGggKyAxKS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgIGFjYy5wdXNoKHN0cmluZyArIHBhZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgfSwgW10pLmpvaW4oJycpICsgbGFzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBSZW1vdmUgZm9ybWF0dGluZyBmcm9tIHRleHRcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHN0cmlwOiBmdW5jdGlvbiBzdHJpcChzdHIpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKGZvcm1hdF9wYXJ0c19yZSwgJyQ2Jyk7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwoW1tcXF1dKS9nLCBmdW5jdGlvbih3aG9sZSwgYnJhY2tldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBicmFja2V0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBSZXR1cm4gYWN0aXZlIHRlcm1pbmFsXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBhY3RpdmU6IGZ1bmN0aW9uIGFjdGl2ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXJtaW5hbHMuZnJvbnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IEltcGxtZW50YXRpb24gZGV0YWlsIGlkIGlzIGFsd2F5cyBsZW5ndGggb2YgdGVybWluYWxzIEN5Y2xlXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBsYXN0X2lkOiBmdW5jdGlvbiBsYXN0X2lkKCkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IHRlcm1pbmFscy5sZW5ndGgoKTtcbiAgICAgICAgICAgIHJldHVybiBsZW4gLSAxO1xuICAgICAgICB9LFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogRnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIHN0cmluZ3MgbGlrZSAnYXNkJyAnYXNkXFwnIGFzZCcgXCJhc2QgYXNkXCJcbiAgICAgICAgLy8gOjogYXNkXFwgMTIzIC1uIC1iIC8gW14gXSsgLyAvXFxzKy8gYXNkXFwgYSBpdCBjcmVhdGVzIGEgcmVnZXggYW5kXG4gICAgICAgIC8vIDo6IG51bWJlcnMgYW5kIHJlcGxhY2VzIGVzY2FwZSBjaGFyYWN0ZXJzIGluIGRvdWJsZSBxdW90ZXNcbiAgICAgICAgLy8gOjogaWYgc3RyaWN0IGlzIHNldCB0byBmYWxzZSBpdCBvbmx5IHN0cmlwcyBzaW5nbGUgYW5kIGRvdWJsZSBxdW90ZXNcbiAgICAgICAgLy8gOjogYW5kIGVzY2FwZXMgc3BhY2VzXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBwYXJzZV9hcmd1bWVudDogZnVuY3Rpb24gcGFyc2VfYXJndW1lbnQoYXJnLCBzdHJpY3QpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlX3N0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCBzdHJpbmcgdG8gc3RyaW5nIGxpdGVyYWxzIGFuZCBub24tc3RyaW5nc1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc3RyaW5nX3JlKS5tYXAoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBxdW90ZXMgaWYgYmVmb3JlIGFyZSBldmVuIG51bWJlciBvZiBzbGFzaGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHJlbW92ZSBzbGFzZXMgYmVjdWFzZSB0aGV5IGFyZSBoYW5kbGVkIGJ5IEpTT04ucGFyc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZy5tYXRjaCgvXlsnXCJdLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpeGluZyByZWdleCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgaXMgbm90IHdvcnRoIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nID09PSAnXCJcIicgfHwgc3RyaW5nID09PSBcIicnXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcXVvdGUgPSBzdHJpbmdbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiKF58KD86XFxcXFxcXFwoPzpcXFxcXFxcXCkqKT8pXCIgKyBxdW90ZSwgXCJnXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmUsIFwiJDFcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gJ1wiJyArIHN0cmluZyArICdcIic7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBidWlsZCBpbiBmdW5jdGlvbiB0byBwYXJzZSByZXN0IG9mIGVzY2FwZWQgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmcpO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmljdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnWzBdID09PSBcIidcIiAmJiBhcmdbYXJnLmxlbmd0aCAtIDFdID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLnJlcGxhY2UoL14nfCckL2csICcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ1swXSA9PT0gJ1wiJyAmJiBhcmdbYXJnLmxlbmd0aCAtIDFdID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcucmVwbGFjZSgvXlwifFwiJC9nLCAnJykucmVwbGFjZSgvXFxcXChbXCIgXSkvZywgJyQxJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcubWF0Y2goL1xcLy4qXFwvW2dpbXldKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLm1hdGNoKC9bJ1wiXV0vKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0IG9mIGFyZyBpcyBpbiBxdW90ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2Vfc3RyaW5nKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5yZXBsYWNlKC9cXFxcIC9nLCAnICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZWdleCA9IGFyZy5tYXRjaChyZV9yZSk7XG4gICAgICAgICAgICBpZiAocmVnZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleFsxXSwgcmVnZXhbMl0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcubWF0Y2goL1snXCJdLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2Vfc3RyaW5nKGFyZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZy5tYXRjaCgvXi0/WzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGFyZywgMTApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcubWF0Y2goZmxvYXRfcmUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoYXJnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5yZXBsYWNlKC9cXFxcKFsnXCIoKSBdKS9nLCAnJDEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IGZ1bmN0aW9uIHNwbGl0IGFuZCBwYXJzZSBhcmd1bWVudHNcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHBhcnNlX2FyZ3VtZW50czogZnVuY3Rpb24gcGFyc2VfYXJndW1lbnRzKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuICQubWFwKHN0cmluZy5tYXRjaChjb21tYW5kX3JlKSB8fCBbXSwgJC50ZXJtaW5hbC5wYXJzZV9hcmd1bWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBGdW5jdGlvbiBzcGxpdCBhbmQgc3RyaXBzIHNpbmdsZSBhbmQgZG91YmxlIHF1b3Rlc1xuICAgICAgICAvLyA6OiBhbmQgZXNjYXBlcyBzcGFjZXNcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHNwbGl0X2FyZ3VtZW50czogZnVuY3Rpb24gc3BsaXRfYXJndW1lbnRzKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuICQubWFwKHN0cmluZy5tYXRjaChjb21tYW5kX3JlKSB8fCBbXSwgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQudGVybWluYWwucGFyc2VfYXJndW1lbnQoYXJnLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qge25hbWUsYXJnc30uIEFyZ3VtZW50cyBhcmUgcGFyc2VkXG4gICAgICAgIC8vIDo6IHVzaW5nIHRoZSBmdW5jdGlvbiBwYXJzZV9hcmd1bWVudHNcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHBhcnNlX2NvbW1hbmQ6IGZ1bmN0aW9uIHBhcnNlX2NvbW1hbmQoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc19jb21tYW5kKHN0cmluZywgJC50ZXJtaW5hbC5wYXJzZV9hcmd1bWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBTYW1lIGFzIHBhcnNlX2NvbW1hbmQgYnV0IGFyZ3VtZW50cyBhcmUgcGFyc2VkIHVzaW5nIHNwbGl0X2FyZ3VtZW50c1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgc3BsaXRfY29tbWFuZDogZnVuY3Rpb24gc3BsaXRfY29tbWFuZChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzX2NvbW1hbmQoc3RyaW5nLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJC50ZXJtaW5hbC5wYXJzZV9hcmd1bWVudChhcmcsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjsgZnVuY3Rpb24gdGhhdCBwYXJzZSBhcmd1bWVudHMgbGlrZSB5YXJncyBsaWJyYXJ5XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBwYXJzZV9vcHRpb25zOiBmdW5jdGlvbiBwYXJzZV9vcHRpb25zKGFyZywgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQoe30sIHtcbiAgICAgICAgICAgICAgICBib29sZWFuOiBbXVxuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2Vfb3B0aW9ucygkLnRlcm1pbmFsLnNwbGl0X2FyZ3VtZW50cyhhcmcpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgXzogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmdW5jdGlvbiB0b2tlbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN0ID0gYXJnLnJlZHVjZShmdW5jdGlvbihhY2MsIGFyZykge1xuICAgICAgICAgICAgICAgIHZhciBzdHIgPSB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyA/IGFyZyA6ICcnO1xuICAgICAgICAgICAgICAgIGlmIChzdHIubWF0Y2goL14tLykgJiYgYWNjIGluc3RhbmNlb2YgdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2FjYy52YWx1ZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyLm1hdGNoKC9eLS0vKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHN0ci5yZXBsYWNlKC9eLS0vLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5ib29sZWFuLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRva2VuKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyLm1hdGNoKC9eLS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaW5nbGUgPSBzdHIucmVwbGFjZSgvXi0vLCAnJykuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYm9vbGVhbi5pbmRleE9mKHNpbmdsZS5zbGljZSgtMSlbMF0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBzaW5nbGUucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlLmZvckVhY2goZnVuY3Rpb24oc2luZ2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbc2luZ2xlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0b2tlbihsYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWNjIGluc3RhbmNlb2YgdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2FjYy52YWx1ZV0gPSBhcmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Ll8ucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sIG51bGwpO1xuICAgICAgICAgICAgaWYgKHJlc3QgaW5zdGFuY2VvZiB0b2tlbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN0LnZhbHVlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogZnVuY3Rpb24gZXhlY3V0ZWQgZm9yIGVhY2ggdGV4dCBpbnNpZGUgW1sgLi4uLiBdXSBpbiBlY2hvXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBleHRlbmRlZF9jb21tYW5kOiBmdW5jdGlvbiBleHRlbmRlZF9jb21tYW5kKHRlcm0sIHN0cmluZywgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGludm9rZU1ldGhvZHM6IGZhbHNlXG4gICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlX2hhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHN0cmluZy5tYXRjaChleHRlbmRlZF9jb21tYW5kX3JlKTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmludm9rZU1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ1RvIGludm9rZSB0ZXJtaW5hbCBvciBjbWQgbWV0aG9kcyB5b3UgbmVlZCB0byBlbmFibGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbnZva2VNZXRob2RzIG9wdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IG1bMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBtWzJdID09PSAndGVybWluYWwnID8gdGVybSA6IHRlcm0uY21kKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IG1bM107XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGV2YWwoJ1snICsgbVs0XSArICddJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9ialtmbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtLmVycm9yKCdVbmtub3cgZnVuY3Rpb24gJyArIGZuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2ZuXS5hcHBseSh0ZXJtLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVybS5lcnJvcignSW52YWxpZCBpbnZvY2F0aW9uIGluICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLnRlcm1pbmFsLmVzY2FwZV9icmFja2V0cyhzdHJpbmcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRlcm0uZXhlYyhzdHJpbmcsIHRydWUpLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VfaGFzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBlcnJvciBpcyBwcm9jZXNzIGluIGV4ZWNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IEVTNiBpdGVyYXRvciBmb3IgYSBnaXZlbiBzdHJpbmcgdGhhdCBoYW5kbGUgZW1vamkgYW5kIGZvcm1hdHRpbmdcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGl0ZXJhdG9yOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdHRpbmcoc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCQudGVybWluYWwuaXNfZm9ybWF0dGluZyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmcubWF0Y2goL1xcXVxcXFxcXF0vKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1xcXVxcXFxcXF0vZywgJ11cXFxcXFxcXF0nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gJC50ZXJtaW5hbC5sZW5ndGgoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICAgICAgICAgIG9ialtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9ICQudGVybWluYWwuc3Vic3RyaW5nKHN0cmluZywgaSwgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZm9ybWF0dGluZyh0ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGluIHN0cmluZyBtZXRob2RzIGludGVhZCBvZiByZWdleFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZm9ybWF0dGVyOiBuZXcgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzW1N5bWJvbC5zcGxpdF0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQudGVybWluYWwuZm9ybWF0X3NwbGl0KHN0cmluZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzW1N5bWJvbC5tYXRjaF0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChmb3JtYXRfcmUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpc1tTeW1ib2wucmVwbGFjZV0gPSBmdW5jdGlvbihzdHJpbmcsIHJlcGxhY2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShmb3JtYXRfcGFydHNfcmUsIHJlcGxhY2VyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXNbU3ltYm9sLnNlYXJjaF0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zZWFyY2goZm9ybWF0X3JlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpLFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogaGVscGVyIGZ1bmN0aW9uIHRoYXQgYWRkIGZvcm1hdHRlciBiZWZvcmUgbmVzdGVkX2Zvcm1hdHRpbmdcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIG5ld19mb3JtYXR0ZXI6IGZ1bmN0aW9uKGZvcm1hdHRlcikge1xuICAgICAgICAgICAgdmFyIGZvcm1hdHRlcnMgPSAkLnRlcm1pbmFsLmRlZmF1bHRzLmZvcm1hdHRlcnM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm1hdHRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVyc1tpXSA9PT0gJC50ZXJtaW5hbC5uZXN0ZWRfZm9ybWF0dGluZykge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXJzLnNwbGljZShpLCAwLCBmb3JtYXR0ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAkLnRlcm1pbmFsLkV4Y2VwdGlvbiA9IGZ1bmN0aW9uIFRlcm1pbmFsX0V4Y2VwdGlvbih0eXBlLCBtZXNzYWdlLCBzdGFjaykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ1RFUk1JTkFMJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAkLnRlcm1pbmFsLkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICAkLnRlcm1pbmFsLkV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZSArICdcXG4nICsgdGhpcy5zdGFjaztcbiAgICB9O1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gSGVscGVyIHBsdWdpbnMgYW5kIGZ1bmN0aW9uc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgJC5mbi52aXNpYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNzcygndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgfTtcbiAgICAkLmZuLmhpZGRlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciB3YXJuaW5ncyA9IFtdO1xuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIG1zZyA9ICdbalF1ZXJ5IFRlcm1pbmFsXSAnICsgbXNnO1xuICAgICAgICBpZiAod2FybmluZ3MuaW5kZXhPZihtc2cpID09PSAtMSkge1xuICAgICAgICAgICAgd2FybmluZ3MucHVzaChtc2cpO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgICAgICAgIGlmIChjb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBjYXRjaGluZyBpbiBvdXRlciB0cnkuLmNhdGNoXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXQVJOOiAnICsgbXNnKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEpTT04tUlBDIENBTExcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBpZHMgPSB7fTsgLy8gbGlzdCBvZiB1cmwgYmFzZWQgaWRzIG9mIEpTT04tUlBDXG4gICAgJC5qcnBjID0gZnVuY3Rpb24odXJsLCBtZXRob2QsIHBhcmFtcywgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3ICQuRGVmZXJyZWQoKTtcbiAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QodXJsKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHVybDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgc3VjY2Vzczogc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRKU09OUlBDKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gJC5pc051bWVyaWMocmVzcG9uc2UuaWQpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiByZXNwb25zZS5yZXN1bHQgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICAgICAgIHR5cGVvZiByZXNwb25zZS5lcnJvciAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlkc1tvcHRpb25zLnVybF0gPSBpZHNbb3B0aW9ucy51cmxdIHx8IDA7XG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ2pzb25ycGMnOiAnMi4wJyxcbiAgICAgICAgICAgICdtZXRob2QnOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICdwYXJhbXMnOiBvcHRpb25zLnBhcmFtcyxcbiAgICAgICAgICAgICdpZCc6ICsraWRzW29wdGlvbnMudXJsXVxuICAgICAgICB9O1xuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uIGJlZm9yZVNlbmQoanhociwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24ob3B0aW9ucy5yZXF1ZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJlcXVlc3QoanhociwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRhdGEgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKHJlc3BvbnNlLCBzdGF0dXMsIGpxWEhSKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRfdHlwZSA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRfdHlwZS5tYXRjaCgvKGFwcGxpY2F0aW9ufHRleHQpXFwvanNvbi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ1Jlc3BvbnNlIENvbnRlbnQtVHlwZSBpcyBuZWl0aGVyIGFwcGxpY2F0aW9uL2pzb24nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnIG5vciB0ZXh0L2pzb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGpzb247XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IoanFYSFIsICdJbnZhbGlkIEpTT04nLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyAkLnRlcm1pbmFsLkV4Y2VwdGlvbignSlNPTicsICdJbnZhbGlkIEpTT04nLCBlLnN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3Qoe21lc3NhZ2U6ICdJbnZhbGlkIEpTT04nLCByZXNwb25zZTogcmVzcG9uc2V9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24ob3B0aW9ucy5yZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZXNwb25zZShqcVhIUiwganNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWxpZEpTT05SUEMoanNvbikgfHwgb3B0aW9ucy5tZXRob2QgPT09ICdzeXN0ZW0uZGVzY3JpYmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGNhdGNoIGVycm9ycyBpbiBzdWNjZXNzIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3VjY2Vzcyhqc29uLCBzdGF0dXMsIGpxWEhSKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGpzb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmVycm9yKGpxWEhSLCAnSW52YWxpZCBKU09OLVJQQycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCh7bWVzc2FnZTogJ0ludmFsaWQgSlNPTi1SUEMnLCByZXNwb25zZTogcmVzcG9uc2V9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IG9wdGlvbnMuZXJyb3IsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgLy8gdGltZW91dDogMSxcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICB9O1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKlxuICAgIGZ1bmN0aW9uIGlzX3Njcm9sbGVkX2ludG9fdmlldyhlbGVtKSB7XG4gICAgICAgIHZhciBkb2NWaWV3VG9wID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuICAgICAgICB2YXIgZG9jVmlld0JvdHRvbSA9IGRvY1ZpZXdUb3AgKyAkKHdpbmRvdykuaGVpZ2h0KCk7XG5cbiAgICAgICAgdmFyIGVsZW1Ub3AgPSAkKGVsZW0pLm9mZnNldCgpLnRvcDtcbiAgICAgICAgdmFyIGVsZW1Cb3R0b20gPSBlbGVtVG9wICsgJChlbGVtKS5oZWlnaHQoKTtcblxuICAgICAgICByZXR1cm4gKChlbGVtQm90dG9tID49IGRvY1ZpZXdUb3ApICYmIChlbGVtVG9wIDw9IGRvY1ZpZXdCb3R0b20pKTtcbiAgICB9XG4gICAgKi9cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIHRlcm1pbmFsX3JlYWR5KHRlcm0pIHtcbiAgICAgICAgcmV0dXJuICEhKHRlcm0uY2xvc2VzdCgnYm9keScpLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgdGVybS5pcygnOnZpc2libGUnKSAmJlxuICAgICAgICAgICAgICAgICAgdGVybS5maW5kKCcuY21kLXByb21wdCcpLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gOjogQ3JlYXRlIGZha2UgdGVybWluYWwgdG8gY2FsY3VhbHRlIHRoZSBkaW1lbnRpb24gb2Ygb25lIGNoYXJhY3RlclxuICAgIC8vIDo6IHRoaXMgd2lsbCBtYWtlIHRlcm1pbmFsIHdvcmsgaWYgdGVybWluYWwgZGl2IGlzIG5vdCBhZGRlZCB0byB0aGVcbiAgICAvLyA6OiBET00gYXQgaW5pdCBsaWtlIHdpdGg6XG4gICAgLy8gOjogJCgnPGRpdi8+JykudGVybWluYWwoKS5lY2hvKCdmb28gYmFyJykuYXBwZW5kVG8oJ2JvZHknKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGdldF9jaGFyX3NpemUodGVybSkge1xuICAgICAgICB2YXIgcmVjdDtcbiAgICAgICAgaWYgKHRlcm1pbmFsX3JlYWR5KHRlcm0pKSB7XG4gICAgICAgICAgICB2YXIgJHByb21wdCA9IHRlcm0uZmluZCgnLmNtZC1wcm9tcHQnKS5jbG9uZSgpLmNzcyh7XG4gICAgICAgICAgICAgICAgdmlzaWJsaXR5OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkcHJvbXB0LmFwcGVuZFRvKHRlcm0uZmluZCgnLmNtZCcpKS5odG1sKCcmbmJzcDsnKTtcbiAgICAgICAgICAgIHJlY3QgPSAkcHJvbXB0WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgJHByb21wdC5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gJCgnPGRpdiBjbGFzcz1cInRlcm1pbmFsIHRlcm1pbmFsLXRlbXBcIj48ZGl2IGNsYXNzPVwidGVybWluYWwtJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3dyYXBwZXJcIj48ZGl2IGNsYXNzPVwidGVybWluYWwtb3V0cHV0XCI+PGRpdj48ZGl2IGNsYXNzPVwidGUnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAncm1pbmFsLWxpbmVcIiBzdHlsZT1cImZsb2F0OiBsZWZ0XCI+PHNwYW4+Jm5ic3A7PC9zcGFuPjwvZGl2JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJz48L2Rpdj48L2Rpdj48L2Rpdj4nKS5hcHBlbmRUbygnYm9keScpO1xuICAgICAgICAgICAgdGVtcC5hZGRDbGFzcyh0ZXJtLmF0dHIoJ2NsYXNzJykpLmF0dHIoJ2lkJywgdGVybS5hdHRyKCdpZCcpKTtcbiAgICAgICAgICAgIGlmICh0ZXJtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gdGVybS5hdHRyKCdzdHlsZScpO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlLnNwbGl0KC9cXHMqO1xccyovKS5maWx0ZXIoZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFzLm1hdGNoKC9kaXNwbGF5XFxzKjpcXHMqbm9uZS9pKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuam9pbignOycpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wLmF0dHIoJ3N0eWxlJywgc3R5bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY3QgPSB0ZW1wLmZpbmQoJy50ZXJtaW5hbC1saW5lJylbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGVtcCkge1xuICAgICAgICAgICAgdGVtcC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDo6IGNhbGN1bGF0ZSBudW1iZXJzIG9mIGNoYXJhY3RlcnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGdldF9udW1fY2hhcnModGVybWluYWwsIGNoYXJfc2l6ZSkge1xuICAgICAgICB2YXIgd2lkdGggPSB0ZXJtaW5hbC5maW5kKCcudGVybWluYWwtZmlsbCcpLndpZHRoKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBNYXRoLmZsb29yKHdpZHRoIC8gY2hhcl9zaXplLndpZHRoKTtcbiAgICAgICAgLy8gcmFuZG9tIG51bWJlciB0byBub3QgZ2V0IE5hTiBpbiBub2RlLmpzIGJ1dCBiaWcgZW5vdWdoIHRvXG4gICAgICAgIC8vIG5vdCB3cmFwIGV4Y2VwdGlvblxuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IDEwMDA7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gOjogQ2FsY3VsYXRlIG51bWJlciBvZiBsaW5lcyB0aGF0IGZpdCB3aXRob3V0IHNjcm9sbFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gZ2V0X251bV9yb3dzKHRlcm1pbmFsLCBjaGFyX3NpemUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGVybWluYWwuZmluZCgnLnRlcm1pbmFsLWZpbGwnKS5oZWlnaHQoKSAvIGNoYXJfc2l6ZS5oZWlnaHQpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIGFsbChhcnJheSwgZm4pIHtcbiAgICAgICAgdmFyIHNhbWUgPSBhcnJheS5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1bZm5dKCkgPT09IGl0ZW07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2FtZS5sZW5ndGggPT09IGFycmF5Lmxlbmd0aDtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBzdHJpbmdfY2FzZShzdHJpbmcpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gc3RyaW5nLnNwbGl0KCcnKTtcbiAgICAgICAgaWYgKGFsbChhcnJheSwgJ3RvTG93ZXJDYXNlJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnbG93ZXInO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbChhcnJheSwgJ3RvVXBwZXJDYXNlJykpIHtcbiAgICAgICAgICAgIHJldHVybiAndXBwZXInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdtaXhlZCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBzYW1lX2Nhc2Uoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdfY2FzZShzdHJpbmcpICE9PSAnbWl4ZWQnO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGZpeCBmb3IgalF1ZXJ5IGJ1Z1xuICAgIGZ1bmN0aW9uIGlzX2Z1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZ2V0X3R5cGUob2JqZWN0KSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBpc19hcnJheShvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGdldF90eXBlKG9iamVjdCkgPT09ICdhcnJheSc7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gZ2V0X3R5cGUob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nID8gJ2Z1bmN0aW9uJyA6ICQudHlwZShvYmplY3QpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDo6IFRFUk1JTkFMIFBMVUdJTiBDT0RFXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICB2YXIgdmVyc2lvbl9zZXQgPSAhJC50ZXJtaW5hbC52ZXJzaW9uLm1hdGNoKC9eXFx7XFx7Lyk7XG4gICAgdmFyIGNvcHlyaWdodCA9ICdDb3B5cmlnaHQgKGMpIDIwMTEtMjAxOSBKYWt1YiBULiBKYW5raWV3aWN6ICcgK1xuICAgICAgICAnPGh0dHBzOi8vamN1YmljLnBsL21lPic7XG4gICAgdmFyIHZlcnNpb25fc3RyaW5nID0gdmVyc2lvbl9zZXQgPyAnIHYuICcgKyAkLnRlcm1pbmFsLnZlcnNpb24gOiAnICc7XG4gICAgLy8gcmVnZXggaXMgZm9yIHBsYWNpbmcgdmVyc2lvbiBzdHJpbmcgYWxpZ25lZCB0byB0aGUgcmlnaHRcbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cCgnIHsnICsgdmVyc2lvbl9zdHJpbmcubGVuZ3RoICsgJ30kJyk7XG4gICAgdmFyIG5hbWVfdmVyID0gJ2pRdWVyeSBUZXJtaW5hbCBFbXVsYXRvcicgK1xuICAgICAgICAodmVyc2lvbl9zZXQgPyB2ZXJzaW9uX3N0cmluZyA6ICcnKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIDo6IFRlcm1pbmFsIFNpZ25hdHVyZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBzaWduYXR1cmVzID0gW1xuICAgICAgICBbJ2pRdWVyeSBUZXJtaW5hbCcsICcoYykgMjAxMS0yMDE5IGpjdWJpYyddLFxuICAgICAgICBbbmFtZV92ZXIsIGNvcHlyaWdodC5yZXBsYWNlKC9eQ29weXJpZ2h0IHwgKjwuKj4vZywgJycpXSxcbiAgICAgICAgW25hbWVfdmVyLCBjb3B5cmlnaHQucmVwbGFjZSgvXkNvcHlyaWdodCAvLCAnJyldLFxuICAgICAgICBbXG4gICAgICAgICAgICAnICAgICAgX19fX19fXyAgICAgICAgICAgICAgICAgX19fX19fX18gICAgICAgICAgICAgICAgICAgICAgICBfXycsXG4gICAgICAgICAgICAnICAgICAvIC8gXyAgL18gX19fX19fX19fX19fIF8vX18gIF9fXy9fX19fX19fX19fX19fXyAgX19fX18gIC8gLycsXG4gICAgICAgICAgICAnIF9fIC8gLyAvLyAvIC8vIC8gXyAgLyBfLyAvLyAvIC8gLyBfICAvIF8vICAgICAvIC8gIFxcXFwvIC8gXyBcXFxcLyAvJyxcbiAgICAgICAgICAgICcvICAvIC8gLy8gLyAvLyAvIF9fXy8gLy8gLy8gLyAvIC8gX19fLyAvLyAvIC8gLyAvIC9cXFxcICAvIC8vIC8gL19fJyxcbiAgICAgICAgICAgICdcXFxcX19fL19fX18gXFxcXFxcXFxfXy9fX19fL18vIFxcXFxfXyAvIC9fL19fX18vXy8vXy9fL18vXy9fLyAgXFxcXC9cXFxcX19cXFxcX1xcXFxfX18vJyxcbiAgICAgICAgICAgICcgICAgICAgICBcXFxcLyAgICAgICAgICAvX19fXy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcbiAgICAgICAgICAgICAgICAucmVwbGFjZShyZWcsICcgJykgKyB2ZXJzaW9uX3N0cmluZyxcbiAgICAgICAgICAgIGNvcHlyaWdodFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnICAgICAgX18gX19fX18gICAgICAgICAgICAgICAgICAgICBfX19fX19fXyAgICAgICAgICAgICAgICAgICAgICAgICAgICAnICtcbiAgICAgICAgICAgICAgICAnICBfXycsXG4gICAgICAgICAgICAnICAgICAvIC8vIF8gIC9fXyBfXyBfX19fXyBfX18gX18gXy9fXyAgX19fL19fIF9fXyBfX19fX18gX18gX18gIF9fIF9fXyAnICtcbiAgICAgICAgICAgICAgICAnIC8gLycsXG4gICAgICAgICAgICAnIF9fIC8gLy8gLy8gLy8gLy8gLy8gXyAgLy8gXy8vIC8vIC8gLyAvLyBfICAvLyBfLy8gICAgIC8vIC8vICBcXFxcLyAvLyBfICcgK1xuICAgICAgICAgICAgICAgICdcXFxcLyAvJyxcbiAgICAgICAgICAgICcvICAvIC8vIC8vIC8vIC8vIC8vIF9fXy8vIC8gLyAvLyAvIC8gLy8gX19fLy8gLyAvIC8gLyAvLyAvLyAvXFxcXCAgLy8gLy8gJyArXG4gICAgICAgICAgICAgICAgJy8gL19fJyxcbiAgICAgICAgICAgICdcXFxcX19fLy9fX19fIFxcXFxcXFxcX19fLy9fX19fLy9fLyBfXFxcXF8gIC8gL18vL19fX18vL18vIC9fLyAvXy8vXy8vXy8gL18vIFxcXFwnICtcbiAgICAgICAgICAgICAgICAnX19cXFxcX1xcXFxfX18vJyxcbiAgICAgICAgICAgICgnICAgICAgICAgIFxcXFwvICAgICAgICAgICAgICAvX19fXy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyArXG4gICAgICAgICAgICAgJyAgICAgJykucmVwbGFjZShyZWcsICcnKSArIHZlcnNpb25fc3RyaW5nLFxuICAgICAgICAgICAgY29weXJpZ2h0XG4gICAgICAgIF1cbiAgICBdO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gOjogRGVmYXVsdCBvcHRpb25zXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAkLnRlcm1pbmFsLm5lc3RlZF9mb3JtYXR0aW5nLl9fbWV0YV9fID0gdHJ1ZTtcbiAgICAvLyBpZiBzZXQgdG8gdHJ1ZSBuZXN0ZWQgZm9ybWF0dGluZyB3aWxsIGluaGVyaXQgc3R5bGVzIGZyb20gc3R5bGVzIG91dHNpZGVcbiAgICAkLnRlcm1pbmFsLm5lc3RlZF9mb3JtYXR0aW5nLl9faW5oZXJpdF9fID0gZmFsc2U7XG4gICAgLy8gbmVzdGVkIGZvcm1hdHRpbmcgd2lsbCBhbHdheXMgcmV0dXJuIGRpZmZlcmVudCBsZW5ndGggc28gd2Ugc2lsZW50IHRoZSB3YXJuaW5nXG4gICAgJC50ZXJtaW5hbC5uZXN0ZWRfZm9ybWF0dGluZy5fX25vX3dhcm5fXyA9IHRydWU7XG4gICAgJC50ZXJtaW5hbC5kZWZhdWx0cyA9IHtcbiAgICAgICAgcHJvbXB0OiAnPiAnLFxuICAgICAgICBoaXN0b3J5OiB0cnVlLFxuICAgICAgICBleGl0OiB0cnVlLFxuICAgICAgICBjbGVhcjogdHJ1ZSxcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgbWFza0NoYXI6ICcqJyxcbiAgICAgICAgd3JhcDogdHJ1ZSxcbiAgICAgICAgY2hlY2tBcml0eTogdHJ1ZSxcbiAgICAgICAgcmF3OiBmYWxzZSxcbiAgICAgICAgdGFiaW5kZXg6IDEsXG4gICAgICAgIGludm9rZU1ldGhvZHM6IGZhbHNlLFxuICAgICAgICBleGNlcHRpb25IYW5kbGVyOiBudWxsLFxuICAgICAgICBwYXVzZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgc29mdFBhdXNlOiBmYWxzZSxcbiAgICAgICAgbWVtb3J5OiBmYWxzZSxcbiAgICAgICAgY2FuY2VsYWJsZUFqYXg6IHRydWUsXG4gICAgICAgIHByb2Nlc3NBcmd1bWVudHM6IHRydWUsXG4gICAgICAgIGxpbmtzTm9SZWZlcnJlcjogZmFsc2UsXG4gICAgICAgIGFueUxpbmtzOiBmYWxzZSxcbiAgICAgICAgbGlua3NOb0ZvbGxvdzogZmFsc2UsXG4gICAgICAgIHByb2Nlc3NSUENSZXNwb25zZTogbnVsbCxcbiAgICAgICAgY29tcGxldGlvbkVzY2FwZTogdHJ1ZSxcbiAgICAgICAgb25Db21tYW5kQ2hhbmdlOiBudWxsLFxuICAgICAgICBtb2JpbGVEZWxldGU6IGlzX21vYmlsZSxcbiAgICAgICAgb25Qb3NpdGlvbkNoYW5nZTogbnVsbCxcbiAgICAgICAgY29udmVydExpbmtzOiB0cnVlLFxuICAgICAgICBleHRyYToge30sXG4gICAgICAgIHRhYnM6IDQsXG4gICAgICAgIGhpc3RvcnlTaXplOiA2MCxcbiAgICAgICAgc2Nyb2xsT2JqZWN0OiBudWxsLFxuICAgICAgICBoaXN0b3J5U3RhdGU6IGZhbHNlLFxuICAgICAgICBpbXBvcnRIaXN0b3J5OiBmYWxzZSxcbiAgICAgICAgaGlzdG9yeUZpbHRlcjogbnVsbCxcbiAgICAgICAgZWNob0NvbW1hbmQ6IHRydWUsXG4gICAgICAgIHNjcm9sbE9uRWNobzogdHJ1ZSxcbiAgICAgICAgbG9naW46IG51bGwsXG4gICAgICAgIG91dHB1dExpbWl0OiAtMSxcbiAgICAgICAgZm9ybWF0dGVyczogWyQudGVybWluYWwubmVzdGVkX2Zvcm1hdHRpbmddLFxuICAgICAgICBvbkFqYXhFcnJvcjogbnVsbCxcbiAgICAgICAgcGFzdGVJbWFnZTogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsQm90dG9tT2Zmc2V0OiAyMCxcbiAgICAgICAgd29yZEF1dG9jb21wbGV0ZTogdHJ1ZSxcbiAgICAgICAgY2FzZVNlbnNpdGl2ZUF1dG9jb21wbGV0ZTogdHJ1ZSxcbiAgICAgICAgY2FzZVNlbnNpdGl2ZVNlYXJjaDogdHJ1ZSxcbiAgICAgICAgY2xpY2tUaW1lb3V0OiAyMDAsXG4gICAgICAgIGhvbGRUaW1lb3V0OiA0MDAsXG4gICAgICAgIGhvbGRSZXBlYXRUaW1lb3V0OiAyMDAsXG4gICAgICAgIHJlcGVhdFRpbWVvdXRLZXlzOiBbXSxcbiAgICAgICAgbW9iaWxlSW5nb3JlQXV0b1NwYWNlOiBbXSxcbiAgICAgICAgcmVxdWVzdDogJC5ub29wLFxuICAgICAgICByZXNwb25zZTogJC5ub29wLFxuICAgICAgICBkZXNjcmliZTogJ3Byb2NzJyxcbiAgICAgICAgb25SUENFcnJvcjogbnVsbCxcbiAgICAgICAgZG91YmxlVGFiOiBudWxsLFxuICAgICAgICBkb3VibGVUYWJFY2hvQ29tbWFuZDogZmFsc2UsXG4gICAgICAgIGNvbXBsZXRpb246IGZhbHNlLFxuICAgICAgICBvbkluaXQ6ICQubm9vcCxcbiAgICAgICAgb25DbGVhcjogJC5ub29wLFxuICAgICAgICBvbkJsdXI6ICQubm9vcCxcbiAgICAgICAgb25Gb2N1czogJC5ub29wLFxuICAgICAgICBvblRlcm1pbmFsQ2hhbmdlOiAkLm5vb3AsXG4gICAgICAgIG9uRXhpdDogJC5ub29wLFxuICAgICAgICBvblB1c2g6ICQubm9vcCxcbiAgICAgICAgb25Qb3A6ICQubm9vcCxcbiAgICAgICAga2V5cHJlc3M6ICQubm9vcCxcbiAgICAgICAga2V5ZG93bjogJC5ub29wLFxuICAgICAgICByZW5kZXJIYW5kbGVyOiBudWxsLFxuICAgICAgICBvbkFmdGVyUmVkcmF3OiAkLm5vb3AsXG4gICAgICAgIG9uRWNob0NvbW1hbmQ6ICQubm9vcCxcbiAgICAgICAgb25QYXN0ZTogJC5ub29wLFxuICAgICAgICBvbkZsdXNoOiAkLm5vb3AsXG4gICAgICAgIG9uQmVmb3JlQ29tbWFuZDogbnVsbCxcbiAgICAgICAgb25BZnRlckNvbW1hbmQ6IG51bGwsXG4gICAgICAgIG9uQmVmb3JlRWNobzogbnVsbCxcbiAgICAgICAgb25BZnRlckVjaG86IG51bGwsXG4gICAgICAgIG9uQmVmb3JlTG9naW46IG51bGwsXG4gICAgICAgIG9uQWZ0ZXJMb2dvdXQ6IG51bGwsXG4gICAgICAgIG9uQmVmb3JlTG9nb3V0OiBudWxsLFxuICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogWyd0aXRsZScsIC9eYXJpYS0vLCAnaWQnLCAvXmRhdGEtL10sXG4gICAgICAgIHN0cmluZ3M6IHtcbiAgICAgICAgICAgIGNvbWxldGlvblBhcmFtZXRlcnM6ICdGcm9tIHZlcnNpb24gMS4wLjAgY29tcGxldGlvbiBmdW5jdGlvbiBuZWVkIHRvJyArXG4gICAgICAgICAgICAgICAgJyBoYXZlIHR3byBhcmd1bWVudHMnLFxuICAgICAgICAgICAgd3JvbmdQYXNzd29yZFRyeUFnYWluOiAnV3JvbmcgcGFzc3dvcmQgdHJ5IGFnYWluIScsXG4gICAgICAgICAgICB3cm9uZ1Bhc3N3b3JkOiAnV3JvbmcgcGFzc3dvcmQhJyxcbiAgICAgICAgICAgIGFqYXhBYm9ydEVycm9yOiAnRXJyb3Igd2hpbGUgYWJvcnRpbmcgYWpheCBjYWxsIScsXG4gICAgICAgICAgICB3cm9uZ0FyaXR5OiBcIldyb25nIG51bWJlciBvZiBhcmd1bWVudHMuIEZ1bmN0aW9uICclcycgZXhwZWN0cyAlcyBnb3RcIiArXG4gICAgICAgICAgICAgICAgJyAlcyEnLFxuICAgICAgICAgICAgY29tbWFuZE5vdEZvdW5kOiBcIkNvbW1hbmQgJyVzJyBOb3QgRm91bmQhXCIsXG4gICAgICAgICAgICBvbmVSUENXaXRoSWdub3JlOiAnWW91IGNhbiB1c2Ugb25seSBvbmUgcnBjIHdpdGggZGVzY3JpYmUgPT0gZmFsc2UgJyArXG4gICAgICAgICAgICAgICAgJ29yIHJwYyB3aXRob3V0IHN5c3RlbS5kZXNjcmliZScsXG4gICAgICAgICAgICBvbmVJbnRlcnByZXRlckZ1bmN0aW9uOiBcIllvdSBjYW4ndCB1c2UgbW9yZSB0aGFuIG9uZSBmdW5jdGlvbiAocnBjIFwiICtcbiAgICAgICAgICAgICAgICAnd2l0aG91dCBzeXN0ZW0uZGVzY3JpYmUgb3Igd2l0aCBvcHRpb24gZGVzY3JpYmUgPT0gZmFsc2UgY291bnQnICtcbiAgICAgICAgICAgICAgICAgJ3MgYXMgb25lKScsXG4gICAgICAgICAgICBsb2dpbkZ1bmN0aW9uTWlzc2luZzogXCJZb3UgZGlkbid0IHNwZWNpZnkgYSBsb2dpbiBmdW5jdGlvblwiLFxuICAgICAgICAgICAgbm9Ub2tlbkVycm9yOiAnQWNjZXNzIGRlbmllZCAobm8gdG9rZW4pJyxcbiAgICAgICAgICAgIHNlcnZlclJlc3BvbnNlOiAnU2VydmVyIHJlc3BvbmRlZCcsXG4gICAgICAgICAgICB3cm9uZ0dyZWV0aW5nczogJ1dyb25nIHZhbHVlIG9mIGdyZWV0aW5ncyBwYXJhbWV0ZXInLFxuICAgICAgICAgICAgbm90V2hpbGVMb2dpbjogXCJZb3UgY2FuJ3QgY2FsbCBgJXMnIGZ1bmN0aW9uIHdoaWxlIGluIGxvZ2luXCIsXG4gICAgICAgICAgICBsb2dpbklzTm90QUZ1bmN0aW9uOiAnQXV0aGVudGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicsXG4gICAgICAgICAgICBjYW5FeGl0RXJyb3I6IFwiWW91IGNhbid0IGV4aXQgZnJvbSBtYWluIGludGVycHJldGVyXCIsXG4gICAgICAgICAgICBpbnZhbGlkQ29tcGxldGlvbjogJ0ludmFsaWQgY29tcGxldGlvbicsXG4gICAgICAgICAgICBpbnZhbGlkU2VsZWN0b3I6ICdTb3JyeSwgYnV0IHRlcm1pbmFsIHNhaWQgdGhhdCB5b3UgdXNlIGludmFsaWQgJyArXG4gICAgICAgICAgICAgICAgJ3NlbGVjdG9yIScsXG4gICAgICAgICAgICBpbnZhbGlkVGVybWluYWxJZDogJ0ludmFsaWQgVGVybWluYWwgSUQnLFxuICAgICAgICAgICAgbG9naW46ICdsb2dpbicsXG4gICAgICAgICAgICBwYXNzd29yZDogJ3Bhc3N3b3JkJyxcbiAgICAgICAgICAgIHJlY3Vyc2l2ZUNhbGw6ICdSZWN1cnNpdmUgY2FsbCBkZXRlY3RlZCwgc2tpcCcsXG4gICAgICAgICAgICBub3RBU3RyaW5nOiAnJXMgZnVuY3Rpb246IGFyZ3VtZW50IGlzIG5vdCBhIHN0cmluZycsXG4gICAgICAgICAgICByZWRyYXdFcnJvcjogJ0ludGVybmFsIGVycm9yLCB3cm9uZyBwb3NpdGlvbiBpbiBjbWQgcmVkcmF3JyxcbiAgICAgICAgICAgIGludmFsaWRTdHJpbmdzOiAnQ29tbWFuZCAlcyBoYXZlIHVuY2xvc2VkIHN0cmluZ3MnLFxuICAgICAgICAgICAgZGVmdW5jdFRlcm1pbmFsOiBcIllvdSBjYW4ndCBjYWxsIG1ldGhvZCBvbiB0ZXJtaW5hbCB0aGF0IHdhcyBkZXN0cm95ZWRcIlxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gOjogQWxsIHRlcm1pbmFsIGdsb2JhbHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIHJlcXVlc3RzID0gW107IC8vIGZvciBjYW5jZWxpbmcgb24gQ1RSTCtEXG4gICAgdmFyIHRlcm1pbmFscyA9IG5ldyBDeWNsZSgpOyAvLyBsaXN0IG9mIHRlcm1pbmFscyBnbG9iYWwgaW4gdGhpcyBzY29wZVxuICAgIC8vIHN0YXRlIGZvciBhbGwgdGVybWluYWxzLCB0ZXJtaW5hbHMgY2FuJ3QgaGF2ZSBvd24gYXJyYXkgZm8gc3RhdGUgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG9ubHkgb25lIHBvcHN0YXRlIGV2ZW50XG4gICAgdmFyIHNhdmVfc3RhdGUgPSBbXTsgLy8gaG9sZCBvYmplY3RzIHJldHVybmVkIGJ5IGV4cG9ydF92aWV3IGJ5IGhpc3RvcnkgQVBJXG4gICAgdmFyIGhhc2hfY29tbWFuZHM7XG4gICAgdmFyIGNoYW5nZV9oYXNoID0gZmFsc2U7IC8vIGRvbid0IGNoYW5nZSBoYXNoIG9uIEluaXRcbiAgICB2YXIgZmlyZV9oYXNoX2NoYW5nZSA9IHRydWU7XG4gICAgdmFyIGZpcnN0X2luc3RhbmNlID0gdHJ1ZTsgLy8gdXNlZCBieSBoaXN0b3J5IHN0YXRlXG4gICAgJC5mbi50ZXJtaW5hbCA9IGZ1bmN0aW9uKGluaXRfaW50ZXJwcmV0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RvcmFnZUhlbHBlcihtZW1vcnkpIHtcbiAgICAgICAgICAgIGlmIChtZW1vcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChtZW1vcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkLlN0b3JhZ2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChtZW1vcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZVtrZXldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkLlN0b3JhZ2UuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lbW9yeSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zdG9yYWdlW2tleV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJC5TdG9yYWdlLnJlbW92ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IGhlbHBlciBmdW5jdGlvblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gZ2V0X3Byb2Nlc3NlZF9jb21tYW5kKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGlmICgkLnRlcm1pbmFsLnVuY2xvc2VkX3N0cmluZ3MoY29tbWFuZCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gJC50ZXJtaW5hbC5lc2NhcGVfYnJhY2tldHMoY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBzcHJpbnRmKHN0cmluZ3MoKS5pbnZhbGlkU3RyaW5ncywgXCJgXCIgKyBzdHJpbmcgKyBcImBcIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3ICQudGVybWluYWwuRXhjZXB0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc19mdW5jdGlvbihzZXR0aW5ncy5wcm9jZXNzQXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzX2NvbW1hbmQoY29tbWFuZCwgc2V0dGluZ3MucHJvY2Vzc0FyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnByb2Nlc3NBcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJC50ZXJtaW5hbC5wYXJzZV9jb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJC50ZXJtaW5hbC5zcGxpdF9jb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBoZWxwZXIgZnVuY3Rpb24gdGhhdCB1c2Ugb3B0aW9uIHRvIHJlbmRlciBvYmplY3RzXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBwcmVwcm9jZXNzX3ZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oc2V0dGluZ3MucmVuZGVySGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gc2V0dGluZ3MucmVuZGVySGFuZGxlci5jYWxsKHNlbGYsIHZhbHVlLCBzZWxmKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmV0ID09PSAnc3RyaW5nJyB8fCBpc19ub2RlKHJldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBjYWxsIHdoZW4gbGluZSBpcyBvdXQgb2YgdmlldyB3aGVuIG91dHB1dExpbWl0IGlzIHVzZWRcbiAgICAgICAgLy8gOjogTk9URTogaXQncyBub3QgY2FsbGVkIHdoZW4gbGVzcyBwbHVnaW4gaXMgdXNlZCBvbkNsZWFyIGlzIGNhbGxlZFxuICAgICAgICAvLyA6OiBpbnN0ZWFkIGJlY2F1c2UgbGVzcyBjYWxsIHRlcm06OmNsZWFyKCkgYWZ0ZXIgZXhwb3J0IG9sZCB2aWV3XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiB1bm1vdW50KG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IG5vZGUuZGF0YSgnaW5kZXgnKTtcbiAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBsaW5lWzFdO1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKG9wdGlvbnMudW5tb3VudCkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVubW91bnQuY2FsbChzZWxmLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogaGVscGVyIGZ1bmN0aW9uIHVzZWQgaW4gcmVuZGVyIGFuZCBpbiB1cGRhdGVcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIHByZXBhcmVfcmVuZGVyKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoaXNfbm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICByYXc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbihkaXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgJC5mbi5pbml0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVlcCBjbG9uZSB3aXRoIGV2ZW50cyAtIHdlIGNsb25lIGJlY2F1c2UgcmVtb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSBET00gd2lsbCByZW1vdmUgZXZlbnRzIGZyb20gb3JpZ2luYWwgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHZhbHVlLmNsb25lKHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBjbG9uZSBodG1sIG5vZGVzIGJlY2F1c2UgaXQgd2lsbCBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3b3JrIGZvciBjYW52YXMgb3IgdmlkZW8gdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2LmZpbmQoJy50ZXJtaW5hbC1yZW5kZXItaXRlbScpLnJlcGxhY2VXaXRoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgaXNfZnVuY3Rpb24ob3B0aW9ucy5maW5hbGl6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZpbmFsaXplKGRpdiwgc2VsZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyc8ZGl2IGNsYXNzPVwidGVybWluYWwtcmVuZGVyLWl0ZW1cIi8+Jywgc2V0dGluZ3NdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBoZWxwZXIgZnVuY3Rpb24gdGhhdCByZW5kZXJzIERPTSBub2RlcyBhbmQgalF1ZXJ5IG9iamVjdHNcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIHJlbmRlcih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHJldCA9IHByZXBhcmVfcmVuZGVyKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVjaG8uYXBwbHkoc2VsZiwgcmV0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gZ2V0X25vZGUoaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQuZmluZCgnW2RhdGEtaW5kZXg9JyArIGluZGV4ICsgJ10nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogdGVzdCBpZiBvYmplY3QgY2FuIGJlIHJlbmRlcmVkXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBpc19ub2RlKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICQuZm4uaW5pdCB8fCBvYmplY3QgaW5zdGFuY2VvZiBFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBEaXNwbGF5IG9iamVjdCBvbiB0ZXJtaW5hbFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gZGlzcGxheV9vYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBvYmplY3QgPSBwcmVwcm9jZXNzX3ZhbHVlKG9iamVjdCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZW5kZXIob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHNlbGYuZWNobyhvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc19hcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lY2hvKCQubWFwKG9iamVjdCwgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmplY3QpO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lY2hvKEpTT04uc3RyaW5naWZ5KG9iamVjdCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVjaG8ob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogRGlzcGxheSBsaW5lIGNvZGUgaW4gdGhlIGZpbGUgaWYgbGluZSBudW1iZXJzIGFyZSBwcmVzZW50XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBwcmludF9saW5lKHVybF9zcGVjLCBjb2xzKSB7XG4gICAgICAgICAgICB2YXIgcmUgPSAvKC4qKTooWzAtOV0rKTooWzAtOV0rKSQvO1xuICAgICAgICAgICAgLy8gZ29vZ2xlIGNocm9tZSBoYXZlIGxpbmUgYW5kIGNvbHVtbiBhZnRlciBmaWxlbmFtZVxuICAgICAgICAgICAgdmFyIG0gPSB1cmxfc3BlYy5tYXRjaChyZSk7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdG8gY2FsbCBwYXVzZS9yZXN1bWUgb3IgcmV0dXJuIHByb21pc2U/XG4gICAgICAgICAgICAgICAgc2VsZi5wYXVzZShzZXR0aW5ncy5zb2Z0UGF1c2UpO1xuICAgICAgICAgICAgICAgICQuZ2V0KG1bMV0sIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlID0gbVsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGUgPSByZXNwb25zZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gK21bMl0gLSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBuID4gMiA/IG4gLSAyIDogMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gY29kZS5zbGljZShzdGFydCwgbiArIDMpLm1hcChmdW5jdGlvbihsaW5lLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gJ1snICsgKG4gKyBpIC0gMSkgKyAnXTogJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW1pdCA9IGNvbHMgLSBwcmVmaXgubGVuZ3RoIC0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKDAsIGxpbWl0KSArICcuLi4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gPiAyID8gaSA9PT0gMiA6IGkgPT09IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gJ1tbOyNmMDA7XScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLnRlcm1pbmFsLmVzY2FwZV9icmFja2V0cyhsaW5lKSArICddJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBsaW5lO1xuICAgICAgICAgICAgICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWNobygnW1tiO3doaXRlO10nICsgZmlsZSArICddJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVjaG8obGluZXMpLnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgJ3RleHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogSGVscGVyIGZ1bmN0aW9uXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBkaXNwbGF5X2pzb25fcnBjX2Vycm9yKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oc2V0dGluZ3Mub25SUENFcnJvcikpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblJQQ0Vycm9yLmNhbGwoc2VsZiwgZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVycm9yKCcmIzkxO1JQQyYjOTM7ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuZXJyb3IgJiYgZXJyb3IuZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycm9yLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3JlIGRldGFpbGVkIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdcXHQnICsgZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyArPSAnIGluIGZpbGUgXCInICsgZXJyb3IuZmlsZS5yZXBsYWNlKC8uKlxcLy8sICcnKSArICdcIic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgKz0gJyBhdCBsaW5lICcgKyBlcnJvci5hdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBDcmVhdGUgaW50ZXJwcmV0ZXIgZnVuY3Rpb24gZnJvbSB1cmwgc3RyaW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBtYWtlX2Jhc2ljX2pzb25fcnBjKHVybCwgYXV0aCkge1xuICAgICAgICAgICAgdmFyIGludGVycHJldGVyID0gZnVuY3Rpb24obWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnBhdXNlKHNldHRpbmdzLnNvZnRQYXVzZSk7XG4gICAgICAgICAgICAgICAgJC5qcnBjKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogZnVuY3Rpb24oanhociwgcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yZXF1ZXN0LmNhbGwoc2VsZiwganhociwgcmVxdWVzdCwgc2VsZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9leGNlcHRpb24oZSwgJ1VTRVInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGZ1bmN0aW9uKGp4aHIsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJlc3BvbnNlLmNhbGwoc2VsZiwganhociwgcmVzcG9uc2UsIHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfZXhjZXB0aW9uKGUsICdVU0VSJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoanNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X2pzb25fcnBjX2Vycm9yKGpzb24uZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc19mdW5jdGlvbihzZXR0aW5ncy5wcm9jZXNzUlBDUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucHJvY2Vzc1JQQ1Jlc3BvbnNlLmNhbGwoc2VsZiwganNvbi5yZXN1bHQsIHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X29iamVjdChqc29uLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYWpheF9lcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGludGVycHJldGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29tbWFuZCwgdGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kID0gZ2V0X3Byb2Nlc3NlZF9jb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIGNhbiBiZSB0aHJvd24gb24gaW52YWxpZCByZWdleFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X2V4Y2VwdGlvbihlLCAnVEVSTUlOQUwgKGdldF9wcm9jZXNzZWRfY29tbWFuZCknKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyBlOyAvLyB0aGlzIHdpbGwgc2hvdyBzdGFjayBpbiBvdGhlciB0cnkuLmNhdGNoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYXV0aCB8fCBjb21tYW5kLm5hbWUgPT09ICdoZWxwJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvd3MgdG8gY2FsbCBoZWxwIHdpdGhvdXQgYSB0b2tlblxuICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRlcihjb21tYW5kLm5hbWUsIGNvbW1hbmQuYXJncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdGVybWluYWwudG9rZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRlcihjb21tYW5kLm5hbWUsIFt0b2tlbl0uY29uY2F0KGNvbW1hbmQuYXJncykpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWwuZXJyb3IoJyYjOTE7QVVUSCYjOTM7ICcgKyBzdHJpbmdzKCkubm9Ub2tlbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IENyZWF0ZSBpbnRlcnByZXRlciBmdW5jdGlvbiBmcm9tIE9iamVjdC4gSWYgdGhlIHZhbHVlIGlzIG9iamVjdFxuICAgICAgICAvLyA6OiBpdCB3aWxsIGNyZWF0ZSBuZXN0ZWQgaW50ZXJwcmV0ZXJzXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBtYWtlX29iamVjdF9pbnRlcnByZXRlcihvYmplY3QsIGFyaXR5LCBsb2dpbiwgZmFsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uIHRoYXQgbWFwcyBjb21tYW5kcyB0byBvYmplY3QgbWV0aG9kc1xuICAgICAgICAgICAgLy8gaXQga2VlcHMgdGVybWluYWwgY29udGV4dFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHVzZXJfY29tbWFuZCwgdGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlcl9jb21tYW5kID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbW1hbmQgPSBzcGxpdF9jb21tYW5kX2xpbmUoY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZCA9IGdldF9wcm9jZXNzZWRfY29tbWFuZCh1c2VyX2NvbW1hbmQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIGNhbiBiZSB0aHJvd24gb24gaW52YWxpZCByZWdleFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oc2V0dGluZ3MuZXhjZXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZXhjZXB0aW9uKGUsIHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvcignRXJyb3I6ICcgKyAoZS5tZXNzYWdlIHx8IGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIC8vIHRocm93IGU7IC8vIHRoaXMgd2lsbCBzaG93IHN0YWNrIGluIG90aGVyIHRyeS4uY2F0Y2hcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IG9iamVjdFtjb21tYW5kLm5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZ2V0X3R5cGUodmFsKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJpdHkgJiYgdmFsLmxlbmd0aCAhPT0gY29tbWFuZC5hcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJiM5MTtBcml0eSYjOTM7ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpbnRmKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5ncygpLndyb25nQXJpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5hcmdzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5hcHBseShzZWxmLCBjb21tYW5kLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWFuZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kcyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBtYWtlX29iamVjdF9pbnRlcnByZXRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9naW5cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGVybWluYWwucHVzaCh2YWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21wdDogY29tbWFuZC5uYW1lICsgJz4gJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGNvbW1hbmQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb246IHR5cGUgPT09ICdvYmplY3QnID8gY29tbWFuZHMgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc19mdW5jdGlvbihmYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2sodXNlcl9jb21tYW5kLCBzZWxmKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzX2Z1bmN0aW9uKHNldHRpbmdzLm9uQ29tbWFuZE5vdEZvdW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbkNvbW1hbmROb3RGb3VuZC5jYWxsKHNlbGYsIHVzZXJfY29tbWFuZCwgc2VsZik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGVybWluYWwuZXJyb3Ioc3ByaW50ZihzdHJpbmdzKCkuY29tbWFuZE5vdEZvdW5kLCBjb21tYW5kLm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBhamF4X2Vycm9yKHhociwgc3RhdHVzLCBlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5yZXN1bWUoKTsgLy8gb25BamF4RXJyb3IgY2FuIHVzZSBwYXVzZS9yZXN1bWUgY2FsbCBpdCBmaXJzdFxuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKHNldHRpbmdzLm9uQWpheEVycm9yKSkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uQWpheEVycm9yLmNhbGwoc2VsZiwgeGhyLCBzdGF0dXMsIGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzICE9PSAnYWJvcnQnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvcignJiM5MTtBSkFYJiM5MzsgJyArIHN0YXR1cyArICcgLSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ3MoKS5zZXJ2ZXJSZXNwb25zZSArICc6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAkLnRlcm1pbmFsLmVzY2FwZV9icmFja2V0cyh4aHIucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IGZ1bmN0aW9uIGNyZWF0ZSBpbnRlcnByZXRlciBvYmplY3QgYmFzZWQgb24gSlNPTi1SUEMgbWV0YSBkYXRhXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBtYWtlX2pzb25fcnBjX29iamVjdCh1cmwsIGF1dGgsIHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGpycGNfc3VjY2Vzcyhqc29uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGpzb24uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9qc29uX3JwY19lcnJvcihqc29uLmVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzX2Z1bmN0aW9uKHNldHRpbmdzLnByb2Nlc3NSUENSZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucHJvY2Vzc1JQQ1Jlc3BvbnNlLmNhbGwoc2VsZiwganNvbi5yZXN1bHQsIHNlbGYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfb2JqZWN0KGpzb24ucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGpycGNfcmVxdWVzdChqeGhyLCByZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmVxdWVzdC5jYWxsKHNlbGYsIGp4aHIsIHJlcXVlc3QsIHNlbGYpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9leGNlcHRpb24oZSwgJ1VTRVInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBqcnBjX3Jlc3BvbnNlKGp4aHIsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmVzcG9uc2UuY2FsbChzZWxmLCBqeGhyLCByZXNwb25zZSwgc2VsZik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X2V4Y2VwdGlvbihlLCAnVVNFUicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb2NzID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgLy8gd2UgY2hlY2sgaWYgaXQncyBmYWxzZSBiZWZvcmUgd2UgY2FsbCB0aGlzIGZ1bmN0aW9uIGJ1dFxuICAgICAgICAgICAgICAgIC8vIGl0IGRvbid0IGh1cnQgdG8gYmUgZXhwbGljaXQgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZXNjcmliZSAhPT0gZmFsc2UgJiYgc2V0dGluZ3MuZGVzY3JpYmUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlc2NyaWJlLnNwbGl0KCcuJykuZm9yRWFjaChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY3MgPSBwcm9jc1tmaWVsZF07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvY3MgJiYgcHJvY3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnByZXRlcl9vYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHByb2NzLCBmdW5jdGlvbihfLCBwcm9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KHByb2MpICYmIHR5cGVvZiBwcm9jLm5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJfb2JqZWN0W3Byb2MubmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwcGVuZCA9IGF1dGggJiYgcHJvYy5uYW1lICE9PSAnaGVscCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3NfbGVuID0gYXJncy5sZW5ndGggKyAoYXBwZW5kID8gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuY2hlY2tBcml0eSAmJiBwcm9jLnBhcmFtcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvYy5wYXJhbXMubGVuZ3RoICE9PSBhcmdzX2xlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJiM5MTtBcml0eSYjOTM7ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHJpbnRmKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5ncygpLndyb25nQXJpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jLnBhcmFtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzX2xlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXVzZShzZXR0aW5ncy5zb2Z0UGF1c2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFwcGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHNlbGYudG9rZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBbdG9rZW5dLmNvbmNhdChhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVycm9yKCcmIzkxO0FVVEgmIzkzOyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdzKCkubm9Ub2tlbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmpycGMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcHJvYy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBqcnBjX3JlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGpycGNfcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczoganJwY19zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBhamF4X2Vycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9naW4gPSB0eXBlb2YgYXV0aCA9PT0gJ3N0cmluZycgPyBhdXRoIDogJ2xvZ2luJztcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJfb2JqZWN0LmhlbHAgPSBpbnRlcnByZXRlcl9vYmplY3QuaGVscCB8fCBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZXMgPSBwcm9jcy5tYXAoZnVuY3Rpb24ocHJvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvYy5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJywgJykgKyAnLCBoZWxwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVjaG8oJ0F2YWlsYWJsZSBjb21tYW5kczogJyArIG5hbWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHByb2NzLCBmdW5jdGlvbihfLCBwcm9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jLm5hbWUgPT09IGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cgKz0gJ1tbYnU7O10nICsgcHJvYy5uYW1lICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2MucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHByb2MucGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdXRoICYmIHByb2MubmFtZSAhPT0gbG9naW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cgKz0gJyAnICsgcGFyYW1zLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jLmhlbHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2cgKz0gJ1xcbicgKyBwcm9jLmhlbHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVjaG8obXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuID09PSAnaGVscCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWNobygnW1tidTs7XWhlbHBdIFttZXRob2RdXFxuZGlzcGxheSBoZWxwICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmb3IgdGhlIG1ldGhvZCBvciBsaXN0IG9mIG1ldGhvZHMgaWYgbm90JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnTWV0aG9kIGAnICsgZm4gKyBcIicgbm90IGZvdW5kIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGludGVycHJldGVyX29iamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJC5qcnBjKHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdzeXN0ZW0uZGVzY3JpYmUnLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgICAgICAgc3VjY2VzczogcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDoganJwY19yZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBqcnBjX3Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogZnVuY3Rpb24gY3JlYXRlIGludGVycGV0ZXIgZnVuY3Rpb24gYW5kIGNhbGwgZmluYWxpemUgd2l0aFxuICAgICAgICAvLyA6OiBpbnRlcnByZXRlciBhbmQgb3B0aW9uYWwgY29tcGxldGlvblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gbWFrZV9pbnRlcnByZXRlcih1c2VyX2ludHJwLCBsb2dpbiwgZmluYWxpemUpIHtcbiAgICAgICAgICAgIGZpbmFsaXplID0gZmluYWxpemUgfHwgJC5ub29wO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXRfdHlwZSh1c2VyX2ludHJwKTtcbiAgICAgICAgICAgIHZhciBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICB2YXIgcnBjX2NvdW50ID0gMDsgLy8gb25seSBvbmUgcnBjIGNhbiBiZSB1c2UgZm9yIGFycmF5XG4gICAgICAgICAgICB2YXIgZm5faW50ZXJwcmV0ZXI7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgICAgIC8vIHJlY3VyIHdpbGwgYmUgY2FsbGVkIHdoZW4gcHJldmlvdXMgYWN5bmMgY2FsbCBpcyBmaW5pc2hlZFxuICAgICAgICAgICAgICAgIChmdW5jdGlvbiByZWN1cihpbnRlcnByZXRlcnMsIHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVycHJldGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IGludGVycHJldGVyc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN0ID0gaW50ZXJwcmV0ZXJzLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXRfdHlwZShmaXJzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBhdXNlKHNldHRpbmdzLnNvZnRQYXVzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlc2NyaWJlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytycGNfY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuX2ludGVycHJldGVyID0gbWFrZV9iYXNpY19qc29uX3JwYyhmaXJzdCwgbG9naW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvcihzdHJpbmdzKCkub25lUlBDV2l0aElnbm9yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXIocmVzdCwgc3VjY2Vzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZV9qc29uX3JwY19vYmplY3QoZmlyc3QsIGxvZ2luLCBmdW5jdGlvbihuZXdfb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3X29iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKG9iamVjdCwgbmV3X29iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCsrcnBjX2NvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm5faW50ZXJwcmV0ZXIgPSBtYWtlX2Jhc2ljX2pzb25fcnBjKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9naW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVycm9yKHN0cmluZ3MoKS5vbmVSUENXaXRoSWdub3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN1cihyZXN0LCBzdWNjZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuX2ludGVycHJldGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXJyb3Ioc3RyaW5ncygpLm9uZUludGVycHJldGVyRnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuX2ludGVycHJldGVyID0gZmlyc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3VyKHJlc3QsIHN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKG9iamVjdCwgZmlyc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3VyKHJlc3QsIHN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkodXNlcl9pbnRycCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsaXplKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycHJldGVyOiBtYWtlX29iamVjdF9pbnRlcnByZXRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9naW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm5faW50ZXJwcmV0ZXIgJiYgZm5faW50ZXJwcmV0ZXIuYmluZChzZWxmKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb246IE9iamVjdC5rZXlzKG9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlc2NyaWJlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRlcjogbWFrZV9iYXNpY19qc29uX3JwYyh1c2VyX2ludHJwLCBsb2dpbilcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNBcnJheShzZXR0aW5ncy5jb21wbGV0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmNvbXBsZXRpb24gPSBzZXR0aW5ncy5jb21wbGV0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsaXplKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXVzZShzZXR0aW5ncy5zb2Z0UGF1c2UpO1xuICAgICAgICAgICAgICAgICAgICBtYWtlX2pzb25fcnBjX29iamVjdCh1c2VyX2ludHJwLCBsb2dpbiwgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmludGVycHJldGVyID0gbWFrZV9vYmplY3RfaW50ZXJwcmV0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2luXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29tcGxldGlvbiA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIHByb2NzIGluIHN5c3RlbS5kZXNjcmliZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5pbnRlcnByZXRlciA9IG1ha2VfYmFzaWNfanNvbl9ycGModXNlcl9pbnRycCwgbG9naW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxpemUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZSh7XG4gICAgICAgICAgICAgICAgICAgIGludGVycHJldGVyOiBtYWtlX29iamVjdF9pbnRlcnByZXRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJfaW50cnAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5jaGVja0FyaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9naW5cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvbjogT2JqZWN0LmtleXModXNlcl9pbnRycClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgJCgnPGRpdi8+JykudGVybWluYWwoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlcl9pbnRycCA9ICQubm9vcDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IHR5cGUgKyAnIGlzIGludmFsaWQgaW50ZXJwcmV0ZXIgdmFsdWUnO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgJC50ZXJtaW5hbC5FeGNlcHRpb24obXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc2luZ2xlIGZ1bmN0aW9uIGRvbid0IG5lZWQgYmluZFxuICAgICAgICAgICAgICAgIGZpbmFsaXplKHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXI6IHVzZXJfaW50cnAsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb246IHNldHRpbmdzLmNvbXBsZXRpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogQ3JlYXRlIEpTT04tUlBDIGF1dGhlbnRpY2F0aW9uIGZ1bmN0aW9uXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBtYWtlX2pzb25fcnBjX2xvZ2luKHVybCwgbG9naW4pIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBnZXRfdHlwZShsb2dpbikgPT09ICdib29sZWFuJyA/ICdsb2dpbicgOiBsb2dpbjtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih1c2VyLCBwYXNzd2QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5wYXVzZShzZXR0aW5ncy5zb2Z0UGF1c2UpO1xuICAgICAgICAgICAgICAgICQuanJwYyh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbdXNlciwgcGFzc3dkXSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogZnVuY3Rpb24oanhociwgcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yZXF1ZXN0LmNhbGwoc2VsZiwganhociwgcmVxdWVzdCwgc2VsZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9leGNlcHRpb24oZSwgJ1VTRVInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGZ1bmN0aW9uKGp4aHIsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJlc3BvbnNlLmNhbGwoc2VsZiwganhociwgcmVzcG9uc2UsIHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfZXhjZXB0aW9uKGUsICdVU0VSJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2UuZXJyb3IgJiYgcmVzcG9uc2UucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVsbCB3aWxsIHRyaWdnZXIgbWVzc2FnZSB0aGF0IGxvZ2luIGZhaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBhamF4X2Vycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZGVmYXVsdCBuYW1lIGlzIGxvZ2luIHNvIHlvdSBjYW4gcGFzcyB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IGRpc3BsYXkgRXhjZXB0aW9uIG9uIHRlcm1pbmFsXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBkaXNwbGF5X2V4Y2VwdGlvbihlLCBsYWJlbCwgc2lsZW50KSB7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oc2V0dGluZ3MuZXhjZXB0aW9uSGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5leGNlcHRpb25IYW5kbGVyLmNhbGwoc2VsZiwgZSwgbGFiZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmV4Y2VwdGlvbihlLCBsYWJlbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogRHJhdyBsaW5lIC0gY2FuIGhhdmUgbGluZSBicmVha3MgYW5kIGJlIGxvbmdlciB0aGFuIHRoZSB3aWR0aCBvZlxuICAgICAgICAvLyA6OiB0aGUgdGVybWluYWwsIHRoZXJlIGFyZSAyIG9wdGlvbnMgcmF3IGFuZCBmaW5hbGl6ZVxuICAgICAgICAvLyA6OiByYXcgLSB3aWxsIG5vdCBlbmNvZGUgdGhlIHN0cmluZyBhbmQgZmluYWxpemUgaWYgYSBmdW5jdGlvbiB0aGF0XG4gICAgICAgIC8vIDo6IHdpbGwgaGF2ZSBkaXYgY29udGFpbmVyIG9mIHRoZSBsaW5lIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAgICAgIC8vIDo6IE5PVEU6IGl0IGZvcm1hdHMgYW5kIGFwcGVuZHMgbGluZXMgdG8gb3V0cHV0X2J1ZmZlci4gVGhlIGFjdHVhbFxuICAgICAgICAvLyA6OiBhcHBlbmQgdG8gdGVybWluYWwgb3V0cHV0IGhhcHBlbnMgaW4gdGhlIGZsdXNoIGZ1bmN0aW9uXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB2YXIgb3V0cHV0X2J1ZmZlciA9IFtdO1xuICAgICAgICB2YXIgTkVXX0xJTkUgPSAxO1xuICAgICAgICB2YXIgZm9ybWF0X2NhY2hlO1xuICAgICAgICBpZiAoJ01hcCcgaW4gcm9vdCkge1xuICAgICAgICAgICAgZm9ybWF0X2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1ZmZlcl9saW5lKGFyZywgaW5kZXgsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIHVybHMgc2hvdWxkIGFsd2F5cyBoYXZlIGZvcm1hdHRpbmcgdG8ga2VlcCB1cmwgaWYgc3BsaXRcbiAgICAgICAgICAgIHZhciBpLCBsZW47XG4gICAgICAgICAgICBvdXRwdXRfYnVmZmVyLnB1c2goTkVXX0xJTkUpO1xuICAgICAgICAgICAgdmFyIGZvcm1hdF9vcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGxpbmtzTm9SZWZlcnJlcjogc2V0dGluZ3MubGlua3NOb1JlZmVycmVyLFxuICAgICAgICAgICAgICAgIGxpbmtzTm9Gb2xsb3c6IHNldHRpbmdzLmxpbmtzTm9Gb2xsb3csXG4gICAgICAgICAgICAgICAgYW55TGlua3M6IHNldHRpbmdzLmFueUxpbmtzLFxuICAgICAgICAgICAgICAgIGNoYXJfd2lkdGg6IGNoYXJfc2l6ZS53aWR0aCxcbiAgICAgICAgICAgICAgICBlc2NhcGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBvcHRpb25zLmFsbG93ZWRBdHRyaWJ1dGVzIHx8IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHVzZV9jYWNoZSA9IHNldHRpbmdzLnVzZUNhY2hlICYmIGZvcm1hdF9jYWNoZTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdF9idWZmKGFyZywgbmV3bGluZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gSlNPTi5zdHJpbmdpZnkoW2FyZywgZm9ybWF0X29wdGlvbnNdKTtcbiAgICAgICAgICAgICAgICBpZiAodXNlX2NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXRfY2FjaGUuaGFzKGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0X2NhY2hlLmdldChhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogJC50ZXJtaW5hbC5mb3JtYXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRfb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBuZXdsaW5lOiBuZXdsaW5lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodXNlX2NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdF9jYWNoZS5zZXQoYXJncywgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gYXJnLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdbaV0gPT09ICcnIHx8IGFyZ1tpXSA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dF9idWZmZXIucHVzaCh7bGluZTogJzxzcGFuPjwvc3Bhbj4nfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRfYnVmZmVyLnB1c2goZm9ybWF0X2J1ZmYoYXJnW2ldLCBpID09PSBsZW4gLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvcHRpb25zLnJhdykge1xuICAgICAgICAgICAgICAgIG91dHB1dF9idWZmZXIucHVzaChmb3JtYXRfYnVmZihhcmcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0X2J1ZmZlci5wdXNoKHtsaW5lOiBhcmd9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dF9idWZmZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgZmluYWxpemU6IG9wdGlvbnMuZmluYWxpemUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gbGlua3Moc3RyaW5nKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXQoXywgc3R5bGUsIGNvbG9yLCBiYWNrZ3JvdW5kLCBfY2xhc3MsIGRhdGEsIHRleHQpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXR0aW5nKHMsIHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbWycgKyBbXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSArIChzIHx8ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgfHwgdGV4dFxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJzsnKSArICddJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZXNjYXBlZChfKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnXScgKyBmb3JtYXR0aW5nKCchJywgXykgKyBfICsgJ10nICsgZm9ybWF0dGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlLm1hdGNoKC8hLykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQubWF0Y2goZW1haWxfZnVsbF9yZSkgfHwgdGV4dC5tYXRjaCh1cmxfZnVsbF9yZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0aW5nKCchJywgdGV4dCkgKyB0ZXh0ICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRleHQubWF0Y2goZW1haWxfcmUpIHx8IHRleHQubWF0Y2godXJsX25mX3JlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRleHQucmVwbGFjZShlbWFpbF9yZSwgZXNjYXBlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSh1cmxfbmZfcmUsIGVzY2FwZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRpbmcoJycsIGRhdGEpICsgb3V0cHV0ICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoc3RyaW5nLm1hdGNoKGVtYWlsX3JlKSB8fCBzdHJpbmcubWF0Y2godXJsX25mX3JlKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEkLnRlcm1pbmFsLmhhdmVfZm9ybWF0dGluZyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGVtYWlsX3JlLCAnW1shOztdJDFdJykuXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2UodXJsX25mX3JlLCAnW1shOztdJDFdJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJC50ZXJtaW5hbC5mb3JtYXRfc3BsaXQoc3RyaW5nKS5tYXAoZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCQudGVybWluYWwuaXNfZm9ybWF0dGluZyhzdHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZShmb3JtYXRfcGFydHNfcmUsIGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKGVtYWlsX3JlLCAnW1shOztdJDFdJykuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlKHVybF9uZl9yZSwgJ1tbITs7XSQxXScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBzaG91bGRfd3JhcChzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiAoc3RybGVuKHRleHQoc3RyaW5nKSkgPiBvcHRpb25zLmNvbHMgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLm1hdGNoKC9cXG4vKSkgJiZcbiAgICAgICAgICAgICAgICAoKHNldHRpbmdzLndyYXAgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMud3JhcCA9PT0gdW5kZWZpbmVkKSB8fFxuICAgICAgICAgICAgICAgICBzZXR0aW5ncy53cmFwID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICBvcHRpb25zLndyYXAgPT09IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB2YXIgc3RyaW5nX2NhY2hlO1xuICAgICAgICBpZiAoJ01hcCcgaW4gcm9vdCkge1xuICAgICAgICAgICAgc3RyaW5nX2NhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NfbGluZShsaW5lKSB7XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGV4Y2VwdGlvbiBpbiBkaXNwbGF5IGV4Y2VwdGlvblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZV9zZXR0aW5ncyA9ICQuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgZXhlYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmF3OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemU6ICQubm9vcCxcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlTWV0aG9kczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcnM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRMaW5rczogc2V0dGluZ3MuY29udmVydExpbmtzXG4gICAgICAgICAgICAgICAgfSwgbGluZS5vcHRpb25zIHx8IHt9KTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nO1xuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZ2lmeV92YWx1ZShsaW5lLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmVfc2V0dGluZ3MucmF3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZV9zZXR0aW5ncy5mb3JtYXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gJC50ZXJtaW5hbC5hcHBseV9mb3JtYXR0ZXJzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfZXhjZXB0aW9uKGUsICdGT1JNQVRUSU5HJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnVzZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nX2NhY2hlICYmIHN0cmluZ19jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmdfY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcl9saW5lKHN0cmluZywgbGluZS5pbmRleCwgbGluZV9zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZV9zZXR0aW5ncy5leGVjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KGZvcm1hdF9leGVjX3JlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSAkLm1hcChwYXJ0cywgZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgJiYgc3RyaW5nLm1hdGNoKGZvcm1hdF9leGVjX3JlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgISQudGVybWluYWwuaXNfZm9ybWF0dGluZyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWRyYXcgc2hvdWxkIG5vdCBleGVjdXRlIGNvbW1hbmRzIGFuZCBpdCBoYXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbGluZXMgdmFyaWFibGUgaGF2ZSBhbGwgZXh0ZW5kZWQgY29tbWFuZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eXFxbXFxbfFxcXVxcXSQvZywgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVfc2V0dGluZ3MuZXhlYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmltID0gc3RyaW5nLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldl9leGVjX2NtZCAmJiBwcmV2X2V4ZWNfY21kID09PSB0cmltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZfZXhlY19jbWQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvcihzdHJpbmdzKCkucmVjdXJzaXZlQ2FsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldl9leGVjX2NtZCA9IHRyaW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQudGVybWluYWwuZXh0ZW5kZWRfY29tbWFuZChzZWxmLCBzdHJpbmcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZU1ldGhvZHM6IGxpbmVfc2V0dGluZ3MuaW52b2tlTWV0aG9kc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lX3NldHRpbmdzLmNvbnZlcnRMaW5rcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IGxpbmtzKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBjcmxmKCQudGVybWluYWwubm9ybWFsaXplKHN0cmluZykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gJC50ZXJtaW5hbC5lbmNvZGUoc3RyaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFiczogc2V0dGluZ3MudGFic1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3N0cmluZyA9ICQudGVybWluYWwubm9ybWFsaXplKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29scyA9IGxpbmVfc2V0dGluZ3MuY29scyA9IHNlbGYuY29scygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZF93cmFwKHN0cmluZywgbGluZV9zZXR0aW5ncykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd29yZHMgPSBsaW5lX3NldHRpbmdzLmtlZXBXb3JkcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheSA9ICQudGVybWluYWwuc3BsaXRfZXF1YWwoc3RyaW5nLCBjb2xzLCB3b3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmluZy5tYXRjaCgvXFxuLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheSA9IHN0cmluZy5zcGxpdCgvXFxuLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGFyZyA9IGFycmF5IHx8IHN0cmluZztcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nX2NhY2hlICYmIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdfY2FjaGUuc2V0KGtleSwgYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyX2xpbmUoYXJnLCBsaW5lLmluZGV4LCBsaW5lX3NldHRpbmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRfYnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgZGlzcGxheSBleGNlcHRpb24gaWYgZXhjZXB0aW9uIHRocm93IGluIHRlcm1pbmFsXG4gICAgICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKHNldHRpbmdzLmV4Y2VwdGlvbkhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmV4Y2VwdGlvbkhhbmRsZXIuY2FsbChzZWxmLCBlLCAnVEVSTUlOQUwnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbGVydF9leGNlcHRpb24oJ1tJbnRlcm5hbCBFeGNlcHRpb24ocHJvY2Vzc19saW5lKV0nLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IFVwZGF0ZSB0ZXJtaW5hbCBsaW5lc1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gcmVkcmF3KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwge1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSB1c2VkIHdoZW4gc2luZ2xlIGxpbmUgaXMgdXBkYXRlZFxuICAgICAgICAgICAgICAgIHVwZGF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHVzZWQgaWYgeW91IHdhbnQgdG8gc2Nyb2xsIHRvIGJvdHRvbSBhZnRlciByZWRyYXdcbiAgICAgICAgICAgICAgICBzY3JvbGw6IHRydWVcbiAgICAgICAgICAgIH0sIG9wdGlvbnMgfHwge30pO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbW1hbmRfbGluZS5yZXNpemUobnVtX2NoYXJzKTtcbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHJlZmxvdyB3aGlsZSBwcm9jZXNzaW5nIGxpbmVzXG4gICAgICAgICAgICAgICAgdmFyIGRldGFjaGVkX291dHB1dCA9IG91dHB1dC5lbXB0eSgpLmRldGFjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpbmVzX3RvX3Nob3cgPSBbXTtcbiAgICAgICAgICAgIC8vIERlYWQgY29kZVxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm91dHB1dExpbWl0ID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBmbHVzaCB3aWxsIGxpbWl0IGxpbmVzIGJ1dCBpZiB0aGVyZSBpcyBsb3Qgb2ZcbiAgICAgICAgICAgICAgICAvLyBsaW5lcyB3ZSBkb24ndCBuZWVkIHRvIHNob3cgdGhlbSBhbmQgdGhlbiByZW1vdmVcbiAgICAgICAgICAgICAgICAvLyB0aGVtIGZyb20gdGVybWluYWxcbiAgICAgICAgICAgICAgICB2YXIgbGltaXQ7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm91dHB1dExpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0ID0gc2VsZi5yb3dzKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGltaXQgPSBzZXR0aW5ncy5vdXRwdXRMaW1pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbihsaW5lLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBsaW5lWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGxpbmVbMV07XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzX3RvX3Nob3cucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBwaXZvdCA9IGxpbmVzX3RvX3Nob3cubGVuZ3RoIC0gbGltaXQgLSAxO1xuICAgICAgICAgICAgICAgIGxpbmVzX3RvX3Nob3cgPSBsaW5lc190b19zaG93LnNsaWNlKHBpdm90KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZXNfdG9fc2hvdyA9IGxpbmVzLm1hcChmdW5jdGlvbihsaW5lLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxpbmVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBsaW5lWzFdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG91dHB1dF9idWZmZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAkLmVhY2gobGluZXNfdG9fc2hvdywgZnVuY3Rpb24oaSwgbGluZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzX2xpbmUobGluZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUuYmVmb3JlKGRldGFjaGVkX291dHB1dCk7IC8vIHJlaW5zZXJ0IG91dHB1dFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmZsdXNoKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGZpcmVfZXZlbnQoJ29uQWZ0ZXJSZWRyYXcnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oc2V0dGluZ3MuZXhjZXB0aW9uSGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZXhjZXB0aW9uSGFuZGxlci5jYWxsKHNlbGYsIGUsICdURVJNSU5BTCAocmVkcmF3KScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0X2V4Y2VwdGlvbignW3JlZHJhd10nLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IEZ1bmN0aW9uIGxpbWl0IG91dHB1dCBsaW5lcyBiYXNlZCBvbiBvdXRwdXRMaW1pdCBvcHRpb25cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIGxpbWl0X2xpbmVzKCkge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm91dHB1dExpbWl0ID49IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGltaXQ7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm91dHB1dExpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0ID0gc2VsZi5yb3dzKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGltaXQgPSBzZXR0aW5ncy5vdXRwdXRMaW1pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyICRsaW5lcyA9IG91dHB1dC5maW5kKCc+IGRpdiA+IGRpdicpO1xuICAgICAgICAgICAgICAgIGlmICgkbGluZXMubGVuZ3RoICsgMSA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSAkbGluZXMubGVuZ3RoIC0gbGltaXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9yX3JlbW92ZSA9ICRsaW5lcy5zbGljZSgwLCBtYXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyB5b3UgY2FuJ3QgZ2V0IHBhcmVudCBpZiB5b3UgcmVtb3ZlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHNvIHdlIGZpcnN0IGdldCB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRzID0gZm9yX3JlbW92ZS5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yX3JlbW92ZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50cy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRzZWxmID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2VsZi5pcygnOmVtcHR5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1vdW50KCRzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBjYW4gYmUgZGl2cyBpbnNpZGUgcGFyZW50IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXMgbm90IHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2VsZi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBEaXNwbGF5IHVzZXIgZ3JlZXRpbmdzIG9yIHRlcm1pbmFsIHNpZ25hdHVyZVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gc2hvd19ncmVldGluZ3MoKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZ3JlZXRpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmUgaGF2ZSBhc2NpaSBhcnQgc28gaXQncyBub3Qgc3VpdGUgZm9yIHNjcmVlbiByZWFkZXJzXG4gICAgICAgICAgICAgICAgc2VsZi5lY2hvKHNlbGYuc2lnbmF0dXJlLCB7ZmluYWxpemU6IGExMXlfaGlkZSwgZm9ybWF0dGVyczogZmFsc2V9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuZ3JlZXRpbmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygc2V0dGluZ3MuZ3JlZXRpbmdzO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVjaG8oc2V0dGluZ3MuZ3JlZXRpbmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBzZXR0aW5ncy5ncmVldGluZ3MuY2FsbChzZWxmLCBzZWxmLmVjaG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbWFrZV9sYWJlbF9lcnJvcignR3JlZXRpbmdzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnByb21pc2UocmV0LCBzZWxmLmVjaG8sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5ncmVldGluZ3MgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmdyZWV0aW5ncyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X2V4Y2VwdGlvbihlLCAnZ3JlZXRpbmdzJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVycm9yKHN0cmluZ3MoKS53cm9uZ0dyZWV0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBEaXNwbGF5IHByb21wdCBhbmQgbGFzdCBjb21tYW5kXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBlY2hvX2NvbW1hbmQoY29tbWFuZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21tYW5kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBzZWxmLmdldF9jb21tYW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cnVlIHdpbGwgcmV0dXJuIGxhc3QgcmVuZGVyZWQgc3RyaW5nXG4gICAgICAgICAgICB2YXIgcHJvbXB0ID0gY29tbWFuZF9saW5lLnByb21wdCh0cnVlKTtcbiAgICAgICAgICAgIHZhciBtYXNrID0gY29tbWFuZF9saW5lLm1hc2soKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIG1hc2spIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kID0gY29tbWFuZC5yZXBsYWNlKC8uL2csIG1hc2spO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBjb21tYW5kLnJlcGxhY2UoLy4vZywgc2V0dGluZ3MubWFza0NoYXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZCA9ICQudGVybWluYWwuZXNjYXBlX2Zvcm1hdHRpbmcoY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0TGlua3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGV4ZWM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiBmaW5hbGl6ZShkaXYpIHtcbiAgICAgICAgICAgICAgICAgICAgYTExeV9oaWRlKGRpdi5hZGRDbGFzcygndGVybWluYWwtY29tbWFuZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCgnb25FY2hvQ29tbWFuZCcsIFtkaXYsIGNvbW1hbmRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2VsZi5lY2hvKHByb21wdCArIGNvbW1hbmQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBoYXZlX3Njcm9sbGJhcigpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxsLm91dGVyV2lkdGgoKSAhPT0gc2VsZi5vdXRlcldpZHRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IEhlbHBlciBmdW5jdGlvbiB0aGF0IHJlc3RvcmUgc3RhdGUuIENhbGwgaW1wb3J0X3ZpZXcgb3IgZXhlY1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gcmVzdG9yZV9zdGF0ZShzcGVjKSB7XG4gICAgICAgICAgICAvLyBzcGVjIFt0ZXJtaW5hbF9pZCwgc3RhdGVfaW5kZXgsIGNvbW1hbmRdXG4gICAgICAgICAgICB2YXIgdGVybWluYWwgPSB0ZXJtaW5hbHMuZ2V0KClbc3BlY1swXV07XG4gICAgICAgICAgICBpZiAoIXRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3ICQudGVybWluYWwuRXhjZXB0aW9uKHN0cmluZ3MoKS5pbnZhbGlkVGVybWluYWxJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29tbWFuZF9pZHggPSBzcGVjWzFdO1xuICAgICAgICAgICAgaWYgKHNhdmVfc3RhdGVbY29tbWFuZF9pZHhdKSB7IC8vIHN0YXRlIGV4aXN0c1xuICAgICAgICAgICAgICAgIHRlcm1pbmFsLmltcG9ydF92aWV3KHNhdmVfc3RhdGVbY29tbWFuZF9pZHhdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBzdGF0ZVxuICAgICAgICAgICAgICAgIGNoYW5nZV9oYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBzcGVjWzJdO1xuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsLmV4ZWMoY29tbWFuZCkuZG9uZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZV9oYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVfc3RhdGVbY29tbWFuZF9pZHhdID0gdGVybWluYWwuZXhwb3J0X3ZpZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyppZiAoc3BlY1szXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN0b3JlX3N0YXRlKHNwZWNbM10pO1xuICAgICAgICAgICAgfSovXG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIG1ha2VfbGFiZWxfZXJyb3IobGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvcignWycgKyBsYWJlbCArICddICcgKyAoZS5tZXNzYWdlIHx8IGUpKS5yZXN1bWUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IEhlbHBlciBmdW5jdGlvblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVfdXBkYXRlX2hhc2goKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlX2hhc2gpIHtcbiAgICAgICAgICAgICAgICBmaXJlX2hhc2hfY2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24uaGFzaCA9ICcjJyArIEpTT04uc3RyaW5naWZ5KGhhc2hfY29tbWFuZHMpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVfaGFzaF9jaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IFdyYXBwZXIgb3ZlciBpbnRlcnByZXRlciwgaXQgaW1wbGVtZW50cyBleGl0IGFuZCBjYXRjaGVzIGFsbFxuICAgICAgICAvLyA6OiBleGVwdGlvbnMgZnJvbSB1c2VyIGNvZGUgYW5kIGRpc3BsYXlzIHRoZW0gb24gdGhlIHRlcm1pbmFsXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB2YXIgZmlyc3RfY29tbWFuZCA9IHRydWU7XG4gICAgICAgIHZhciByZXN1bWVfY2FsbGJhY2tzID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGNvbW1hbmRzKGNvbW1hbmQsIHNpbGVudCwgZXhlYykge1xuICAgICAgICAgICAgZnVuY3Rpb24gaW5pdF9zdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAvLyBleGVjSGFzaCBuZWVkIGZpcnN0IGVtcHR5IGNvbW1hbmQgdG9vXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmhpc3RvcnlTdGF0ZSB8fCBzZXR0aW5ncy5leGVjSGFzaCAmJiBleGVjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2F2ZV9zdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IGNvbW1hbmQgaW4gZmlyc3QgdGVybWluYWwgZG9uJ3QgaGF2ZSBoYXNoXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNhdmVfc3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2F2ZV9zdGF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBmdW5jdGlvbiBhZnRlcl9leGVjKCkge1xuICAgICAgICAgICAgICAgIC8vIHZhcmlhYmxlcyBkZWZpbmVkIGxhdGVyIGluIGNvbW1hbmRzXG4gICAgICAgICAgICAgICAgaWYgKCFleGVjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZV9oYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmhpc3RvcnlTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zYXZlX3N0YXRlKGNvbW1hbmQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VfaGFzaCA9IHNhdmVkX2NoYW5nZV9oYXNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgZmlyZV9ldmVudCgnb25BZnRlckNvbW1hbmQnLCBbY29tbWFuZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNob3cocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfb2JqZWN0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFmdGVyX2V4ZWMoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGludm9rZSgpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxsIHVzZXIgaW50ZXJwcmV0ZXIgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW50ZXJwcmV0ZXIuaW50ZXJwcmV0ZXIuY2FsbChzZWxmLCBjb21tYW5kLCBzZWxmKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGF1dG8gcGF1c2UvcmVzdW1lIHdoZW4gdXNlciByZXR1cm4gcHJvbWlzZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIG5vdCBwYXVzZSB3aGVuIHVzZXIgcmV0dXJuIHByb21pc2UgZnJvbSByZWFkKClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3JjZV9hd2FrZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXVzZShzZXR0aW5ncy5zb2Z0UGF1c2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlX2F3YWtlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG1ha2VfbGFiZWxfZXJyb3IoJ0NvbW1hbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBmb3IgbmF0aXZlIFByb21pc2Ugb2JqZWN0IHdvcmsgb25seSBpbiBqUXVlcnkgMy54XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihyZXN1bHQuZG9uZSB8fCByZXN1bHQudGhlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bnByb21pc2UocmVzdWx0LCBzaG93LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC53aGVuKHJlc3VsdCkuZG9uZShzaG93KS5jYXRjaChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bWVfY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleGVjIHdpdGggcmVzdW1lL3BhdXNlIGluIHVzZXIgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJfZXhlYygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZnRlcl9leGVjKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIGZpcnN0IGNvbW1hbmQgc3RvcmUgc3RhdGUgb2YgdGhlIHRlcm1pbmFsIGJlZm9yZSB0aGUgY29tbWFuZCBnZXRcbiAgICAgICAgICAgIC8vIGV4ZWN1dGVkXG4gICAgICAgICAgICBpZiAoZmlyc3RfY29tbWFuZCkge1xuICAgICAgICAgICAgICAgIGZpcnN0X2NvbW1hbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpbml0X3N0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FsbGJhY2sgY2FuIGRpc2FibGUgY29tbWFuZHNcbiAgICAgICAgICAgICAgICBpZiAoZmlyZV9ldmVudCgnb25CZWZvcmVDb21tYW5kJywgW2NvbW1hbmRdKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhlYykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2X2V4ZWNfY21kID0gY29tbWFuZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldl9jb21tYW5kID0gJC50ZXJtaW5hbC5zcGxpdF9jb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWdob3N0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhlYyBleGVjdXRlIHRoaXMgZnVuY3Rpb24gd2lob3V0IHRoZSBoZWxwIG9mIGNtZCBwbHVnaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBhZGQgY29tbWFuZCB0byBoaXN0b3J5IG9uIGVudGVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleGVjICYmIChpc19mdW5jdGlvbihzZXR0aW5ncy5oaXN0b3J5RmlsdGVyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaGlzdG9yeUZpbHRlcihjb21tYW5kKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5tYXRjaChzZXR0aW5ncy5oaXN0b3J5RmlsdGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRfbGluZS5oaXN0b3J5KCkuYXBwZW5kKGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbnRlcnByZXRlciA9IGludGVycHJldGVycy50b3AoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNpbGVudCAmJiBzZXR0aW5ncy5lY2hvQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICBlY2hvX2NvbW1hbmQoY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG5ldyBwcm9taXNlIHdpbGwgYmUgcmV0dXJuZWQgdG8gZXhlYyB0aGF0IHdpbGwgcmVzb2x2ZSBoaXNcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5lZCBwcm9taXNlXG4gICAgICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3ICQuRGVmZXJyZWQoKTtcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHNhdmUgc2F0ZSBiZWZvcmUgY29tbWFuZHMgaXMgZGVsZXlkIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBleGVjdXRlX2V4dGVuZGVkX2NvbW1hbmQgZGlzYWJsZSBpdCBhbmQgaXQgY2FuIGJlIGV4ZWN1dGVkXG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgZGVsYXlcbiAgICAgICAgICAgICAgICB2YXIgc2F2ZWRfY2hhbmdlX2hhc2ggPSBjaGFuZ2VfaGFzaDtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZC5tYXRjaCgvXlxccypsb2dpblxccyokLykgJiYgc2VsZi50b2tlbih0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5sZXZlbCgpID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dvdXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZ291dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyX2V4ZWMoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmV4aXQgJiYgY29tbWFuZC5tYXRjaCgvXlxccypleGl0XFxzKiQvKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIWluX2xvZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IHNlbGYubGV2ZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxldmVsID09PSAxICYmIHNlbGYuZ2V0X3Rva2VuKCkgfHwgbGV2ZWwgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5nZXRfdG9rZW4odHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNldF90b2tlbih1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhZnRlcl9leGVjKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5jbGVhciAmJiBjb21tYW5kLm1hdGNoKC9eXFxzKmNsZWFyXFxzKiQvKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIWluX2xvZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJfZXhlYygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBpbnZva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlfZXhjZXB0aW9uKGUsICdVU0VSJywgZXhlYyk7XG4gICAgICAgICAgICAgICAgc2VsZi5yZXN1bWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhlYykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogVGhlIGxvZ291dCBmdW5jdGlvbiByZW1vdmVzIFN0b3JhZ2UsIGRpc2FibGVzIGhpc3RvcnkgYW5kIHJ1bnNcbiAgICAgICAgLy8gOjogdGhlIGxvZ2luIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IHdoZW4gb3B0aW9ucy5sb2dpblxuICAgICAgICAvLyA6OiBmdW5jdGlvbiBpcyBkZWZpbmVkLiBUaGUgY2hlY2sgZm9yIHRoaXMgaXMgaW4gdGhlIHNlbGYucG9wIG1ldGhvZFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gZ2xvYmFsX2xvZ291dCgpIHtcbiAgICAgICAgICAgIGlmIChmaXJlX2V2ZW50KCdvbkJlZm9yZUxvZ291dCcsIFtdLCB0cnVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhcl9sb2dpbmdfc3RvcmFnZSgpO1xuICAgICAgICAgICAgZmlyZV9ldmVudCgnb25BZnRlcmxvZ291dCcsIFtdLCB0cnVlKTtcbiAgICAgICAgICAgIHNlbGYubG9naW4oZ2xvYmFsX2xvZ2luX2ZuLCB0cnVlLCBpbml0aWFsaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gY2xlYXJfbG9naW5nX3N0b3JhZ2UoKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHNlbGYucHJlZml4X25hbWUodHJ1ZSkgKyAnXyc7XG4gICAgICAgICAgICBzdG9yYWdlLnJlbW92ZShuYW1lICsgJ3Rva2VuJyk7XG4gICAgICAgICAgICBzdG9yYWdlLnJlbW92ZShuYW1lICsgJ2xvZ2luJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIDo6IFNhdmUgdGhlIGludGVycHJldGVyIG5hbWUgZm9yIHVzZSB3aXRoIHB1cmdlXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBtYXliZV9hcHBlbmRfbmFtZShpbnRlcnByZXRlcl9uYW1lKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmFnZV9rZXkgPSBzZWxmLnByZWZpeF9uYW1lKCkgKyAnX2ludGVycHJldGVycyc7XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBzdG9yYWdlLmdldChzdG9yYWdlX2tleSk7XG4gICAgICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgICAgICBuYW1lcyA9IEpTT04ucGFyc2UobmFtZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYW1lcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCQuaW5BcnJheShpbnRlcnByZXRlcl9uYW1lLCBuYW1lcykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbmFtZXMucHVzaChpbnRlcnByZXRlcl9uYW1lKTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnNldChzdG9yYWdlX2tleSwgSlNPTi5zdHJpbmdpZnkobmFtZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogRnVuY3Rpb24gZW5hYmxlcyBoaXN0b3J5LCBzZXRzIHByb21wdCwgcnVucyBpbnRlcnByZXRlciBmdW5jdGlvblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gcHJlcGFyZV90b3BfaW50ZXJwcmV0ZXIoc2lsZW50KSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJwcmV0ZXIgPSBpbnRlcnByZXRlcnMudG9wKCk7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHNlbGYucHJlZml4X25hbWUodHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIWdob3N0KCkpIHtcbiAgICAgICAgICAgICAgICBtYXliZV9hcHBlbmRfbmFtZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsb2dpbiA9IHNlbGYubG9naW5fbmFtZSh0cnVlKTtcbiAgICAgICAgICAgIGNvbW1hbmRfbGluZS5uYW1lKG5hbWUgKyAobG9naW4gPyAnXycgKyBsb2dpbiA6ICcnKSk7XG4gICAgICAgICAgICB2YXIgcHJvbXB0ID0gaW50ZXJwcmV0ZXIucHJvbXB0O1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKHByb21wdCkpIHtcbiAgICAgICAgICAgICAgICBwcm9tcHQgPSBjb250ZXh0X2NhbGxiYWNrX3Byb3h5KHByb21wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvbXB0ICE9PSBjb21tYW5kX2xpbmUucHJvbXB0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oaW50ZXJwcmV0ZXIucHJvbXB0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGZsaWNrZXIgb2Ygb2xkIHByb21wdCB1bnRpbCBhc3luYyBwcm9tcHQgZmluaXNoZXNcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZF9saW5lLnByb21wdCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbW1hbmRfbGluZS5wcm9tcHQoaW50ZXJwcmV0ZXIucHJvbXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW50ZXJwcmV0ZXIuaGlzdG9yeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmhpc3RvcnkoKS50b2dnbGUoaW50ZXJwcmV0ZXIuaGlzdG9yeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGludGVycHJldGVyLmtleW1hcCkpIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUua2V5bWFwKCQub21hcChpbnRlcnByZXRlci5rZXltYXAsIGZ1bmN0aW9uKG5hbWUsIGZ1bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X2V4Y2VwdGlvbihlLCAnVVNFUiBLRVlNQVAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21tYW5kX2xpbmUuc2V0KCcnKTtcbiAgICAgICAgICAgIGluaXRfcXVldWUucmVzb2x2ZSgpO1xuICAgICAgICAgICAgaWYgKCFzaWxlbnQgJiYgaXNfZnVuY3Rpb24oaW50ZXJwcmV0ZXIub25TdGFydCkpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnByZXRlci5vblN0YXJ0LmNhbGwoc2VsZiwgc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIGZpcmVfZXZlbnQobmFtZSwgYXJncywgc2tpcF9sb2NhbCkge1xuICAgICAgICAgICAgYXJncyA9IChhcmdzIHx8IFtdKS5jb25jYXQoW3NlbGZdKTsgLy8gY3JlYXRlIG5ldyBhcnJheVxuICAgICAgICAgICAgLy8gZXZlbiBjYW4gYmUgZmlyZWQgYmVmb3JlIGludGVycHJldGVycyBpcyBjcmVhdGVkXG4gICAgICAgICAgICB2YXIgdG9wID0gaW50ZXJwcmV0ZXJzICYmIGludGVycHJldGVycy50b3AoKTtcbiAgICAgICAgICAgIGlmICh0b3AgJiYgaXNfZnVuY3Rpb24odG9wW25hbWVdKSAmJiAhc2tpcF9sb2NhbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b3BbbmFtZV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdG9wW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X2V4Y2VwdGlvbihlLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzX2Z1bmN0aW9uKHNldHRpbmdzW25hbWVdKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5nc1tuYW1lXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzW25hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9leGNlcHRpb24oZSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JvbGxfdG9fdmlldyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNjcm9sbF90b192aWV3KHZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IGNhdGNoIGZvciBOb2RlLmpzIHVuaXQgdGVzdHNcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsX3RvKHNlbGYuZmluZCgnLmNtZC1jdXJzb3InKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IGRlYm91bmNlIGluIFVuaXQgVGVzdHNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsLml0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcm9sbF90b192aWV3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlYm91bmNlKHNjcm9sbF90b192aWV3LCAxMDAsIHtcbiAgICAgICAgICAgICAgICBsZWFkaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRyYWlsaW5nOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBtYWtlX2N1cnNvcl92aXNpYmxlKCkge1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IHNlbGYuZmluZCgnLmNtZC1jdXJzb3ItbGluZScpO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnNvci5pc19mdWxseV9pbl92aWV3cG9ydChzZWxmKS50aGVuKHNjcm9sbF90b192aWV3KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gaGFzaGNoYW5nZSgpIHtcbiAgICAgICAgICAgIGlmIChmaXJlX2hhc2hfY2hhbmdlICYmIHNldHRpbmdzLmV4ZWNIYXNoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaC5yZXBsYWNlKC9eIy8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hfY29tbWFuZHMgPSBKU09OLnBhcnNlKGRlY29kZVVSSUNvbXBvbmVudChoYXNoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoX2NvbW1hbmRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2hfY29tbWFuZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN0b3JlX3N0YXRlKGhhc2hfY29tbWFuZHNbaGFzaF9jb21tYW5kcy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2F2ZV9zdGF0ZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbXBvcnRfdmlldyhzYXZlX3N0YXRlWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9leGNlcHRpb24oZSwgJ1RFUk1JTkFMJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgICAgICAgICAgcHJlcGFyZV90b3BfaW50ZXJwcmV0ZXIoKTtcbiAgICAgICAgICAgIHNob3dfZ3JlZXRpbmdzKCk7XG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZWZyZXNoKCk7IC8vIGZvciBjYXNlIHdoZW4gc2hvd2luZyBsb25nIGVycm9yIGJlZm9yZSBpbml0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3YXNfcGF1c2VkIGZsYWcgaXMgd29ya2Fyb3VuZCBmb3IgY2FzZSB3aGVuIHVzZXIgY2FsbCBleGVjIGJlZm9yZVxuICAgICAgICAgICAgLy8gbG9naW4gYW5kIHBhdXNlIGluIG9uSW5pdCwgM3JkIGV4ZWMgd2lsbCBoYXZlIHByb3BlciB0aW1pbmcgKHdpbGxcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgYWZ0ZXIgb25Jbml0IHJlc3VtZSlcbiAgICAgICAgICAgIHZhciB3YXNfcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oc2V0dGluZ3Mub25Jbml0KSkge1xuICAgICAgICAgICAgICAgIG9uUGF1c2UgPSBmdW5jdGlvbigpIHsgLy8gbG9jYWwgaW4gdGVybWluYWxcbiAgICAgICAgICAgICAgICAgICAgd2FzX3BhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbkluaXQuY2FsbChzZWxmLCBzZWxmKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfZXhjZXB0aW9uKGUsICdPbkluaXQnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgZTsgLy8gaXQgd2lsbCBiZSBjYXRjaGVkIGJ5IHRlcm1pbmFsXG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgb25QYXVzZSA9ICQubm9vcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3YXNfcGF1c2VkICYmIHNlbGYuZW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bWUgbG9naW4gaWYgdXNlciBkaWRuJ3QgY2FsbCBwYXVzZSBpbiBvbkluaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIgcGF1c2UgaW4gb25Jbml0IHdhaXQgd2l0aCBleGVjIHVudGlsIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVzdW1lKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0X2luc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RfaW5zdGFuY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAkKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCBoYXNoY2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogSWYgR2hvc3QgZG9uJ3Qgc3RvcmUgYW55dGhpbmcgaW4gbG9jYWxzdG9yYWdlXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBnaG9zdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbl9sb2dpbiB8fCBjb21tYW5kX2xpbmUubWFzaygpICE9PSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gOjogS2V5ZG93biBldmVudCBoYW5kbGVyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiB1c2VyX2tleV9kb3duKGUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIHRvcCA9IGludGVycHJldGVycy50b3AoKTtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbih0b3Aua2V5ZG93bikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0b3Aua2V5ZG93bi5jYWxsKHNlbGYsIGUsIHNlbGYpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNfZnVuY3Rpb24oc2V0dGluZ3Mua2V5ZG93bikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXR0aW5ncy5rZXlkb3duLmNhbGwoc2VsZiwgZSwgc2VsZik7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBrZXltYXAgPSB7XG4gICAgICAgICAgICAnQ1RSTCtEJzogZnVuY3Rpb24oZSwgb3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluX2xvZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tYW5kX2xpbmUuZ2V0KCkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJwcmV0ZXJzLnNpemUoKSA+IDEgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc19mdW5jdGlvbihnbG9iYWxfbG9naW5fZm4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wb3AoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWNobygnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnQ1RSTCtDJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgd2l0aF9zZWxlY3Rpb24oZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHRtbCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21tYW5kID0gc2VsZi5nZXRfY29tbWFuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gc2VsZi5nZXRfcG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBjb21tYW5kLnNsaWNlKDAsIHBvc2l0aW9uKSArICdeQycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQuc2xpY2UocG9zaXRpb24gKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVjaG9fY29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0X2NvbW1hbmQoJycpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXAgPSBzZWxmLmZpbmQoJ3RleHRhcmVhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0X3RvX2NsaXBib2FyZChjbGlwLCBwcm9jZXNzX3NlbGVjdGVkX2h0bWwoaHRtbCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdDVFJMK0wnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNsZWFyKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ1RBQic6IGZ1bmN0aW9uKGUsIG9yaWduYWwpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgdG8gY21kIHBsdWdpblxuICAgICAgICAgICAgICAgIC8vICAgICAgIGFkZCBjb21wbGV0aW9uID0gYXJyYXkgfCBmdW5jdGlvblxuICAgICAgICAgICAgICAgIC8vICAgICAgICEhISBQcm9ibGVtIGNvbXBsZXRlIG1vcmUgdGhlbiBvbmUga2V5IG5lZWQgdGVybWluYWxcbiAgICAgICAgICAgICAgICB2YXIgdG9wID0gaW50ZXJwcmV0ZXJzLnRvcCgpLCBjb21wbGV0aW9uLCBjYXNlU2Vuc2l0aXZlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9wLmNhc2VTZW5zaXRpdmVBdXRvY29tcGxldGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2VTZW5zaXRpdmUgPSB0b3AuY2FzZVNlbnNpdGl2ZUF1dG9jb21wbGV0ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYXNlU2Vuc2l0aXZlID0gc2V0dGluZ3MuY2FzZVNlbnNpdGl2ZUF1dG9jb21wbGV0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNvbXBsZXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgZ2V0X3R5cGUoc2V0dGluZ3MuY29tcGxldGlvbikgIT09ICdib29sZWFuJyAmJlxuICAgICAgICAgICAgICAgICAgICB0b3AuY29tcGxldGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb24gPSBzZXR0aW5ncy5jb21wbGV0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb24gPSB0b3AuY29tcGxldGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRpb24gPT09ICdzZXR0aW5ncycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvbiA9IHNldHRpbmdzLmNvbXBsZXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmUoY29tbWFuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9jYWwgY29weVxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kcyA9IGNvbW1hbmRzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgY29tbWFuZHMgc2hvdWxkIG5vdCBtYXRjaCBmb3IgYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5iZWZvcmVfY3Vyc29yKGZhbHNlKS5tYXRjaCgvXFxzLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5jbGVhciAmJiAkLmluQXJyYXkoJ2NsZWFyJywgY29tbWFuZHMpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goJ2NsZWFyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZXhpdCAmJiAkLmluQXJyYXkoJ2V4aXQnLCBjb21tYW5kcykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZHMucHVzaCgnZXhpdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcGxldGUoY29tbWFuZHMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVjaG86IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JkOiBzZXR0aW5ncy53b3JkQXV0b2NvbXBsZXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlOiBzZXR0aW5ncy5jb21wbGV0aW9uRXNjYXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZTogY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVjaG9Db21tYW5kOiBzZXR0aW5ncy5kb3VibGVUYWJFY2hvQ29tbWFuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdWJsZVRhYjogc2V0dGluZ3MuZG91YmxlVGFiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGdldF90eXBlKGNvbXBsZXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IHNlbGYuYmVmb3JlX2N1cnNvcihzZXR0aW5ncy53b3JkQXV0b2NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGlvbi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHN0cmluZ3MoKS5jb21sZXRpb25QYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9leGNlcHRpb24oZXJyb3IsICdVU0VSJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBsZXRpb24uY2FsbChzZWxmLCBzdHJpbmcsIHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVucHJvbWlzZShyZXN1bHQsIHJlc29sdmUsIG1ha2VfbGFiZWxfZXJyb3IoJ0NvbXBsZXRpb24nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShjb21wbGV0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3ICQudGVybWluYWwuRXhjZXB0aW9uKHN0cmluZ3MoKS5pbnZhbGlkQ29tcGxldGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcmlnbmFsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnQ1RSTCtWJzogZnVuY3Rpb24oZSwgb3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbChlKTtcbiAgICAgICAgICAgICAgICBzZWxmLm9uZVRpbWUoMjAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxfdG9fYm90dG9tKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ0NUUkwrVEFCJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlcm1pbmFscy5sZW5ndGgoKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mb2N1cyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ1BBR0VET1dOJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGwoc2VsZi5oZWlnaHQoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ1BBR0VVUCc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsKC1zZWxmLmhlaWdodCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIGtleV9kb3duKGUpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgdG8gYmUgZXhlY3V0ZWQgYnkgY21kOiBDVFJMK0QsIFRBQiwgQ1RSTCtUQUIgKGlmIG1vcmVcbiAgICAgICAgICAgIC8vIHRoZW4gb25lIHRlcm1pbmFsKVxuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaTtcbiAgICAgICAgICAgIGlmIChzZWxmLmVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5wYXVzZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB1c2VyX2tleV9kb3duKGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggIT09IDkpIHsgLy8gbm90IGEgVEFCXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJfY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5wYXVzZUV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdXNlcl9rZXlfZG93bihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDY4ICYmIGUuY3RybEtleSkgeyAvLyBDVFJMK0QgKGlmIHBhdXNlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5wYXVzZUV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHVzZXJfa2V5X2Rvd24oZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHJlcXVlc3RzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHJlcXVlc3RzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKHNldHRpbmdzLmV4Y2VwdGlvbkhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmV4Y2VwdGlvbkhhbmRsZXIuY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0FKQVggQUJPUlQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvcihzdHJpbmdzKCkuYWpheEFib3J0RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXN1bWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBrZXlfcHJlc3MoZSkge1xuICAgICAgICAgICAgdmFyIHRvcCA9IGludGVycHJldGVycy50b3AoKTtcbiAgICAgICAgICAgIGlmIChlbmFibGVkICYmICghcGF1c2VkIHx8ICFzZXR0aW5ncy5wYXVzZUV2ZW50cykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24odG9wLmtleXByZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9wLmtleXByZXNzLmNhbGwoc2VsZiwgZSwgc2VsZik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc19mdW5jdGlvbihzZXR0aW5ncy5rZXlwcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmtleXByZXNzLmNhbGwoc2VsZiwgZSwgc2VsZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiByZWFkeShxdWV1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZ1bikge1xuICAgICAgICAgICAgICAgIHF1ZXVlLmFkZChmdW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZnVuY3Rpb24gc3RyaW5ncygpIHtcbiAgICAgICAgICAgIHJldHVybiAkLmV4dGVuZChcbiAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAkLnRlcm1pbmFsLmRlZmF1bHRzLnN0cmluZ3MsXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgJiYgc2V0dGluZ3Muc3RyaW5ncyB8fCB7fVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5pcygnYm9keSxodG1sJykpIHtcbiAgICAgICAgICAgIHNlbGYgPSAkKCc8ZGl2Lz4nKS5hcHBlbmRUbygnYm9keScpO1xuICAgICAgICAgICAgJCgnYm9keScpLmFkZENsYXNzKCdmdWxsLXNjcmVlbi10ZXJtaW5hbCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJC5mbi50ZXJtaW5hbC5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBpbml0X2ludGVycHJldGVyLFxuICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZCh7bmFtZTogc2VsZi5zZWxlY3Rvcn0sIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlcm1pbmFsIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGlmIChzZWxmLmRhdGEoJ3Rlcm1pbmFsJykpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmRhdGEoJ3Rlcm1pbmFsJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy8gVEVSTUlOQUwgTUVUSE9EU1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAkLmV4dGVuZChzZWxmLCAkLm9tYXAoe1xuICAgICAgICAgICAgaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXJtaW5hbF9pZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBDbGVhciB0aGUgb3V0cHV0XG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcmVfZXZlbnQoJ29uQ2xlYXInKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbihsaW5lLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGxpbmVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24ob3B0aW9ucy5vbkNsZWFyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25DbGVhci5jYWxsKHNlbGYsIGdldF9ub2RlKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFswXS5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcm9wKHtzY3JvbGxUb3A6IDB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogUmV0dXJuIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHdpdGggaW1wb3J0X3ZpZXcgdG9cbiAgICAgICAgICAgIC8vIDo6IHJlc3RvcmUgdGhlIHN0YXRlXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBleHBvcnRfdmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVzZXJfZXhwb3J0ID0gZmlyZV9ldmVudCgnb25FeHBvcnQnKTtcbiAgICAgICAgICAgICAgICB1c2VyX2V4cG9ydCA9IHVzZXJfZXhwb3J0IHx8IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwge1xuICAgICAgICAgICAgICAgICAgICBmb2N1czogZW5hYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgbWFzazogY29tbWFuZF9saW5lLm1hc2soKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0OiBzZWxmLmdldF9wcm9tcHQoKSxcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogc2VsZi5nZXRfY29tbWFuZCgpLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogY29tbWFuZF9saW5lLnBvc2l0aW9uKCksXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzOiBjbG9uZShsaW5lcyksXG4gICAgICAgICAgICAgICAgICAgIGludGVycHJldGVyczogaW50ZXJwcmV0ZXJzLmNsb25lKCksXG4gICAgICAgICAgICAgICAgICAgIGhpc3Rvcnk6IGNvbW1hbmRfbGluZS5oaXN0b3J5KCkuZGF0YVxuICAgICAgICAgICAgICAgIH0sIHVzZXJfZXhwb3J0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBSZXN0b3JlIHRoZSBzdGF0ZSBvZiB0aGUgcHJldmlvdXMgZXhwb3J0ZWQgdmlld1xuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgaW1wb3J0X3ZpZXc6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5fbG9naW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNwcmludGYoc3RyaW5ncygpLm5vdFdoaWxlTG9naW4sICdpbXBvcnRfdmlldycpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlyZV9ldmVudCgnb25JbXBvcnQnLCBbdmlld10pO1xuICAgICAgICAgICAgICAgIHdoZW5fcmVhZHkoZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0X3Byb21wdCh2aWV3LnByb21wdCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0X2NvbW1hbmQodmlldy5jb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZF9saW5lLnBvc2l0aW9uKHZpZXcucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUubWFzayh2aWV3Lm1hc2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldy5mb2N1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzID0gY2xvbmUodmlldy5saW5lcykuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lWzBdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXcuaW50ZXJwcmV0ZXJzIGluc3RhbmNlb2YgU3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycHJldGVycyA9IHZpZXcuaW50ZXJwcmV0ZXJzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5pbXBvcnRIaXN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUuaGlzdG9yeSgpLnNldCh2aWV3Lmhpc3RvcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IFN0b3JlIGN1cnJlbnQgdGVybWluYWwgc3RhdGVcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHNhdmVfc3RhdGU6IGZ1bmN0aW9uKGNvbW1hbmQsIGlnbm9yZV9oYXNoLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIHNhdmVfc3RhdGUucHVzaCh7dmlldzpzZWxmLmV4cG9ydF92aWV3KCksIGpvaW46W119KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBzYXZlX3N0YXRlW2luZGV4XSA9IHNlbGYuZXhwb3J0X3ZpZXcoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzYXZlX3N0YXRlLnB1c2goc2VsZi5leHBvcnRfdmlldygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEkLmlzQXJyYXkoaGFzaF9jb21tYW5kcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaF9jb21tYW5kcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZCAhPT0gdW5kZWZpbmVkICYmICFpZ25vcmVfaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVfc3RhdGUubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgaGFzaF9jb21tYW5kcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVfdXBkYXRlX2hhc2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogRXhlY3V0ZSBhIGNvbW1hbmQsIGl0IHdpbGwgaGFuZGxlIGNvbW1hbmRzIHRoYXQgZG8gQUpBWFxuICAgICAgICAgICAgLy8gOjogY2FsbHMgYW5kIGhhdmUgZGVsYXlzLCBpZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIHNldCB0b1xuICAgICAgICAgICAgLy8gOjogdHJ1ZSBpdCB3aWxsIG5vdCBlY2hvIGV4ZWN1dGVkIGNvbW1hbmRcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbW1hbmQsIHNpbGVudCwgZGVmZXJyZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRlZmVycmVkIHx8IG5ldyAkLkRlZmVycmVkKCk7XG4gICAgICAgICAgICAgICAgY21kX3JlYWR5KGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KGNvbW1hbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gcmVjdXIoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNtZCA9IGNvbW1hbmQuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY21kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXhlYyhjbWQsIHNpbGVudCkuZG9uZShyZWN1cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvdGggY29tbWFuZHMgZXhlY3V0ZWQgaGVyZSAocmVzdW1lIHdpbGwgY2FsbCBUZXJtOjpleGVjKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVsYXkgY29tbWFuZCBtdWx0aXBsZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxheWVkX2NvbW1hbmRzLnB1c2goW2NvbW1hbmQsIHNpbGVudCwgZF0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tbWFuZHMgbWF5IHJldHVybiBwcm9taXNlIGZyb20gdXNlciBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCB3aWxsIHJlc29sdmUgZXhlYyBwcm9taXNlIHdoZW4gdXNlciBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyByZXNvbHZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGNvbW1hbmRzKGNvbW1hbmQsIHNpbGVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnByb21pc2UocmV0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHdoaWxlIHRlc3RpbmcgaXQgZGlkbid0IGV4ZWN1dGVkIGxhc3QgZXhlYyB3aGVuIHVzaW5nIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBmb3IgcmVzb2x2ZWQgZGVmZXJyZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5wcm9taXNlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogYnlwYXNzIGxvZ2luIGZ1bmN0aW9uIHRoYXQgd2FpdCB1bnRpbGwgeW91IHR5cGUgdXNlci9wYXNzXG4gICAgICAgICAgICAvLyA6OiBpdCBoaWRlIGltcGxlbWVudGF0aW9uIGRldGFpbFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgYXV0b2xvZ2luOiBmdW5jdGlvbih1c2VyLCB0b2tlbiwgc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd0ZXJtaW5hbC5hdXRvbG9naW4nLCBbdXNlciwgdG9rZW4sIHNpbGVudF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IEZ1bmN0aW9uIGNoYW5nZXMgdGhlIHByb21wdCBvZiB0aGUgY29tbWFuZCBsaW5lIHRvIGxvZ2luXG4gICAgICAgICAgICAvLyA6OiB3aXRoIGEgcGFzc3dvcmQgYW5kIGNhbGxzIHRoZSB1c2VyIGxvZ2luIGZ1bmN0aW9uIHdpdGhcbiAgICAgICAgICAgIC8vIDo6IHRoZSBjYWxsYmFjayB0aGF0IGV4cGVjdHMgYSB0b2tlbi4gVGhlIGxvZ2luIGlzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgIC8vIDo6IGlmIHRoZSB1c2VyIGNhbGxzIGl0IHdpdGggdmFsdWUgdGhhdCBpcyB0cnV0aHlcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGxvZ2luOiBmdW5jdGlvbihhdXRoLCBpbmZpbml0ZSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dpbnMucHVzaChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgIGlmIChpbl9sb2dpbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3ByaW50ZihzdHJpbmdzKCkubm90V2hpbGVMb2dpbiwgJ2xvZ2luJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzX2Z1bmN0aW9uKGF1dGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHJpbmdzKCkubG9naW5Jc05vdEFGdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluX2xvZ2luID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi50b2tlbigpICYmIHNlbGYubGV2ZWwoKSA9PT0gMSAmJiAhYXV0b2xvZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIGluX2xvZ2luID0gZmFsc2U7IC8vIGxvZ291dCB3aWxsIGNhbGwgbG9naW5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dvdXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLnRva2VuKHRydWUpICYmIHNlbGYubG9naW5fbmFtZSh0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbl9sb2dpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oc3VjY2VzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc3RvcmUgbG9naW4gZGF0YSBpbiBoaXN0b3J5XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZF9saW5lLmhpc3RvcnkoKS5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHBvcFVzZXJQYXNzKCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc2VsZi5sZXZlbCgpID4gbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucG9wKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmhpc3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRfbGluZS5oaXN0b3J5KCkuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc28gd2Uga25vdyBob3cgbWFueSB0aW1lcyBjYWxsIHBvcFxuICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IHNlbGYubGV2ZWwoKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsb2dpbl9jYWxsYmFjayh1c2VyLCB0b2tlbiwgc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnBhdXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9wVXNlclBhc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gc2VsZi5wcmVmaXhfbmFtZSh0cnVlKSArICdfJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0KG5hbWUgKyAndG9rZW4nLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnNldChuYW1lICsgJ2xvZ2luJywgdXNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbl9sb2dpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCgnb25BZnRlckxvZ2luJywgW3VzZXIsIHRva2VuXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oc3VjY2VzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIHVzZWQgaW50ZXJuYWx5IHNpbmNlIHVzZXJzIGtub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGxvZ2luIHN1Y2Nlc3MgKHRoZXkgZGVjaWRlIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBoYXBwZW4gYnkgY2FsbGluZyB0aGUgY2FsbGJhY2sgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgZnVudGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5maW5pdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVycm9yKHN0cmluZ3MoKS53cm9uZ1Bhc3N3b3JkVHJ5QWdhaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBvcCh1bmRlZmluZWQsIHRydWUpLnNldF9tYXNrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5fbG9naW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVycm9yKHN0cmluZ3MoKS53cm9uZ1Bhc3N3b3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5wb3AodW5kZWZpbmVkLCB0cnVlKS5wb3AodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWQgb25seSB0byBjYWxsIHBvcCBpbiBwdXNoXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLm9mZigndGVybWluYWwuYXV0b2xvZ2luJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYub24oJ3Rlcm1pbmFsLmF1dG9sb2dpbicsIGZ1bmN0aW9uKGV2ZW50LCB1c2VyLCB0b2tlbiwgc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJlX2V2ZW50KCdvbkJlZm9yZUxvZ2luJywgW3VzZXIsIHRva2VuXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9naW5fY2FsbGJhY2sodXNlciwgdG9rZW4sIHNpbGVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsZi5wdXNoKGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRfbWFzayhzZXR0aW5ncy5tYXNrQ2hhcikucHVzaChmdW5jdGlvbihwYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJlX2V2ZW50KCdvbkJlZm9yZUxvZ2luJywgW3VzZXIsIHBhc3NdKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wVXNlclBhc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGF1dGguY2FsbChzZWxmLCB1c2VyLCBwYXNzLCBmdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dpbl9jYWxsYmFjayh1c2VyLCB0b2tlbiwgc2lsZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ICYmIGlzX2Z1bmN0aW9uKHJldC50aGVuIHx8IHJldC5kb25lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmV0LnRoZW4gfHwgcmV0LmRvbmUpLmNhbGwocmV0LCBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9naW5fY2FsbGJhY2sodXNlciwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9leGNlcHRpb24oZSwgJ0FVVEgnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXB0OiBzdHJpbmdzKCkucGFzc3dvcmQgKyAnOiAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3Bhc3N3b3JkJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHByb21wdDogc3RyaW5ncygpLmxvZ2luICsgJzogJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xvZ2luJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IFVzZXIgZGVmaW5lZCBzZXR0aW5ncyBhbmQgZGVmYXVsdHMgYXMgd2VsbFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgc2V0dGluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBHZXQgc3RyaW5nIGJlZm9yZSBjdXJzb3JcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGJlZm9yZV9jdXJzb3I6IGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gY29tbWFuZF9saW5lLnBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBjb21tYW5kX2xpbmUuZ2V0KCkuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgICAgICAgICB2YXIgY21kX3N0cmluZ3MgPSBjb21tYW5kLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZzsgLy8gc3RyaW5nIGJlZm9yZSBjdXJzb3IgdGhhdCB3aWxsIGJlIGNvbXBsZXRlZFxuICAgICAgICAgICAgICAgIGlmICh3b3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbWRfc3RyaW5ncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IGNtZF9zdHJpbmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBjb21tYW5kLm1hdGNoKC8oXFxcXD9cIikvZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG91YmxlX3F1b3RlcyA9IG0gPyBtLmZpbHRlcihmdW5jdGlvbihjaHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWNoci5tYXRjaCgvXlxcXFwvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gY29tbWFuZC5tYXRjaCgvJy9nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaW5nbGVfcXVvdGUgPSBtID8gbS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpbmdsZV9xdW90ZSAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBjb21tYW5kLm1hdGNoKC8oJ1teJ10qKSQvKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZG91YmxlX3F1b3RlcyAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBjb21tYW5kLm1hdGNoKC8oXCIoPzpbXlwiXXxcXFxcXCIpKikkLylbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IGNtZF9zdHJpbmdzW2NtZF9zdHJpbmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGNtZF9zdHJpbmdzLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJlYXQgZXNjYXBlIHNwYWNlIGFzIHBhcnQgb2YgdGhlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldl9zdHJpbmcgPSBjbWRfc3RyaW5nc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2X3N0cmluZ1twcmV2X3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBjbWRfc3RyaW5nc1tpIC0gMV0gKyAnICcgKyBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IGNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogY29tcGxldGUgd29yZCBvciBjb21tYW5kIGJhc2VkIG9uIGFycmF5IG9mIHdvcmRzXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oY29tbWFuZHMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gJC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICB3b3JkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlY2hvOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlY2hvQ29tbWFuZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRvdWJsZVRhYjogbnVsbFxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMgfHwge30pO1xuICAgICAgICAgICAgICAgIHZhciBzZW5zaXRpdmUgPSBvcHRpb25zLmNhc2VTZW5zaXRpdmU7XG4gICAgICAgICAgICAgICAgLy8gY3Vyc29yIGNhbiBiZSBpbiB0aGUgbWlkZGxlIG9mIHRoZSBjb21tYW5kXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBnZXQgdGhlIHRleHQgYmVmb3JlIHRoZSBjdXJzb3JcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gc2VsZi5iZWZvcmVfY3Vyc29yKG9wdGlvbnMud29yZCkucmVwbGFjZSgvXFxcXFwiL2csICdcIicpO1xuICAgICAgICAgICAgICAgIHZhciBxdW90ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZy5tYXRjaCgvXlwiLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlID0gJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpbmcubWF0Y2goL14nLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlID0gXCInXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXltcIiddLywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0YWJfY291bnQgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBzZWxmLmJlZm9yZV9jdXJzb3Iob3B0aW9ucy53b3JkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdCA9IHNlbGYuYmVmb3JlX2N1cnNvcihvcHRpb25zLndvcmQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVzdCAhPT0gY29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tbWFuZCBsaW5lIGNoYW5nZWQgYmV0d2VlbiBUQUJTIC0gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNhZmUgPSAkLnRlcm1pbmFsLmVzY2FwZV9yZWdleChzdHJpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVzY2FwZSkge1xuICAgICAgICAgICAgICAgICAgICBzYWZlID0gc2FmZS5yZXBsYWNlKC8oXFxcXCspKFtcIicoKSBdKS9nLCBmdW5jdGlvbihfLCBzbGFzaCwgY2hyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hyLm1hdGNoKC9bKCldLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xhc2ggKyAnXFxcXD9cXFxcJyArIGNocjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsYXNoICsgJz8nICsgY2hyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVvdGUgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFxdW90ZSAmJiBvcHRpb25zLmVzY2FwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoLyhbXCInKCkgXSkvZywgJ1xcXFwkMScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoZWRfc3RyaW5ncygpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGNvbW1hbmRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmRzW2ldLm1hdGNoKC9cXG4vKSAmJiBvcHRpb25zLndvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdJZiB5b3UgdXNlIGNvbW1hbmRzIHdpdGggbmV3bGluZXMgeW91ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Nob3VsZCB1c2Ugd29yZCBvcHRpb24gZm9yIGNvbXBsZXRlIG9yJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdvcmRBdXRvY29tcGxldGUgdGVybWluYWwgb3B0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXgudGVzdChjb21tYW5kc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBlc2NhcGUoY29tbWFuZHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2Vuc2l0aXZlICYmIHNhbWVfY2FzZShtYXRjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZy50b0xvd2VyQ2FzZSgpID09PSBzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpbmcudG9VcHBlckNhc2UoKSA9PT0gc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGZsYWdzID0gc2Vuc2l0aXZlID8gJycgOiAnaSc7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBzYWZlLCBmbGFncyk7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBtYXRjaGVkX3N0cmluZ3MoKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXBsYWNlKGlucHV0LCByZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHNlbGYuZ2V0X2NvbW1hbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IHNlbGYuZ2V0X3Bvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJ14nICsgaW5wdXQsICdpJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmUgPSB0ZXh0LnNsaWNlKDAsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3N0ID0gdGV4dC5zbGljZShwb3MpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9faW5zZXJ0ID0gcmVwbGFjZW1lbnQucmVwbGFjZShyZSwgJycpICsgKHF1b3RlIHx8ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRfY29tbWFuZChwcmUgKyB0b19pbnNlcnQgKyBwb3N0KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRfcG9zaXRpb24oKHByZSArIHRvX2luc2VydCkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVzY2FwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZShzYWZlLCBtYXRjaGVkWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5zZXJ0KG1hdGNoZWRbMF0ucmVwbGFjZShyZWdleCwgJycpICsgKHF1b3RlIHx8ICcnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZCA9IHNlbGYuYmVmb3JlX2N1cnNvcihvcHRpb25zLndvcmQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZWQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKyt0YWJfY291bnQgPj0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFiX2NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVjaG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24ob3B0aW9ucy5kb3VibGVUYWIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ldyBBUEkgb2xkIGlzIGtlZXAgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZWNob0NvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjaG9fY29tbWFuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBvcHRpb25zLmRvdWJsZVRhYi5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2hvX2NvbW1hbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZG91YmxlVGFiICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2hvX2NvbW1hbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSBtYXRjaGVkLnNsaWNlKCkucmV2ZXJzZSgpLmpvaW4oJ1xcdFxcdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVjaG8oJC50ZXJtaW5hbC5lc2NhcGVfYnJhY2tldHModGV4dCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBXb3JkczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcnM6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21tb24gPSBjb21tb25fc3RyaW5nKGVzY2FwZShzdHJpbmcpLCBtYXRjaGVkLCBzZW5zaXRpdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1vbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2Uoc2FmZSwgY29tbW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kID0gc2VsZi5iZWZvcmVfY3Vyc29yKG9wdGlvbnMud29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogUmV0dXJuIGNvbW1hbmRzIGZ1bmN0aW9uIGZyb20gdG9wIGludGVycHJldGVyXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBjb21tYW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVycHJldGVycy50b3AoKS5pbnRlcnByZXRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBMb3cgTGV2ZWwgbWV0aG9kIHRoYXQgb3ZlcndyaXRlcyBpbnRlcnByZXRlclxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgc2V0X2ludGVycHJldGVyOiBmdW5jdGlvbih1c2VyX2ludHJwLCBsb2dpbikge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG92ZXJ3cml0ZV9pbnRlcnByZXRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXVzZShzZXR0aW5ncy5zb2Z0UGF1c2UpO1xuICAgICAgICAgICAgICAgICAgICBtYWtlX2ludGVycHJldGVyKHVzZXJfaW50cnAsIGxvZ2luLCBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9wID0gaW50ZXJwcmV0ZXJzLnRvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQodG9wLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlcGFyZV90b3BfaW50ZXJwcmV0ZXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24obG9naW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9naW4obG9naW4sIHRydWUsIG92ZXJ3cml0ZV9pbnRlcnByZXRlcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChnZXRfdHlwZSh1c2VyX2ludHJwKSA9PT0gJ3N0cmluZycgJiYgbG9naW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dpbihcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VfanNvbl9ycGNfbG9naW4odXNlcl9pbnRycCwgbG9naW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJ3cml0ZV9pbnRlcnByZXRlclxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJ3cml0ZV9pbnRlcnByZXRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBTaG93IHVzZXIgZ3JlZXRpbmdzIG9yIHRlcm1pbmFsIHNpZ25hdHVyZVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgZ3JlZXRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzaG93X2dyZWV0aW5ncygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IFJldHVybiB0cnVlIGlmIHRlcm1pbmFsIGlzIHBhdXNlZCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHBhdXNlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdXNlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBQYXVzZSB0aGUgdGVybWluYWwsIGl0IHNob3VsZCBiZSB1c2VkIGZvciBhamF4IGNhbGxzXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBwYXVzZTogZnVuY3Rpb24odmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNtZF9yZWFkeShmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgICAgICAgICAgICAgb25QYXVzZSgpO1xuICAgICAgICAgICAgICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUuZGlzYWJsZSh2aXNpYmxlIHx8IGlzX2FuZHJvaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRfbGluZS5maW5kKCcuY21kLXByb21wdCcpLmhpZGRlbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpcmVfZXZlbnQoJ29uUGF1c2UnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBSZXN1bWUgdGhlIHByZXZpb3VzbHkgcGF1c2VkIHRlcm1pbmFsXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICByZXN1bWU6IGZ1bmN0aW9uKHNpbGVudCkge1xuICAgICAgICAgICAgICAgIGNtZF9yZWFkeShmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkICYmIHRlcm1pbmFscy5mcm9udCgpID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUuZW5hYmxlKHNpbGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZF9saW5lLmZpbmQoJy5jbWQtcHJvbXB0JykudmlzaWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBkZWxheWVkX2NvbW1hbmRzO1xuICAgICAgICAgICAgICAgICAgICBkZWxheWVkX2NvbW1hbmRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JpZ2luYWwubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXhlYy5hcHBseShzZWxmLCBvcmlnaW5hbFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdyZXN1bWUnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcmVzdW1lX2NhbGxiYWNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxfdG9fYm90dG9tKCk7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVfZXZlbnQoJ29uUmVzdW1lJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogUmV0dXJuIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGZpdCBpbnRvIHRoZSB3aWR0aCBvZlxuICAgICAgICAgICAgLy8gOjogdGhlIHRlcm1pbmFsXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBjb2xzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubnVtQ2hhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm51bUNoYXJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG51bV9jaGFycyA9PT0gJ3VuZGVmaW5lZCcgfHwgbnVtX2NoYXJzID09PSAxMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bV9jaGFycyA9IGdldF9udW1fY2hhcnMoc2VsZiwgY2hhcl9zaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bV9jaGFycztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaW5lcyB0aGF0IGZpdCBpbnRvIHRoZSBoZWlnaHQgb2YgdGhlXG4gICAgICAgICAgICAvLyA6OiB0ZXJtaW5hbFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgcm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm51bVJvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm51bVJvd3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtX3Jvd3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bV9yb3dzID0gZ2V0X251bV9yb3dzKHNlbGYsIGNoYXJfc2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudW1fcm93cztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBSZXR1cm4gdGhlIEhpc3Rvcnkgb2JqZWN0XG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBoaXN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZF9saW5lLmhpc3RvcnkoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiB0b2dnbGUgcmVjb3JkaW5nIG9mIGhpc3Rvcnkgc3RhdGVcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGhpc3Rvcnlfc3RhdGU6IGZ1bmN0aW9uKHRvZ2dsZSkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaGlzdG9yeVN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzYXZlX3N0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zYXZlX3N0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGVybWluYWxzLmxlbmd0aCgpID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zYXZlX3N0YXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b2dnbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgc2V0IHRvIHRydWUgYW5kIGlmIHNldCBmcm9tIHVzZXIgY29tbWFuZCB3ZSBuZWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCB0byBpbmNsdWRlIHRoZSBjb21tYW5kXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93LnNldEltbWVkaWF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocnVuLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShydW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaGlzdG9yeVN0YXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IGNsZWFyIHRoZSBoaXN0b3J5IHN0YXRlXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBjbGVhcl9oaXN0b3J5X3N0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBoYXNoX2NvbW1hbmRzID0gW107XG4gICAgICAgICAgICAgICAgc2F2ZV9zdGF0ZSA9IFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IFN3aXRjaCB0byB0aGUgbmV4dCB0ZXJtaW5hbFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlcm1pbmFscy5sZW5ndGgoKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbHMuZnJvbnQoKS5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdGVybWluYWxzLnJvdGF0ZSgpLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyA1MCBwcm92aWRlcyBidWZmZXIgaW4gdmlld3BvcnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBuZXh0Lm9mZnNldCgpLnRvcCAtIDUwO1xuICAgICAgICAgICAgICAgICAgICAkKCdodG1sLGJvZHknKS5hbmltYXRlKHtzY3JvbGxUb3A6IHh9LCA1MDApO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcl90ZXJtaW5hbF9jaGFuZ2UobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfZXhjZXB0aW9uKGUsICdvblRlcm1pbmFsQ2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IE1ha2UgdGhlIHRlcm1pbmFsIGluIGZvY3VzIG9yIGJsdXIgZGVwZW5kaW5nIG9uIHRoZSBmaXJzdFxuICAgICAgICAgICAgLy8gOjogYXJndW1lbnQuIElmIHRoZXJlIGlzIG1vcmUgdGhlbiBvbmUgdGVybWluYWwgaXQgd2lsbFxuICAgICAgICAgICAgLy8gOjogc3dpdGNoIHRvIG5leHQgb25lLCBpZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIHNldCB0byB0cnVlXG4gICAgICAgICAgICAvLyA6OiB0aGUgZXZlbnRzIHdpbGwgYmUgbm90IGZpcmVkLiBVc2VkIG9uIGluaXRcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbih0b2dnbGUsIHNpbGVudCkge1xuICAgICAgICAgICAgICAgIGNtZF9yZWFkeShmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlcm1pbmFscy5sZW5ndGgoKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvZ2dsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc2FibGUoc2lsZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmFibGUoc2lsZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2dnbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcm9udCA9IHRlcm1pbmFscy5mcm9udCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb250ICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgc2hvdWxkIGJlIG9ubHkgZnJvbSB0ZXJtaW5hbCBlbmFibGVkIGJ1dCB0ZXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvbWV0aW1lIGZhaWwgYmVjYXVzZSB0aGVyZSB3aGVyZSBtb3JlIHRoZW0gb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlcmUgY3Vyc29yIGhhdmUgYmxpbmsgY2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbHMuZm9yRWFjaChmdW5jdGlvbih0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVybWluYWwgIT09IHNlbGYgJiYgdGVybWluYWwuZW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbC5kaXNhYmxlKHNpbGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcl90ZXJtaW5hbF9jaGFuZ2Uoc2VsZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfZXhjZXB0aW9uKGUsICdvblRlcm1pbmFsQ2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbHMuc2V0KHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmFibGUoc2lsZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IERpc2FibGUvRW5hYmxlIHRlcm1pbmFsIHRoYXQgY2FuIGJlIGVuYWJsZWQgYnkgY2xpY2tcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGZyZWV6ZTogZnVuY3Rpb24oZnJlZXplKSB7XG4gICAgICAgICAgICAgICAgd2hlbl9yZWFkeShmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyZWV6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm96ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvemVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogY2hlY2sgaWYgdGVybWluYWwgaXMgZnJvemVuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBmcm96ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm96ZW47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogRW5hYmxlIHRoZSB0ZXJtaW5hbFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgZW5hYmxlOiBmdW5jdGlvbihzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZWQgJiYgIWZyb3plbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVtX2NoYXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuYWJsaW5nIGZpcnN0IHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVzaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY21kX3JlYWR5KGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2lsZW50ICYmICFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCgnb25Gb2N1cycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaWxlbnQgJiYgcmV0ID09PSB1bmRlZmluZWQgfHwgc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLnBhdXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRfbGluZS5lbmFibGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogZnVuY3Rpb24gY2xlYXIgZm9ybWF0dGluZyBjYWNoZSBpZiB5b3UgZG9uJ3QgbG9uZ2VyIG5lZWQgaXRcbiAgICAgICAgICAgIC8vIDo6IGNhY2hlIGlzIHVzZWQgaWYgb3B0aW9uIHVzZUNhY2hlIGlzIHNldCB0byB0cnVlXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBjbGVhcl9jYWNoZTogJ01hcCcgaW4gcm9vdCA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvcm1hdF9jYWNoZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHN0cmluZ19jYWNoZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IERpc2FibGUgdGhlIHRlcm1pbmFsXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBkaXNhYmxlOiBmdW5jdGlvbihzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBjbWRfcmVhZHkoZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2lsZW50ICYmIGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGZpcmVfZXZlbnQoJ29uQmx1cicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2lsZW50ICYmIHJldCA9PT0gdW5kZWZpbmVkIHx8IHNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZF9saW5lLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IHJldHVybiB0cnVlIGlmIHRoZSB0ZXJtaW5hbCBpcyBlbmFibGVkXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBlbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5hYmxlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBSZXR1cm4gdGhlIHRlcm1pbmFsIHNpZ25hdHVyZSBkZXBlbmRpbmcgb24gdGhlIHNpemUgb2YgdGhlIHRlcm1pbmFsXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBzaWduYXR1cmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2xzID0gc2VsZi5jb2xzKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNpZ25hdHVyZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhzID0gc2lnbmF0dXJlc1tpXS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGgubWF4LmFwcGx5KG51bGwsIGxlbmd0aHMpIDw9IGNvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYXR1cmVzW2ldLmpvaW4oJ1xcbicpICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IFJldHVybiB0aGUgdmVyc2lvbiBudW1iZXJcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHZlcnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLnRlcm1pbmFsLnZlcnNpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogUmV0dXJuIGFjdHVhbCBjb21tYW5kIGxpbmUgb2JqZWN0IChqcXVlcnkgb2JqZWN0IHdpdGggY21kXG4gICAgICAgICAgICAvLyA6OiBtZXRob2RzKVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgY21kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZF9saW5lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IFJldHVybiB0aGUgY3VycmVudCBjb21tYW5kIGVudGVyZWQgYnkgdGVybWluYWxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGdldF9jb21tYW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZF9saW5lLmdldCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IGVjaG8gY29tbWFuZCBhbmQgcHJldmlvdXMgcHJvbXB0ICh1c2VkIGJ5IGVjaG9fbmV3bGluZS5qcylcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGVjaG9fY29tbWFuZDogZnVuY3Rpb24oY29tbWFuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlY2hvX2NvbW1hbmQoY29tbWFuZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogQ2hhbmdlIHRoZSBjb21tYW5kIGxpbmUgdG8gdGhlIG5ldyBvbmVcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHNldF9jb21tYW5kOiBmdW5jdGlvbihjb21tYW5kLCBzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICB3aGVuX3JlYWR5KGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciB0byB1c2Ugb3B0aW9ucyAtIGJyZWFraW5nIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbW1hbmQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kID0gSlNPTi5zdHJpbmdpZnkoY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZF9saW5lLnNldChjb21tYW5kLCB1bmRlZmluZWQsIHNpbGVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogQ2hhbmdlIHBvc2l0aW9uIG9mIHRoZSBjb21tYW5kIGxpbmVcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHNldF9wb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24sIHJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgd2hlbl9yZWFkeShmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZF9saW5lLnBvc2l0aW9uKHBvc2l0aW9uLCByZWxhdGl2ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogUmV0dXJuIHBvc2l0aW9uIG9mIHRoZSBjb21tYW5kIGxpbmVcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGdldF9wb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRfbGluZS5wb3NpdGlvbigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IEluc2VydCB0ZXh0IGludG8gdGhlIGNvbW1hbmQgbGluZSBhZnRlciB0aGUgY3Vyc29yXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBpbnNlcnQ6IGZ1bmN0aW9uKHN0cmluZywgc3RheSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB3aGVuX3JlYWR5KGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbSA9IHNlbGYuaXNfYm90dG9tKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUuaW5zZXJ0KHN0cmluZywgc3RheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2Nyb2xsT25FY2hvIHx8IGJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsX3RvX2JvdHRvbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNwcmludGYoc3RyaW5ncygpLm5vdEFTdHJpbmcsICdpbnNlcnQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IFNldCB0aGUgcHJvbXB0IG9mIHRoZSBjb21tYW5kIGxpbmVcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHNldF9wcm9tcHQ6IGZ1bmN0aW9uKHByb21wdCkge1xuICAgICAgICAgICAgICAgIHdoZW5fcmVhZHkoZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihwcm9tcHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUucHJvbXB0KGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXB0LmNhbGwoc2VsZiwgY2FsbGJhY2ssIHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUucHJvbXB0KHByb21wdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJzLnRvcCgpLnByb21wdCA9IHByb21wdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBSZXR1cm4gdGhlIHByb21wdCB1c2VkIGJ5IHRoZSB0ZXJtaW5hbFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgZ2V0X3Byb21wdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVycHJldGVycy50b3AoKS5wcm9tcHQ7XG4gICAgICAgICAgICAgICAgLy8gY29tbWFuZF9saW5lLnByb21wdCgpOyAtIGNhbiBiZSBhIHdyYXBwZXJcbiAgICAgICAgICAgICAgICAvL3JldHVybiBjb21tYW5kX2xpbmUucHJvbXB0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogRW5hYmxlIG9yIERpc2FibGUgbWFzayBkZXBlZG5pbmcgb24gdGhlIHBhc3NlZCBhcmd1bWVudFxuICAgICAgICAgICAgLy8gOjogdGhlIG1hc2sgY2FuIGFsc28gYmUgY2hhcmFjdGVyIChpbiBmYWN0IGl0IHdpbGwgd29yayB3aXRoXG4gICAgICAgICAgICAvLyA6OiBzdHJpbmdzIGxvbmdlciB0aGVuIG9uZSlcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHNldF9tYXNrOiBmdW5jdGlvbihtYXNrKSB7XG4gICAgICAgICAgICAgICAgd2hlbl9yZWFkeShmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZF9saW5lLm1hc2sobWFzayA9PT0gdHJ1ZSA/IHNldHRpbmdzLm1hc2tDaGFyIDogbWFzayk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogUmV0dXJuIHRoZSBvdXB1dCBvZiB0aGUgdGVybWluYWwgYXMgdGV4dFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgZ2V0X291dHB1dDogZnVuY3Rpb24ocmF3KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQubWFwKGxpbmVzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNfZnVuY3Rpb24oaXRlbVswXSkgPyBpdGVtWzBdKCkgOiBpdGVtWzBdO1xuICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogUmVjYWxjdWxhdGUgYW5kIHJlZHJhdyBldmVyeXRoaW5nXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICByZXNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVsYXkgcmVzaXplIGlmIHRlcm1pbmFsIG5vdCB2aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc3RvcFRpbWUoJ3Jlc2l6ZScpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uZVRpbWUoNTAwLCAncmVzaXplJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi53aWR0aCh3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhlaWdodChoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc2VsZi53aWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBzZWxmLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLm51bUNoYXJzICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNldHRpbmdzLm51bVJvd3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUucmVzaXplKHNldHRpbmdzLm51bUNoYXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCgnb25SZXNpemUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X251bV9jaGFycyA9IGdldF9udW1fY2hhcnMoc2VsZiwgY2hhcl9zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19udW1fcm93cyA9IGdldF9udW1fcm93cyhzZWxmLCBjaGFyX3NpemUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGlmIG51bWJlciBvZiBjaGFycyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdfbnVtX2NoYXJzICE9PSBudW1fY2hhcnMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld19udW1fcm93cyAhPT0gbnVtX3Jvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bV9jaGFycyA9IG5ld19udW1fY2hhcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1fcm93cyA9IG5ld19udW1fcm93cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmRfbGluZS5yZXNpemUobnVtX2NoYXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCgnb25SZXNpemUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiByZWRyYXcgdGhlIHRlcm1pbmFsXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICByZWZyZXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhcl9zaXplLndpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGZbMF0uc3R5bGUuc2V0UHJvcGVydHkoJy0tY2hhci13aWR0aCcsIGNoYXJfc2l6ZS53aWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlZHJhdyh7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IEZsdXNoIHRoZSBvdXRwdXQgdG8gdGhlIHRlcm1pbmFsXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBmbHVzaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm90dG9tID0gc2VsZi5pc19ib3R0b20oKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNzcygndmlzaWJpbHR5JywgJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlcjtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJpbnQgYWxsIGxpbmVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBvdXRwdXRfYnVmZmVyID0gbGluZXMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG91dHB1dF9idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IG91dHB1dF9idWZmZXIuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSBORVdfTElORSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIgPSAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJC5pc1BsYWluT2JqZWN0KGRhdGEpICYmIGlzX2Z1bmN0aW9uKGRhdGEuZmluYWxpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBmaW5hbGl6ZSBmdW5jdGlvbiBmcm9tIGVjaG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy51cGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gJz4gZGl2W2RhdGEtaW5kZXg9JyArIGRhdGEuaW5kZXggKyAnXSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gb3V0cHV0LmZpbmQoc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5odG1sKCkgIT09IHdyYXBwZXIuaHRtbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlcGxhY2VXaXRoKHdyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRUbyhvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmF0dHIoJ2RhdGEtaW5kZXgnLCBkYXRhLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmZpbmFsaXplKHdyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGRhdGEubGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLm5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2LmNsYXNzTmFtZSA9ICdjbWQtZW5kLWxpbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyWzBdLmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGltaXRfbGluZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmNzcygndmlzaWJpbHR5JywgJycpO1xuICAgICAgICAgICAgICAgICAgICBmaXJlX2V2ZW50KCdvbkZsdXNoJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5zY3JvbGxPbkVjaG8gJiYgb3B0aW9ucy5zY3JvbGwpIHx8IGJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxfdG9fYm90dG9tKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oc2V0dGluZ3MuZXhjZXB0aW9uSGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZXhjZXB0aW9uSGFuZGxlci5jYWxsKHNlbGYsIGUxLCAnVEVSTUlOQUwgKEZsdXNoKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5leGNlcHRpb25IYW5kbGVyID0gJC5ub29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0X2V4Y2VwdGlvbignW2V4Y2VwdGlvbkhhbmRsZXJdJywgZTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnRfZXhjZXB0aW9uKCdbRmx1c2hdJywgZTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0X2J1ZmZlciA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBVcGRhdGUgdGhlIG91dHB1dCBsaW5lIC0gbGluZSBudW1iZXIgY2FuIGJlIG5lZ2F0aXZlXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKGxpbmUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgd2hlbl9yZWFkeShmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZXMubGVuZ3RoICsgbGluZTsgLy8geWVzICtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmVzW2xpbmVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVycm9yKCdJbnZhbGlkIGxpbmUgbnVtYmVyICcgKyBsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuc3BsaWNlKGxpbmUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmZpbmQoJ1tkYXRhLWluZGV4PScgKyBsaW5lICsgJ10nKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBwcmVwYXJlX3JlbmRlcih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHJldFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzW2xpbmVdWzBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzW2xpbmVdWzFdID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NfbGluZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mbHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogY29udmVuaWVuY2UgbWV0aG9kIGZvciByZW1vdmluZyBzZWxlY3RlZCBsaW5lXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICByZW1vdmVfbGluZTogZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnVwZGF0ZShsaW5lLCBudWxsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiByZXR1cm4gaW5kZXggb2YgbGFzdCBsaW5lIGluIGNhc2Ugd2hlbiB5b3UgbmVlZCB0byB1cGRhdGVcbiAgICAgICAgICAgIC8vIDo6IGFmdGVyIHNvbWV0aGluZyBpcyBlY2hvIG9uIHRoZSB0ZXJtaW5hbFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgbGFzdF9pbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogUHJpbnQgZGF0YSB0byB0aGUgdGVybWluYWwgb3V0cHV0LiBJdCBjYW4gaGF2ZSBvcHRpb25zXG4gICAgICAgICAgICAvLyA6OiAqIGZsdXNoIC0gaW5kaWNhdGUgdGhhdCBhcmcgc2hvdWxkIGJlIHNlbmQgdG8gRE9NXG4gICAgICAgICAgICAvLyA6OiAqIHJhdyAtIGluZGljYXRlIGlmIGl0IHNob3VsZCBoYW5kbGUgaW5wdXQgYXMgaHRtbFxuICAgICAgICAgICAgLy8gOjogKiBmaW5hbGl6ZSAtIGZ1bmN0aW9uIGNhbGwgd2l0aCBjb250YWluZXIgZGl2XG4gICAgICAgICAgICAvLyA6OiAqIGtlZXBXb3JkcyAtIGluZm9ybSBob3cgdG8gd3JhcCB0ZXh0XG4gICAgICAgICAgICAvLyA6OiAqIGZvcm1hdHRlcnMgLSBpbmZvcm0gZnVuY3Rpb24gaWYgaXQgc2hvdWxkIHVzZSBmb3JtYXR0ZXJzXG4gICAgICAgICAgICAvLyA6OiAgIG9uIGlucHV0IHN0cmluZyAtIGdvb2QgdG8gcHJldmVudCBYU1Mgd2hlbiB5b3Ugd2FudFxuICAgICAgICAgICAgLy8gOjogICBhZHZhbmNlZCBzZXJ2ZXIgc2lkZSBjb250cm9saW5nIG9mIHRlcm1pbmFsXG4gICAgICAgICAgICAvLyA6OiB5b3UgY2FuIGVjaG86IHByb21pc2UsIGZ1bmN0aW9uLCBzdHJpbmdzIGFycmF5IG9yIHN0cmluZ1xuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgZWNobzogZnVuY3Rpb24oYXJnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ19kZWZpbmVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZWNobyhhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbHMgPSAkLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXc6IHNldHRpbmdzLnJhdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZTogJC5ub29wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVubW91bnQ6ICQubm9vcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZWVwV29yZHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZU1ldGhvZHM6IHNldHRpbmdzLmludm9rZU1ldGhvZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGVhcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXJzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBzZXR0aW5ncy5hbGxvd2VkQXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5hbGl6ZSBmdW5jdGlvbiBpcyBwYXNzZWQgYXJvdW5kIGFuZCBpbnZva2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0ZXJtaW5hbDo6Zmx1c2ggYWZ0ZXIgY29udGVudCBpcyBhZGRlZCB0byBET01cbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbihmaW5hbGl6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2Fscy5maW5hbGl6ZSA9IGZ1bmN0aW9uKGRpdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxzLnJhdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2LmFkZENsYXNzKCdyYXcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKGZpbmFsaXplKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsaXplLmNhbGwoc2VsZiwgZGl2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5maW5kKCdpbWcnKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxmID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXBsYWNlV2l0aCh1c2VfYnJva2VuX2ltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSB0aGlzLnNyYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X2V4Y2VwdGlvbihlLCAnVVNFUjplY2hvKGZpbmFsaXplKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxpemUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKGxvY2Fscy5maW5hbGl6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxzLmZsdXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmx1c2ggYnVmZmVyIGlmIHRoZXJlIHdhcyBubyBmbHVzaCBhZnRlciBwcmV2aW91cyBlY2hvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dF9idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyZV9ldmVudCgnb25CZWZvcmVFY2hvJywgW2FyZ10pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhcmcuYmluZChzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnX2RlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBTdHJpbmcoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IHByZXByb2Nlc3NfdmFsdWUoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVyKHZhbHVlLCBsb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzX2xpbmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGxpbmVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleHRlbmRlZCBjb21tYW5kcyBzaG91bGQgYmUgcHJvY2Vzc2VkIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uY2UgaW4gZWNobyBhbmQgbm90IG9uIHJlZHJhd1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxzLmV4ZWMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goW3ZhbHVlLCBsb2NhbHNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbHMuZmx1c2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCgnb25BZnRlckVjaG8nLCBbYXJnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGVjaG8gdGhyb3cgZXhjZXB0aW9uIHdlIGNhbid0IHVzZSBlcnJvciB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzcGxheSB0aGF0IGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKHNldHRpbmdzLmV4Y2VwdGlvbkhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZXhjZXB0aW9uSGFuZGxlci5jYWxsKHNlbGYsIGUsICdURVJNSU5BTCAoZWNobyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnRfZXhjZXB0aW9uKCdbVGVybWluYWwuZWNob10nLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJnICE9PSB1bmRlZmluZWQgJiYgaXNfZnVuY3Rpb24oYXJnLnRoZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICQud2hlbihhcmcpLmRvbmUoZWNobykuY2F0Y2gobWFrZV9sYWJlbF9lcnJvcignRWNobycpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlY2hvKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IGVjaG8gcmVkIHRleHRcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBvcHRpb25zLCB7cmF3OiBmYWxzZSwgZm9ybWF0dGVyczogZmFsc2V9KTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXQoc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nID0gU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcXVpY2sgaGFjayB0byBmaXggdHJhaWxpbmcgYmFja3NsYXNoXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSAkLnRlcm1pbmFsLmVzY2FwZV9icmFja2V0cyhzdHJpbmcpLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZSgvXFxcXCQvLCAnJiM5MjsnKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UodXJsX3JlLCAnXSQxW1s7Ozt0ZXJtaW5hbC1lcnJvcl0nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbWzs7O3Rlcm1pbmFsLWVycm9yXScgKyBzdHIgKyAnXSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5lY2hvKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdChtZXNzYWdlLmNhbGwoc2VsZikpO1xuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UgJiYgbWVzc2FnZS50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGhlbihmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWNobyhmb3JtYXQoc3RyaW5nKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKG1ha2VfbGFiZWxfZXJyb3IoJ0VjaG8gRXJyb3InKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5lY2hvKGZvcm1hdChtZXNzYWdlKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogRGlzcGxheSBFeGNlcHRpb24gb24gdGVybWluYWxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGV4Y2VwdGlvbjogZnVuY3Rpb24oZSwgbGFiZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGV4Y2VwdGlvbl9tZXNzYWdlKGUpO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gJyYjOTE7JyArIGxhYmVsICsgJyYjOTM7OiAnICsgbWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvcihtZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24oZGl2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2LmFkZENsYXNzKCd0ZXJtaW5hbC1leGNlcHRpb24gdGVybWluYWwtbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBXb3JkczogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmZpbGVOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBkaXNwbGF5IGZpbGVuYW1lIGFuZCBsaW5lIHdoaWNoIHRocm93IGV4ZXB0aW9uXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGF1c2Uoc2V0dGluZ3Muc29mdFBhdXNlKTtcbiAgICAgICAgICAgICAgICAgICAgJC5nZXQoZS5maWxlTmFtZSwgZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bSA9IGUubGluZU51bWJlciAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGZpbGUuc3BsaXQoJ1xcbicpW251bV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXJyb3IoJ1snICsgZS5saW5lTnVtYmVyICsgJ106ICcgKyBsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sICd0ZXh0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFjayA9ICQudGVybWluYWwuZXNjYXBlX2JyYWNrZXRzKGUuc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVjaG8oc3RhY2suc3BsaXQoL1xcbi9nKS5tYXAoZnVuY3Rpb24odHJhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lc3RlZCBmb3JtYXR0aW5nIHdpbGwgaGFuZGxlIHVybHMgYnV0IHRoYXQgZm9ybWF0dGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIGJlIHJlbW92ZWQgLSB0aGlzIGNvZGUgd2FzIGNyZWF0ZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGZvcm1hdHRpbmcgZXhpc3RlZCAoc2VlIGNvbW1pdCBjZTAxYzNmNSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW1s7Ozt0ZXJtaW5hbC1lcnJvcl0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZS5yZXBsYWNlKHVybF9yZSwgZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnXScgKyB1cmwgKyAnW1s7Ozt0ZXJtaW5hbC1lcnJvcl0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uKGRpdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5hZGRDbGFzcygndGVybWluYWwtZXhjZXB0aW9uIHRlcm1pbmFsLXN0YWNrLXRyYWNlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyczogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IFNjcm9sbCBEaXYgdGhhdCBob2xkcyB0aGUgdGVybWluYWxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHNjcm9sbDogZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcztcbiAgICAgICAgICAgICAgICBhbW91bnQgPSBNYXRoLnJvdW5kKGFtb3VudCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucHJvcCkgeyAvLyB3b3JrIHdpdGggalF1ZXJ5ID4gMS42XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbW91bnQgPiBzZWxmLnByb3AoJ3Njcm9sbFRvcCcpICYmIGFtb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucHJvcCgnc2Nyb2xsVG9wJywgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zID0gc2VsZi5wcm9wKCdzY3JvbGxUb3AnKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxUb3AocG9zICsgYW1vdW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW1vdW50ID4gc2VsZi5wcm9wKCdzY3JvbGxUb3AnKSAmJiBhbW91bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnByb3AoJ3Njcm9sbFRvcCcsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNlbGYucHJvcCgnc2Nyb2xsVG9wJyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsVG9wKHBvcyArIGFtb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IEV4aXQgYWxsIGludGVycHJldGVycyBhbmQgbG9nb3V0LiBUaGUgZnVuY3Rpb24gd2lsbCB0aHJvd1xuICAgICAgICAgICAgLy8gOjogZXhjZXB0aW9uIGlmIHRoZXJlIGlzIG5vIGxvZ2luIHByb3ZpZGVkXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBsb2dvdXQ6IGZ1bmN0aW9uKGxvY2FsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluX2xvZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzcHJpbnRmKHN0cmluZ3MoKS5ub3RXaGlsZUxvZ2luLCAnbG9nb3V0JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGVuX3JlYWR5KGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2dpbiA9IGxvZ2lucy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0X3Rva2VuKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZ2luLmFwcGx5KHNlbGYsIGxvZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnRlcnByZXRlcnMuc2l6ZSgpID09PSAxICYmIHNlbGYudG9rZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dvdXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW50ZXJwcmV0ZXJzLnNpemUoKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3Agd2lsbCBjYWxsIGdsb2JhbF9sb2dvdXQgdGhhdCB3aWxsIGNhbGwgbG9naW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgc2l6ZSB3aWxsIGJlID4gMDsgdGhpcyBpcyB3b3JrYXJvdW5kIHRoZSBwcm9ibGVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYudG9rZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZ291dCh0cnVlKS5wb3AoKS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IEZ1bmN0aW9uIHJldHVybnMgdGhlIHRva2VuIHJldHVybmVkIGJ5IGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyA6OiBpbiBsb2dpbiBmdW5jdGlvbi4gSXQgZG9lcyBub3RoaW5nIChyZXR1cm4gdW5kZWZpbmVkKSBpZlxuICAgICAgICAgICAgLy8gOjogdGhlcmUgaXMgbm8gbG9naW5cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHRva2VuOiBmdW5jdGlvbihsb2NhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yYWdlLmdldChzZWxmLnByZWZpeF9uYW1lKGxvY2FsKSArICdfdG9rZW4nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBGdW5jdGlvbiBzZXRzIHRoZSB0b2tlbiB0byB0aGUgc3VwcGxpZWQgdmFsdWUuIFRoaXMgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIDo6IHdvcmtzIHJlZ2FyZGxlc3Mgb2Ygd2hlcmVyIHNldHRpbmdzLmxvZ2luIGlzIHN1cHBsaWVkXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBzZXRfdG9rZW46IGZ1bmN0aW9uKHRva2VuLCBsb2NhbCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gc2VsZi5wcmVmaXhfbmFtZShsb2NhbCkgKyAnX3Rva2VuJztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnNldChuYW1lLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IEZ1bmN0aW9uIGdldCB0aGUgdG9rZW4gZWl0aGVyIHNldCBieSB0aGUgbG9naW4gbWV0aG9kIG9yXG4gICAgICAgICAgICAvLyA6OiBieSB0aGUgc2V0X3Rva2VuIG1ldGhvZC5cbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGdldF90b2tlbjogZnVuY3Rpb24obG9jYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi50b2tlbihsb2NhbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogRnVuY3Rpb24gcmV0dXJuIExvZ2luIG5hbWUgZW50ZXJlZCBieSB0aGUgdXNlclxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgbG9naW5fbmFtZTogZnVuY3Rpb24obG9jYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmFnZS5nZXQoc2VsZi5wcmVmaXhfbmFtZShsb2NhbCkgKyAnX2xvZ2luJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogRnVuY3Rpb24gcmV0dXJucyB0aGUgbmFtZSBvZiBjdXJyZW50IGludGVycHJldGVyXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBuYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwcmV0ZXJzLnRvcCgpLm5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogRnVuY3Rpb24gcmV0dXJuIHByZWZpeCBuYW1lIGZvciBsb2dpbi90b2tlblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgcHJlZml4X25hbWU6IGZ1bmN0aW9uKGxvY2FsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSAoc2V0dGluZ3MubmFtZSA/IHNldHRpbmdzLm5hbWUgKyAnXycgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbF9pZDtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWwgJiYgaW50ZXJwcmV0ZXJzLnNpemUoKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsX25hbWUgPSBpbnRlcnByZXRlcnMubWFwKGZ1bmN0aW9uKGludHJwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50cnAubmFtZSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgfSkuc2xpY2UoMSkuam9pbignXycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArPSAnXycgKyBsb2NhbF9uYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IHdyYXBwZXIgZm9yIGNvbW1vbiB1c2UgY2FzZVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgcmVhZDogZnVuY3Rpb24obWVzc2FnZSwgc3VjY2VzcywgY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGZyb20gcmVhZCgpIHNob3VsZCBub3QgcGF1c2UgdGVybWluYWxcbiAgICAgICAgICAgICAgICBmb3JjZV9hd2FrZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZWxmLnB1c2goZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihzdWNjZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5oaXN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUuaGlzdG9yeSgpLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmVhZCcsXG4gICAgICAgICAgICAgICAgICAgIGhpc3Rvcnk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwcm9tcHQ6IG1lc3NhZ2UgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIG9uRXhpdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY2FuY2VsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuaGlzdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUuaGlzdG9yeSgpLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBQdXNoIGEgbmV3IGludGVyZW50ZXIgb24gdGhlIFN0YWNrXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbihpbnRlcnByZXRlciwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNtZF9yZWFkeShmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmluaXRlTG9naW46IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwdXNoX3NldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwdXNoX3NldHRpbmdzLm5hbWUgJiYgcHJldl9jb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIGlzIGNhbGxlZCBpbiBsb2dpblxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaF9zZXR0aW5ncy5uYW1lID0gcHJldl9jb21tYW5kLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHB1c2hfc2V0dGluZ3MucHJvbXB0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hfc2V0dGluZ3MucHJvbXB0ID0gKHB1c2hfc2V0dGluZ3MubmFtZSB8fCAnPicpICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIG5hbWVzLnB1c2gob3B0aW9ucy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcCA9IGludGVycHJldGVycy50b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLm1hc2sgPSBjb21tYW5kX2xpbmUubWFzaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB3YXNfcGF1c2VkID0gcGF1c2VkO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCgnb25QdXNoJywgW3RvcCwgaW50ZXJwcmV0ZXJzLnRvcCgpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlX3RvcF9pbnRlcnByZXRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGYucGF1c2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9pbnRlcnByZXRlcihpbnRlcnByZXRlciwgb3B0aW9ucy5sb2dpbiwgZnVuY3Rpb24ocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHQgaXMgb2JqZWN0IHdpdGggaW50ZXJwcmV0ZXIgYW5kIGNvbXBsZXRpb24gcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJzLnB1c2goJC5leHRlbmQoe30sIHJldCwgcHVzaF9zZXR0aW5ncykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHB1c2hfc2V0dGluZ3MuY29tcGxldGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzQXJyYXkocmV0LmNvbXBsZXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVycHJldGVycy50b3AoKS5jb21wbGV0aW9uID0gcmV0LmNvbXBsZXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcmV0LmNvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJzLnRvcCgpLmNvbXBsZXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHVzaF9zZXR0aW5ncy5sb2dpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGdldF90eXBlKHB1c2hfc2V0dGluZ3MubG9naW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gcHVzaF9zZXR0aW5ncy5pbmZpbml0ZUxvZ2luID8gJC5ub29wIDogc2VsZi5wb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9naW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoX3NldHRpbmdzLmxvZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaF9zZXR0aW5ncy5pbmZpbml0ZUxvZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChnZXRfdHlwZShpbnRlcnByZXRlcikgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBwdXNoX3NldHRpbmdzLmluZmluaXRlTG9naW4gPyAkLm5vb3AgOiBzZWxmLnBvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dpbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VfanNvbl9ycGNfbG9naW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaF9zZXR0aW5ncy5sb2dpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hfc2V0dGluZ3MuaW5maW5pdGVMb2dpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3YXNfcGF1c2VkICYmIHNlbGYuZW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXN1bWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogUmVtb3ZlIHRoZSBsYXN0IGludGVycHJldGVyIGZyb20gdGhlIFN0YWNrXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBwb3A6IGZ1bmN0aW9uKHN0cmluZywgc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVjaG9fY29tbWFuZChzdHJpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBzZWxmLnRva2VuKHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciB0b3A7XG4gICAgICAgICAgICAgICAgaWYgKGludGVycHJldGVycy5zaXplKCkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gaW50ZXJwcmV0ZXJzLnRvcCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubG9naW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCgnb25Qb3AnLCBbdG9wLCBudWxsXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxfbG9nb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJlX2V2ZW50KCdvbkV4aXQnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXJyb3Ioc3RyaW5ncygpLmNhbkV4aXRFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2xvZ2luZ19zdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBpbnRlcnByZXRlcnMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IGludGVycHJldGVycy50b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZV90b3BfaW50ZXJwcmV0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBtYXNrXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0X21hc2sodG9wLm1hc2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCgnb25Qb3AnLCBbY3VycmVudCwgdG9wXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2hlY2sgaW4gY2FzZSBpZiB5b3UgZG9uJ3QgcG9wIGZyb20gcGFzc3dvcmQgaW50ZXJwcmV0ZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluX2xvZ2luICYmIHNlbGYuZ2V0X3Byb21wdCgpICE9PSBzdHJpbmdzKCkubG9naW4gKyAnOiAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbl9sb2dpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjdXJyZW50Lm9uRXhpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5vbkV4aXQuY2FsbChzZWxmLCBzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Lm9uRXhpdCA9ICQubm9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X2V4Y2VwdGlvbihlLCAnb25FeGl0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogQ2hhbmdlIHRlcm1pbmFsIG9wdGlvbihzKSBhdCBydW50aW1lXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBvcHRpb246IGZ1bmN0aW9uKG9iamVjdF9vcl9uYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0X29yX25hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3Nbb2JqZWN0X29yX25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3Rfb3JfbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChvYmplY3Rfb3JfbmFtZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Nbb2JqZWN0X29yX25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3Rfb3JfbmFtZS5tYXRjaCgvXm51bShDaGFyc3xSb3dzKSQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogaW52b2tlIGtleWRvd24gc2hvcmN1dFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgaW52b2tlX2tleTogZnVuY3Rpb24oc2hvcnRjdXQpIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUuaW52b2tlX2tleShzaG9ydGN1dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogY2hhbmdlIHRlcm1pbmFsIGtleW1hcCBhdCBydW50aW1lXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBrZXltYXA6IGZ1bmN0aW9uKGtleW1hcCwgZm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZF9saW5lLmtleW1hcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleW1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kX2xpbmUua2V5bWFwKGtleW1hcCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJC5pc1BsYWluT2JqZWN0KGtleW1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5bWFwID0gJC5vbWFwKGtleW1hcCB8fCB7fSwgZnVuY3Rpb24oa2V5LCBmbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV3X2tleW1hcFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbi5iaW5kKHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSwgb3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV3IGtleW1hcCBmdW5jdGlvbiB3aWxsIGdldCBkZWZhdWx0IGFzIDJuZCBhcmd1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbChzZWxmLCBlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdfa2V5bWFwW2tleV0oZSwgb3JpZ2luYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUua2V5bWFwKGtleW1hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5bWFwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld19rZXltYXBba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZF9saW5lLmtleW1hcChrZXksIGZuLmJpbmQoc2VsZikpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZF9saW5lLmtleW1hcChrZXksIGZ1bmN0aW9uKGUsIG9yaWdpbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoc2VsZiwgZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdfa2V5bWFwW2tleV0oZSwgb3JpZ2luYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogUmV0dXJuIGhvdyBkZWVwIHlvdSBhcmUgaW4gbmVzdGVkIGludGVycHJldGVyc1xuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgbGV2ZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnByZXRlcnMuc2l6ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IFJlaW5pdGlhbGl6ZSB0aGUgdGVybWluYWxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3aGVuX3JlYWR5KGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbnRlcnByZXRlcnMuc2l6ZSgpID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXJzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyA6OiBSZW1vdmUgYWxsIGxvY2FsIHN0b3JhZ2UgbGVmdCBieSB0ZXJtaW5hbCwgaXQgd2lsbCBub3RcbiAgICAgICAgICAgIC8vIDo6IGxvZ291dCB5b3UgdW50aWwgeW91IHJlZnJlc2ggdGhlIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHB1cmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3aGVuX3JlYWR5KGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gc2VsZi5wcmVmaXhfbmFtZSgpICsgJ18nO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZXMgPSBzdG9yYWdlLmdldChwcmVmaXggKyAnaW50ZXJwcmV0ZXJzJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKEpTT04ucGFyc2UobmFtZXMpLCBmdW5jdGlvbihfLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmUobmFtZSArICdfY29tbWFuZHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZShuYW1lICsgJ190b2tlbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlKG5hbWUgKyAnX2xvZ2luJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUucHVyZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmUocHJlZml4ICsgJ2ludGVycHJldGVycycpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IFJlbW92ZSBhbGwgZXZlbnRzIGFuZCBET00gbm9kZXMgbGVmdCBieSB0ZXJtaW5hbCwgaXQgd2lsbFxuICAgICAgICAgICAgLy8gOjogbm90IHB1cmdlIHRoZSB0ZXJtaW5hbCBzbyB5b3Ugd2lsbCBoYXZlIHRoZSBzYW1lIHN0YXRlXG4gICAgICAgICAgICAvLyA6OiB3aGVuIHlvdSByZWZyZXNoIHRoZSBicm93c2VyXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3aGVuX3JlYWR5KGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUuZGVzdHJveSgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlc2l6ZXIoJ3VuYmluZCcpO1xuICAgICAgICAgICAgICAgICAgICBmb250X3Jlc2l6ZXIucmVzaXplcigndW5iaW5kJykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLnVuYmluZCgnLnRlcm1pbmFsXycgKyBzZWxmLmlkKCkpO1xuICAgICAgICAgICAgICAgICAgICAkKHdpbmRvdykudW5iaW5kKCcudGVybWluYWxfJyArIHNlbGYuaWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYudW5iaW5kKCdjbGljayB3aGVlbCBtb3VzZXdoZWVsIG1vdXNlZG93biBtb3VzZXVwJyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlRGF0YSgndGVybWluYWwnKS5yZW1vdmVDbGFzcygndGVybWluYWwnKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuYmluZCgnLnRlcm1pbmFsJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jc3MoJ3dpZHRoJywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3NzKCdoZWlnaHQnLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJCh3aW5kb3cpLm9mZignYmx1cicsIGJsdXJfdGVybWluYWwpLlxuICAgICAgICAgICAgICAgICAgICAgICAgb2ZmKCdmb2N1cycsIGZvY3VzX3Rlcm1pbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maW5kKCcudGVybWluYWwtZmlsbCwgLnRlcm1pbmFsLWZvbnQnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zdG9wVGltZSgpO1xuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbHMucmVtb3ZlKHRlcm1pbmFsX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2liaWxpdHlfb2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2aXNpYmlsaXR5X29ic2VydmVyLnVub2JzZXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHlfb2JzZXJ2ZXIudW5vYnNlcnZlKHNlbGZbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHZpc2liaWxpdHlfb2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxfbWFya2VyID0gc2VsZi5maW5kKCcudGVybWluYWwtc2Nyb2xsLW1hcmtlcicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNfYm90dG9tX29ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5X29ic2VydmVyLnVub2JzZXJ2ZShzY3JvbGxfbWFya2VyWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxfbWFya2VyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb25fb2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFscy5sZW5ndGgoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh3aW5kb3cpLm9mZignaGFzaGNoYW5nZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmdW5jdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogcmVmOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTg5Mjc5NjkvMzg3MTk0XG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBzY3JvbGxfdG86IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsID0gc2VsZi5zY3JvbGxUb3AoKSAtIHNlbGYub2Zmc2V0KCkudG9wICsgJChlbGVtKS5vZmZzZXQoKS50b3A7XG4gICAgICAgICAgICAgICAgc2VsZi5zY3JvbGxUb3Aoc2Nyb2xsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBzY3JvbGxfdG9fYm90dG9tOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gc2VsZi5wcm9wKCdzY3JvbGxIZWlnaHQnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQgPSBzZWxmLmF0dHIoJ3Njcm9sbEhlaWdodCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbFRvcChzY3JvbGxIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vIDo6IHJldHVybiB0cnVlIGlmIHRlcm1pbmFsIGRpdiBvciBib2R5IGlzIGF0IHRoZSBib3R0b21cbiAgICAgICAgICAgIC8vIDo6IGlzIHVzZSBzY3JvbGxCb3R0b21PZmZzZXQgb3B0aW9uIGFzIG1hcmdpbiBmb3IgdGhlIGNoZWNrXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICBpc19ib3R0b206IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY3JvbGxCb3R0b21PZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpc19ib3R0b21fZGV0ZWN0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNfYm90dG9tX2RldGVjdGVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxfaGVpZ2h0LCBzY3JvbGxfdG9wLCBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbF9oZWlnaHQgPSBzZWxmWzBdLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsX3RvcCA9IHNlbGZbMF0uc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBzZWxmWzBdLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gc2Nyb2xsX2hlaWdodCAtIHNldHRpbmdzLnNjcm9sbEJvdHRvbU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjcm9sbF90b3AgKyBoZWlnaHQgPiBsaW1pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKG5hbWUsIGZ1bikge1xuICAgICAgICAgICAgLy8gd3JhcCBhbGwgZnVuY3Rpb25zIGFuZCBkaXNwbGF5IGV4ZWNwdGlvbnNcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmdW5jdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmV4Y2VwdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyAkLnRlcm1pbmFsLkV4Y2VwdGlvbihzdHJpbmdzKCkuZGVmdW5jdFRlcm1pbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuLmFwcGx5KHNlbGYsIFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhlYyBjYXRjaCBieSBjb21tYW5kIChyZXN1bWUgY2FsbCBleGVjKVxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gJ2V4ZWMnICYmIG5hbWUgIT09ICdyZXN1bWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X2V4Y2VwdGlvbihlLCBlLnR5cGUgfHwgJ1RFUk1JTkFMJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5leGNlcHRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyA6OiBJTklUIENPREVcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gc3ByaW50ZihzdHJpbmdzKCkuaW52YWxpZFNlbGVjdG9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyAkLnRlcm1pbmFsLkV4Y2VwdGlvbihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZGF0YSgndGVybWluYWwnLCBzZWxmKTtcbiAgICAgICAgLy8gdmFyIG5hbWVzID0gW107IC8vIHN0YWNrIGlmIGludGVycHJldGVyIG5hbWVzXG4gICAgICAgIHZhciBwcmV2X2NvbW1hbmQ7IC8vIHVzZWQgZm9yIG5hbWUgb24gdGhlIHRlcm1pbmFsIGlmIG5vdCBkZWZpbmVkXG4gICAgICAgIHZhciBwcmV2X2V4ZWNfY21kO1xuICAgICAgICB2YXIgdGFiX2NvdW50ID0gMDsgLy8gZm9yIHRhYiBjb21wbGV0aW9uXG4gICAgICAgIHZhciBvdXRwdXQ7IC8vIC50ZXJtaW5hbC1vdXRwdXQganF1ZXJ5IG9iamVjdFxuICAgICAgICB2YXIgdGVybWluYWxfaWQgPSB0ZXJtaW5hbHMubGVuZ3RoKCk7XG4gICAgICAgIHZhciBmb3JjZV9hd2FrZSA9IGZhbHNlOyAvLyBmbGFnIHVzZWQgdG8gZG9uJ3QgcGF1c2Ugd2hlbiB1c2VyIHJldHVybiByZWFkKCkgY2FsbFxuICAgICAgICB2YXIgbnVtX2NoYXJzOyAvLyBudW1lciBvZiBjaGFycyBpbiBsaW5lXG4gICAgICAgIHZhciBudW1fcm93czsgLy8gbnVtYmVyIG9mIGxpbmVzIHRoYXQgZml0IHdpdGhvdXQgc2Nyb2xsYmFyXG4gICAgICAgIHZhciBjb21tYW5kOyAvLyBmb3IgdGFiIGNvbXBsZXRpb25cbiAgICAgICAgdmFyIGxvZ2lucyA9IG5ldyBTdGFjaygpOyAvLyBzdGFjayBvZiBsb2dpbnNcbiAgICAgICAgdmFyIGNvbW1hbmRfcXVldWUgPSBuZXcgRGVsYXlRdWV1ZSgpO1xuICAgICAgICB2YXIgaW5pdF9xdWV1ZSA9IG5ldyBEZWxheVF1ZXVlKCk7XG4gICAgICAgIHZhciB3aGVuX3JlYWR5ID0gcmVhZHkoaW5pdF9xdWV1ZSk7XG4gICAgICAgIHZhciBjbWRfcmVhZHkgPSByZWFkeShjb21tYW5kX3F1ZXVlKTtcbiAgICAgICAgdmFyIGlzX2JvdHRvbV9kZXRlY3RlZDtcbiAgICAgICAgdmFyIGlzX2JvdHRvbV9vYnNlcnZlcjtcbiAgICAgICAgdmFyIGluX2xvZ2luID0gZmFsc2U7Ly8gc29tZSBNZXRob2RzIHNob3VsZCBub3QgYmUgY2FsbGVkIHdoZW4gbG9naW5cbiAgICAgICAgLy8gVE9ETzogVHJ5IHRvIHVzZSBtdXRleCBsaWtlIGNvdW50ZXIgZm9yIHBhdXNlL3Jlc3VtZVxuICAgICAgICB2YXIgb25QYXVzZSA9ICQubm9vcDsvLyB1c2VkIHRvIGluZGljYXRlIHRoYXQgdXNlciBjYWxsIHBhdXNlIG9uSW5pdFxuICAgICAgICB2YXIgb2xkX3dpZHRoLCBvbGRfaGVpZ2h0O1xuICAgICAgICB2YXIgZGVsYXllZF9jb21tYW5kcyA9IFtdOyAvLyB1c2VkIHdoZW4gZXhlYyBjb21tYW5kcyB3aGlsZSBwYXVzZWRcbiAgICAgICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQoXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICQudGVybWluYWwuZGVmYXVsdHMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogc2VsZi5zZWxlY3RvcixcbiAgICAgICAgICAgICAgICBleGl0OiAhIShvcHRpb25zICYmIG9wdGlvbnMubG9naW4gfHwgIW9wdGlvbnMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9ucyB8fCB7fVxuICAgICAgICApO1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLndpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc2VsZi53aWR0aChzZXR0aW5ncy53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5oZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzZWxmLmhlaWdodChzZXR0aW5ncy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFyX3NpemUgPSBnZXRfY2hhcl9zaXplKHNlbGYpO1xuICAgICAgICAvLyBzbyBpdCdzIHRoZSBzYW1lIGFzIGluIFR5cGVTY3JpcHQgZGVmaW5pdGlvbiBmb3Igb3B0aW9uc1xuICAgICAgICBkZWxldGUgc2V0dGluZ3MuZm9ybWF0dGVycztcbiAgICAgICAgLy8gdXNlZCB0byB0aHJvdyBlcnJvciB3aGVuIGNhbGxpbmcgbWV0aG9kcyBvbiBkZXN0cm95ZWQgdGVybWluYWxcbiAgICAgICAgdmFyIGRlZnVuY3QgPSBmYWxzZTtcbiAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgIHZhciBzdG9yYWdlID0gbmV3IFN0b3JhZ2VIZWxwZXIoc2V0dGluZ3MubWVtb3J5KTtcbiAgICAgICAgdmFyIGVuYWJsZWQgPSBzZXR0aW5ncy5lbmFibGVkO1xuICAgICAgICB2YXIgZnJvemVuID0gZmFsc2U7XG4gICAgICAgIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGF1dG9sb2dpbiA9IHRydWU7IC8vIHNldCB0byBmYWxzZSBpZiBvbkJlZm9yZUxvZ2luIHJldHVybiBmYWxzZVxuICAgICAgICB2YXIgaW50ZXJwcmV0ZXJzO1xuICAgICAgICB2YXIgY29tbWFuZF9saW5lO1xuICAgICAgICB2YXIgb2xkX2VuYWJsZWQ7XG4gICAgICAgIHZhciB2aXNpYmlsaXR5X29ic2VydmVyO1xuICAgICAgICB2YXIgbXV0YXRpb25fb2JzZXJ2ZXI7XG4gICAgICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgaWYgKHNldHRpbmdzLmlnbm9yZVN5c3RlbURlc2NyaWJlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5kZXNjcmliZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZ2lzdGVyIGFqYXhTZW5kIGZvciBjYW5jZWwgcmVxdWVzdHMgb24gQ1RSTCtEXG4gICAgICAgICQoZG9jdW1lbnQpLmJpbmQoJ2FqYXhTZW5kLnRlcm1pbmFsXycgKyBzZWxmLmlkKCksIGZ1bmN0aW9uKGUsIHhocikge1xuICAgICAgICAgICAgcmVxdWVzdHMucHVzaCh4aHIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSAkKCc8ZGl2IGNsYXNzPVwidGVybWluYWwtd3JhcHBlclwiLz4nKS5hcHBlbmRUbyhzZWxmKTtcbiAgICAgICAgJChicm9rZW5faW1hZ2UpLmhpZGUoKS5hcHBlbmRUbyh3cmFwcGVyKTtcbiAgICAgICAgdmFyIGZvbnRfcmVzaXplciA9ICQoJzxkaXYgY2xhc3M9XCJ0ZXJtaW5hbC1mb250XCI+Jm5ic3A7PC9kaXY+JykuYXBwZW5kVG8oc2VsZik7XG4gICAgICAgIHZhciBmaWxsID0gJCgnPGRpdiBjbGFzcz1cInRlcm1pbmFsLWZpbGxcIi8+JykuYXBwZW5kVG8oc2VsZik7XG4gICAgICAgIG91dHB1dCA9ICQoJzxkaXY+JykuYWRkQ2xhc3MoJ3Rlcm1pbmFsLW91dHB1dCcpLmF0dHIoJ3JvbGUnLCAnbG9nJylcbiAgICAgICAgICAgIC5hcHBlbmRUbyh3cmFwcGVyKTtcbiAgICAgICAgc2VsZi5hZGRDbGFzcygndGVybWluYWwnKTtcbiAgICAgICAgLy8gYmVmb3JlIGxvZ2luIGV2ZW50XG4gICAgICAgIGlmIChzZXR0aW5ncy5sb2dpbiAmJiBmaXJlX2V2ZW50KCdvbkJlZm9yZUxvZ2luJykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhdXRvbG9naW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUganNvbi1ycGMgYXV0aGVudGljYXRpb24gZnVuY3Rpb25cbiAgICAgICAgdmFyIGJhc2VfaW50ZXJwcmV0ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgaW5pdF9pbnRlcnByZXRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJhc2VfaW50ZXJwcmV0ZXIgPSBpbml0X2ludGVycHJldGVyO1xuICAgICAgICB9IGVsc2UgaWYgKGlzX2FycmF5KGluaXRfaW50ZXJwcmV0ZXIpKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBKU09OLVJQQ1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGluaXRfaW50ZXJwcmV0ZXIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluaXRfaW50ZXJwcmV0ZXJbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VfaW50ZXJwcmV0ZXIgPSBpbml0X2ludGVycHJldGVyW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdsb2JhbF9sb2dpbl9mbjtcbiAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKHNldHRpbmdzLmxvZ2luKSkge1xuICAgICAgICAgICAgZ2xvYmFsX2xvZ2luX2ZuID0gc2V0dGluZ3MubG9naW47XG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZV9pbnRlcnByZXRlciAmJlxuICAgICAgICAgICAgKHR5cGVvZiBzZXR0aW5ncy5sb2dpbiA9PT0gJ3N0cmluZycgfHwgc2V0dGluZ3MubG9naW4gPT09IHRydWUpKSB7XG4gICAgICAgICAgICBnbG9iYWxfbG9naW5fZm4gPSBtYWtlX2pzb25fcnBjX2xvZ2luKGJhc2VfaW50ZXJwcmV0ZXIsIHNldHRpbmdzLmxvZ2luKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXJtaW5hbHMuYXBwZW5kKHNlbGYpO1xuICAgICAgICBmdW5jdGlvbiBmb2N1c190ZXJtaW5hbCgpIHtcbiAgICAgICAgICAgIGlmIChvbGRfZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIGJsdXJfdGVybWluYWwoKSB7XG4gICAgICAgICAgICBvbGRfZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgICAgICBzZWxmLmRpc2FibGUoKS5maW5kKCcuY21kIHRleHRhcmVhJykudHJpZ2dlcignYmx1cicsIFt0cnVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBmdW5jdGlvbiBzdHJpbmdpZnlfdmFsdWUodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0X3R5cGUodmFsdWUpICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihzZXR0aW5ncy5wYXJzZU9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IHNldHRpbmdzLnBhcnNlT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldF90eXBlKHJldCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNfYXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJC50ZXJtaW5hbC5jb2x1bW5zKHZhbHVlLCBzZWxmLmNvbHMoKSwgc2V0dGluZ3MudGFicyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRleHRfY2FsbGJhY2tfcHJveHkoZm4pIHtcbiAgICAgICAgICAgIGlmIChmbi5wcm94eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uY2FsbChzZWxmLCBjYWxsYmFjaywgc2VsZik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd3JhcHBlci5wcm94eSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIHBhc3RlIGV2ZW50IGlzIG5vdCB0ZXN0YWJsZSBpbiBub2RlXG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIGZ1bmN0aW9uIHBhc3RlX2V2ZW50KGUpIHtcbiAgICAgICAgICAgIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGJyb3dzZXIgdGhhdCBkb24ndCBzdXBwb3J0IGNsaXBib2FyZCBkYXRhXG4gICAgICAgICAgICAvLyB0aG9zZSBicm93c2VyIHNpbXBsZSB3aWxsIG5vdCBoYXZlIHRoaXMgZmVhdHVyZSBub3JtYWwgcGFzdGVcbiAgICAgICAgICAgIC8vIGlzIGNyb3NzLWJyb3dzZXIgYW5kIGl0J3MgaGFuZGxlZCBieSBjbWQgcGx1Z2luXG4gICAgICAgICAgICBmdW5jdGlvbiBpc190eXBlKGl0ZW0sIHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS50eXBlLmluZGV4T2YodHlwZSkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZWNob19pbWFnZShpbWFnZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZWNobygnPGltZyBzcmM9XCInICsgaW1hZ2UgKyAnXCIvPicsIHtyYXc6IHRydWV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRhdGFfdXJpKGJsb2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuICAgICAgICAgICAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZWNobyhvYmplY3QsIGlnbm9yZUV2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmICghaWdub3JlRXZlbnRzICYmIGlzX2Z1bmN0aW9uKHNldHRpbmdzLm9uUGFzdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogc2VsZlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Wyd0ZXh0J10gPSBvYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRbJ2ltYWdlJ10gPSBkYXRhX3VyaShvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBmaXJlX2V2ZW50KCdvblBhc3RlJywgW2V2ZW50XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihyZXQudGhlbiB8fCByZXQuZG9uZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHJldC50aGVuIHx8IHJldC5kb25lKS5jYWxsKHJldCwgZnVuY3Rpb24ocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjaG8ocmV0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWNobyhyZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWNobyhldmVudC5pbWFnZSB8fCBldmVudC50ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgICAgICBlY2hvX2ltYWdlKGRhdGFfdXJpKG9iamVjdCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdC5tYXRjaCgvXihkYXRhOnxibG9iOikvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWNob19pbWFnZShvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnNlcnQob2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLmNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5lbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gZS5jbGlwYm9hcmREYXRhLml0ZW1zO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfdHlwZShpdGVtc1tpXSwgJ2ltYWdlJykgJiYgc2V0dGluZ3MucGFzdGVJbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IGl0ZW1zW2ldLmdldEFzRmlsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2hvKGJsb2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNfdHlwZShpdGVtc1tpXSwgJ3RleHQvcGxhaW4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS5nZXRBc1N0cmluZyhlY2hvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5jbGlwYm9hcmREYXRhLmdldERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gZS5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVjaG8odGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAkKGRvY3VtZW50KS5vbigncGFzdGUudGVybWluYWxfJyArIHNlbGYuaWQoKSwgcGFzdGVfZXZlbnQpO1xuICAgICAgICB2YXIgbmV3X2tleW1hcCA9ICQuZXh0ZW5kKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBrZXltYXAsXG4gICAgICAgICAgICAkLm9tYXAoc2V0dGluZ3Mua2V5bWFwIHx8IHt9LCBmdW5jdGlvbihrZXksIGZuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXltYXBba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4uYmluZChzZWxmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUsIG9yaWdpbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5ldyBrZXltYXAgZnVuY3Rpb24gd2lsbCBnZXQgZGVmYXVsdCBhcyAybmQgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoc2VsZiwgZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5bWFwW2tleV0oZSwgb3JpZ2luYWwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgbWFrZV9pbnRlcnByZXRlcihpbml0X2ludGVycHJldGVyLCBzZXR0aW5ncy5sb2dpbiwgZnVuY3Rpb24oaW50ZXJwcmV0ZXIpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5jb21wbGV0aW9uICYmIHR5cGVvZiBzZXR0aW5ncy5jb21wbGV0aW9uICE9PSAnYm9vbGVhbicgfHxcbiAgICAgICAgICAgICAgICAhc2V0dGluZ3MuY29tcGxldGlvbikge1xuICAgICAgICAgICAgICAgIC8vIG92ZXJ3cml0ZSBpbnRlcnByZXRlciBjb21wbGV0aW9uIGJ5IGdsb2JhbCBzZXR0aW5nICMyMjRcbiAgICAgICAgICAgICAgICAvLyB3ZSB1c2Ugc3RyaW5nIHRvIGluZGljYXRlIHRoYXQgaXQgbmVlZCB0byBiZSB0YWtlbiBmcm9tIHNldHRpbmdzXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgYXJlIGFibGUgdG8gY2hhbmdlIGl0IHVzaW5nIG9wdGlvbiBBUEkgbWV0aG9kXG4gICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXIuY29tcGxldGlvbiA9ICdzZXR0aW5ncyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvbXB0ID0gc2V0dGluZ3MucHJvbXB0O1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmN0aW9uKHByb21wdCkpIHtcbiAgICAgICAgICAgICAgICBwcm9tcHQgPSBjb250ZXh0X2NhbGxiYWNrX3Byb3h5KHByb21wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcnByZXRlcnMgPSBuZXcgU3RhY2soJC5leHRlbmQoe30sIHNldHRpbmdzLmV4dHJhLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogc2V0dGluZ3MubmFtZSxcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdCxcbiAgICAgICAgICAgICAgICBrZXlwcmVzczogc2V0dGluZ3Mua2V5cHJlc3MsXG4gICAgICAgICAgICAgICAga2V5ZG93bjogc2V0dGluZ3Mua2V5ZG93bixcbiAgICAgICAgICAgICAgICByZXNpemU6IHNldHRpbmdzLm9uUmVzaXplLFxuICAgICAgICAgICAgICAgIGdyZWV0aW5nczogc2V0dGluZ3MuZ3JlZXRpbmdzLFxuICAgICAgICAgICAgICAgIG1vdXNld2hlZWw6IHNldHRpbmdzLm1vdXNld2hlZWwsXG4gICAgICAgICAgICAgICAgaGlzdG9yeTogc2V0dGluZ3MuaGlzdG9yeSxcbiAgICAgICAgICAgICAgICBrZXltYXA6IG5ld19rZXltYXBcbiAgICAgICAgICAgIH0sIGludGVycHJldGVyKSk7XG4gICAgICAgICAgICAvLyBDUkVBVEUgQ09NTUFORCBMSU5FXG4gICAgICAgICAgICBjb21tYW5kX2xpbmUgPSAkKCc8ZGl2Lz4nKS5hcHBlbmRUbyh3cmFwcGVyKS5jbWQoe1xuICAgICAgICAgICAgICAgIHRhYmluZGV4OiBzZXR0aW5ncy50YWJpbmRleCxcbiAgICAgICAgICAgICAgICBtb2JpbGVEZWxldGU6IHNldHRpbmdzLm1vYmlsZURlbGV0ZSxcbiAgICAgICAgICAgICAgICBtb2JpbGVJbmdvcmVBdXRvU3BhY2U6IHNldHRpbmdzLm1vYmlsZUluZ29yZUF1dG9TcGFjZSxcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IGdsb2JhbF9sb2dpbl9mbiA/IGZhbHNlIDogcHJvbXB0LFxuICAgICAgICAgICAgICAgIGhpc3Rvcnk6IHNldHRpbmdzLm1lbW9yeSA/ICdtZW1vcnknIDogc2V0dGluZ3MuaGlzdG9yeSxcbiAgICAgICAgICAgICAgICBoaXN0b3J5RmlsdGVyOiBzZXR0aW5ncy5oaXN0b3J5RmlsdGVyLFxuICAgICAgICAgICAgICAgIGhpc3RvcnlTaXplOiBzZXR0aW5ncy5oaXN0b3J5U2l6ZSxcbiAgICAgICAgICAgICAgICBjYXNlU2Vuc2l0aXZlU2VhcmNoOiBzZXR0aW5ncy5jYXNlU2Vuc2l0aXZlU2VhcmNoLFxuICAgICAgICAgICAgICAgIG9uUGFzdGU6IHNldHRpbmdzLm9uUGFzdGUsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjaGFyX3dpZHRoOiBjaGFyX3NpemUud2lkdGgsXG4gICAgICAgICAgICAgICAga2V5ZG93bjoga2V5X2Rvd24sXG4gICAgICAgICAgICAgICAga2V5bWFwOiBuZXdfa2V5bWFwLFxuICAgICAgICAgICAgICAgIGNsaWNrVGltZW91dDogc2V0dGluZ3MuY2xpY2tUaW1lb3V0LFxuICAgICAgICAgICAgICAgIGhvbGRUaW1lb3V0OiBzZXR0aW5ncy5ob2xkVGltZW91dCxcbiAgICAgICAgICAgICAgICBob2xkUmVwZWF0VGltZW91dDogc2V0dGluZ3MuaG9sZFJlcGVhdFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgcmVwZWF0VGltZW91dEtleXM6IHNldHRpbmdzLnJlcGVhdFRpbWVvdXRLZXlzLFxuICAgICAgICAgICAgICAgIGFsbG93ZWRBdHRyaWJ1dGVzOiBzZXR0aW5ncy5hbGxvd2VkQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBrZXlwcmVzczoga2V5X3ByZXNzLFxuICAgICAgICAgICAgICAgIHRhYnM6IHNldHRpbmdzLnRhYnMsXG4gICAgICAgICAgICAgICAgb25Qb3NpdGlvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBtYWtlX2N1cnNvcl92aXNpYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVfZXZlbnQoJ29uUG9zaXRpb25DaGFuZ2UnLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ29tbWFuZENoYW5nZTogZnVuY3Rpb24oY29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXNpemUgaXMgbm90IHRyaWdnZXJlZCB3aGVuIGluc2VydCBjYWxsZWQganVzdCBhZnRlciBpbml0XG4gICAgICAgICAgICAgICAgICAgIC8vICBhbmQgc2Nyb2xsYmFyIGFwcGVhclxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkX3dpZHRoICE9PSBmaWxsLndpZHRoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc2l6ZXIgaGFuZGxlciB3aWxsIHVwZGF0ZSBvbGRfd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVzaXplcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpcmVfZXZlbnQoJ29uQ29tbWFuZENoYW5nZScsIFtjb21tYW5kXSk7XG4gICAgICAgICAgICAgICAgICAgIG1ha2VfY3Vyc29yX3Zpc2libGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbW1hbmRzOiBjb21tYW5kc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBkaXNhYmxlKGUpIHtcbiAgICAgICAgICAgICAgICBlID0gZS5vcmlnaW5hbEV2ZW50O1xuICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGUudGVyZ2V0IGlzIGJvZHkgd2hlbiBjbGljayBvdXRzaWRlIG9mIGNvbnRleHQgbWVudSB0byBjbG9zZSBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHlvdSBjbGljayBvbiB0ZXJtaW5hbFxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISQobm9kZSkuY2xvc2VzdCgnLnRlcm1pbmFsJykubGVuZ3RoICYmIHNlbGYuZW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBvbmx5IG5lZWQgdG8gZGlzYWJsZSB3aGVuIGNsaWNrIG91dHNpZGUgb2YgdGVybWluYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsaWNrIG9uIG90aGVyIHRlcm1pbmFsIGlzIGhhbmRsZWQgYnkgZm9jdXMgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5vbmVUaW1lKDEwMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkuYmluZCgnY2xpY2sudGVybWluYWxfJyArIHNlbGYuaWQoKSwgZGlzYWJsZSkuXG4gICAgICAgICAgICAgICAgICAgIGJpbmQoJ2NvbnRleHRtZW51LnRlcm1pbmFsXycgKyBzZWxmLmlkKCksIGRpc2FibGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgJHdpbiA9ICQod2luZG93KTtcbiAgICAgICAgICAgIC8vIGNvcmRvdmEgYXBwbGljYXRpb24sIGlmIGtleWJvYXJkIHdhcyBvcGVuIGFuZCB3ZSByZXN1bWUsIGl0IHdpbGwgYmVcbiAgICAgICAgICAgIC8vIGNsb3NlZCBzbyB3ZSBuZWVkIHRvIGRpc2FibGUgdGVybWluYWwgc28geW91IGNhbiBlbmFibGUgaXQgd2l0aCB0YXBcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXN1bWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kaXNhYmxlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBpZiAoaXNfbW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmcm96ZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5lbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZF9saW5lLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3b3JrIHdlaXJkIG9uIG1vYmlsZVxuICAgICAgICAgICAgICAgICR3aW4ub24oJ2ZvY3VzLnRlcm1pbmFsXycgKyBzZWxmLmlkKCksIGZvY3VzX3Rlcm1pbmFsKS5cbiAgICAgICAgICAgICAgICAgICAgb24oJ2JsdXIudGVybWluYWxfJyArIHNlbGYuaWQoKSwgYmx1cl90ZXJtaW5hbCk7XG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0IG1vdXNlIGRyYWdcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9ICdjbGlja18nICsgc2VsZi5pZCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWEgPSBzZWxmLmZpbmQoJy5jbWQgdGV4dGFyZWEnKTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY2xpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHRhcmdldC5pcygnLnRlcm1pbmFsJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGFyZ2V0LmlzKCcudGVybWluYWwtd3JhcHBlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHNlbGYuZ2V0X2NvbW1hbmQoKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRfcG9zaXRpb24obGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHRhcmdldC5jbG9zZXN0KCcuY21kLXByb21wdCcpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0X3Bvc2l0aW9uKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXh0YXJlYS5pcygnOmZvY3VzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZ25vcmVfZWxlbWVudHMgPSAnLnRlcm1pbmFsLW91dHB1dCB0ZXh0YXJlYSwnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcudGVybWluYWwtb3V0cHV0IGlucHV0JztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb3VzZWRvd24oZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY3JvbGxiYXJfZXZlbnQoZSwgZmlsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGFyZ2V0ID0gJChlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLm1vdXNldXAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHRhcmdldCAmJiAkdGFyZ2V0LmNsb3Nlc3QoaWdub3JlX2VsZW1lbnRzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdldF9zZWxlY3RlZF9odG1sKCkgPT09ICcnICYmICR0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZyb3plbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IHNldHRpbmdzLmNsaWNrVGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9uZVRpbWUodGltZW91dCwgbmFtZSwgY2xpY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc3RvcFRpbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZGJsY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zdG9wVGltZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGlwID0gc2VsZi5maW5kKCcuY21kIHRleHRhcmVhJyk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzX2NvbnRleHRfZXZlbnQoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudHlwZSA9PT0gJ21vdXNlZG93bicgJiYgZS5idXR0b25zID09PSAyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS50eXBlID09PSAnY29udGV4dG1lbnUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub24oJ2NvbnRleHRtZW51LnRlcm1pbmFsIG1vdXNlZG93bi50ZXJtaW5hbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRfc2VsZWN0ZWRfaHRtbCgpID09PSAnJyAmJiBpc19jb250ZXh0X2V2ZW50KGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkKGUudGFyZ2V0KS5pcygnaW1nLHZhbHVlLGF1ZGlvLG9iamVjdCxjYW52YXMsYScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5lbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGNvbW1hbmRfbGluZS5vZmZzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZS5wYWdlWCAtIG9mZnNldC5sZWZ0IC0gMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGUucGFnZVkgLSBvZmZzZXQudG9wIC0gMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzVlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICc0ZW0nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsaXAuaXMoJzpmb2N1cycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zdG9wVGltZSgndGV4dGFyZWEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vbmVUaW1lKDEwMCwgJ3RleHRhcmVhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNfY3NzX3ZhcmlhYmxlc19zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5fbGluZSA9IHNlbGYuZmluZCgnLmNtZCAuY21kLWN1cnNvci1saW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByZXZVbnRpbCgnLmNtZC1wcm9tcHQnKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMudG9wID0gaW5fbGluZSAqIDE0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXAuY3NzKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc3RvcFRpbWUoJ3NlbGVjdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmV2ZXJ5VGltZSgyMCwgJ3NlbGVjdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaXBbMF0uc2VsZWN0aW9uICE9PSBjbGlwWzBdLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldF90ZXh0YXJlYV9zZWxlY3Rpb24oY2xpcFswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfdGV4dGFyZWFfc2VsZWN0aW9uKGNsaXBbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZpbmQoJy50ZXJtaW5hbC1vdXRwdXQnKVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmluZCgnLmNtZCBkaXY6bGFzdC1vZi10eXBlJylbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zdG9wVGltZSgnc2VsZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLm9uKCdjbGljaycsICdhJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKCR0aGlzLmNsb3Nlc3QoJy50ZXJtaW5hbC1leGNlcHRpb24nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhyZWYgPSAkdGhpcy5hdHRyKCdocmVmJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChocmVmLm1hdGNoKC86WzAtOV0rJC8pKSB7IC8vIGRpc3BsYXkgbGluZSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW50X2xpbmUoaHJlZiwgc2VsZi5jb2xzKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJlZm9jdXMgYmVjYXVzZSBsaW5rcyBoYXZlIHRhYmluZGV4IGluIGNhc2Ugd2hlcmUgdXNlciB3YW50XG4gICAgICAgICAgICAgICAgLy8gdGFiIGNoYW5nZSB1cmxzLCB3ZSBjYW4gaWdub3JlIHRoaXMgZnVuY3Rpb24gb24gY2xpY2tcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpbmQoJy5jbWQgdGV4dGFyZWEnKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2FsY3VsYXRlX2NoYXJfc2l6ZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBjaGFyX3NpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgY2hhcl9zaXplID0gZ2V0X2NoYXJfc2l6ZShzZWxmKTtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggIT09IGNoYXJfc2l6ZS53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kX2xpbmUub3B0aW9uKCdjaGFyX3dpZHRoJywgY2hhcl9zaXplLndpZHRoKS5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzaXplKCk7XG4gICAgICAgICAgICBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZmlsbC53aWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZmlsbC5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCB0b28gbWFueSBjYWxjdWxhdGlvbnMgaW4gSUVcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZF9oZWlnaHQgIT09IGhlaWdodCB8fCBvbGRfd2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9sZF9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIG9sZF93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZV9yZXNpemVycygpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiAndGVybWluYWwtJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2VsZi5yZXNpemVyKCd1bmJpbmQnKS5yZXNpemVyKHJlc2l6ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgZm9udF9yZXNpemVyLnJlc2l6ZXIoJ3VuYmluZCcpLnJlc2l6ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZV9jaGFyX3NpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXNpemUoKTtcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGJvdHRvbV9kZXRlY3QoaW50ZXJzZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlzX2JvdHRvbV9kZXRlY3RlZCA9IGludGVyc2VjdGlvbnNbMF0uaW50ZXJzZWN0aW9uUmF0aW8gPT09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVfYm90dG9tX2RldGVjdCgpIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3AgPSAkKCc8ZGl2IGNsYXNzPVwidGVybWluYWwtc2Nyb2xsLW1hcmtlclwiLz4nKS5hcHBlbmRUbyhzZWxmKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmtlciA9IHRvcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjcm9sbEJvdHRvbU9mZnNldCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlciA9ICQoJzxkaXYvPicpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzZXR0aW5ncy5zY3JvbGxCb3R0b21PZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmFwcGVuZFRvKHRvcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNfYm90dG9tX29ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGJvdHRvbV9kZXRlY3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3Q6IHNlbGZbMF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlzX2JvdHRvbV9vYnNlcnZlci5vYnNlcnZlKG1hcmtlclswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyBvYnNlcnZlciBjYW4gYmUgYWRkZWQgaW1lZGlldGVseSBldmVuIGlmIHRlcm1pbmFsIGlzIG5vdCBpbiB0aGUgRE9NXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGJvdGggb2YgdGhlIGVsZW1lbnRzIChyb290IGFuZCB0YXJnZXQpIGFyZSBpbiBzYW1lIGZyYWdtZW50XG4gICAgICAgICAgICBjcmVhdGVfYm90dG9tX2RldGVjdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGYuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVfcmVzaXplcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9ic2VydmVfdmlzaWJpbGl0eSgpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlzaWJpbGl0eV9vYnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaWJpbGl0eV9vYnNlcnZlci51bm9ic2VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHlfb2JzZXJ2ZXIudW5vYnNlcnZlKHNlbGZbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh2aXNpYmlsaXR5X29ic2VydmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgd2FzX2VuYWJsZWQgPSBzZWxmLmVuYWJsZWQoKTtcbiAgICAgICAgICAgICAgICB2YXIgdmlzaWJsZSA9IHNlbGYuaXMoJzp2aXNpYmxlJyk7XG4gICAgICAgICAgICAgICAgaWYgKHdhc19lbmFibGVkICYmICF2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVfcmVzaXplcnMoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIHRlcm1pbmFsIGNvbnRlbnQgdW50aWwgaXQncyByZXNpemVkIChhbmQgbnVtIGNoYXJzIGNhbGN1bGF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB2aXNpYmlsaXR5X2NoZWNrZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmlzKCc6dmlzaWJsZScpICYmICF2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZV9yZXNpemVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlX2NoYXJfc2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2FzX2VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVuYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5jc3MoJ3Zpc2liaWxpdHknLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmlzaWJsZSAmJiAhc2VsZi5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FzX2VuYWJsZWQgPSAkLnRlcm1pbmFsLmFjdGl2ZSgpID09PSBzZWxmICYmIHNlbGYuZW5hYmxlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyICYmIHNlbGYuY3NzKCdwb3NpdGlvbicpICE9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHlfb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIodmlzaWJpbGl0eV9jaGVja2VyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290OiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5X29ic2VydmVyLm9ic2VydmUoc2VsZlswXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eV9vYnNlcnZlciA9IHNldEludGVydmFsKHZpc2liaWxpdHlfY2hlY2tlciwgMTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5fZG9tID0gISFzZWxmLmNsb3Nlc3QoJ2JvZHknKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgTXV0YXRpb25PYnNydiA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8IHdpbmRvdy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuICAgICAgICAgICAgaWYgKE11dGF0aW9uT2JzcnYpIHtcbiAgICAgICAgICAgICAgICBtdXRhdGlvbl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic3J2KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jbG9zZXN0KCdib2R5JykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluX2RvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsX3RvX2JvdHRvbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgb2JzZXJ2ZXIgbmVlZCB0byBiZSBhZGRlZCB3aGVuIHRlcm1pbmFsIGlzIGluIHRoZSBET01cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlX3Zpc2liaWxpdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluX2RvbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5fZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbl9kb20gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG11dGF0aW9uX29ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluX2RvbSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGVsZW1lbnQgaXMgaW4gdGhlIERPTSBpZiBub3QgcnVubmluZyBJbnRlcnNlY3Rpb25PYnNlcnZlclxuICAgICAgICAgICAgICAgIC8vIGRvbid0IG1ha2Ugc2Vuc2VcbiAgICAgICAgICAgICAgICBvYnNlcnZlX3Zpc2liaWxpdHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbW1hbmRfcXVldWUucmVzb2x2ZSgpO1xuICAgICAgICAgICAgLy8gdG91Y2ggZGV2aWNlcyBuZWVkIHRvdWNoIGV2ZW50IHRvIGdldCB2aXJ0dWFsIGtleWJvYXJkXG4gICAgICAgICAgICBpZiAoZW5hYmxlZCAmJiBzZWxmLmlzKCc6dmlzaWJsZScpICYmICFpc19tb2JpbGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZvY3VzKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuZGlzYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gUnVuIExvZ2luXG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oZ2xvYmFsX2xvZ2luX2ZuKSkge1xuICAgICAgICAgICAgICAgIHNlbGYubG9naW4oZ2xvYmFsX2xvZ2luX2ZuLCB0cnVlLCBpbml0aWFsaXplKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gOjogaGVscGVyXG4gICAgICAgICAgICBmdW5jdGlvbiBleGVjX3NwZWMoc3BlYykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hbCA9IHRlcm1pbmFscy5nZXQoKVtzcGVjWzBdXTtcbiAgICAgICAgICAgICAgICAvLyBleGVjdXRlIGlmIGJlbG9uZyB0byB0aGlzIHRlcm1pbmFsXG4gICAgICAgICAgICAgICAgaWYgKHRlcm1pbmFsICYmIHRlcm1pbmFsX2lkID09PSB0ZXJtaW5hbC5pZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3BlY1syXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWZlciA9ICQuRGVmZXJyZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VtZV9jYWxsYmFja3MucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVybWluYWwuZXhlYyhzcGVjWzJdKS5kb25lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbC5zYXZlX3N0YXRlKHNwZWNbMl0sIHRydWUsIHNwZWNbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVybWluYWwuZXhlYyhzcGVjWzJdKS5kb25lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsLnNhdmVfc3RhdGUoc3BlY1syXSwgdHJ1ZSwgc3BlY1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGV4ZWMgZnJvbSBoYXNoIGNhbGxlZCBpbiBlYWNoIHRlcm1pbmFsIGluc3RhbmNlXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZXhlY0hhc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IHVudGlsIGxvZ2luIGlzIGluaXRpYWxpemVkXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaC5yZXBsYWNlKC9eIy8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB5ZXMgbm8gdmFyIC0gbG9jYWwgaW5zaWRlIHRlcm1pbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaF9jb21tYW5kcyA9IEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KGhhc2gpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uIHJlY3VyKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BlYyA9IGhhc2hfY29tbWFuZHNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNfc3BlYyhzcGVjKS5kb25lKHJlY3VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZV9oYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7Ly8gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnZhbGlkIGpzb24gLSBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlX2hhc2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlX2hhc2ggPSB0cnVlOyAvLyBpZiBlbmFibGVkIGxhdGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGFuZ2VfaGFzaCA9IHRydWU7IC8vIGV4ZWMgY2FuIG5vdyBjaGFuZ2UgaGFzaFxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hpZnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5iaW5kKCdrZXlkb3duLnRlcm1pbmFsXycgKyBzZWxmLmlkKCksIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLmJpbmQoJ2tleXVwLnRlcm1pbmFsXycgKyBzZWxmLmlkKCksIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gR29vZ2xlIENocm9taXVtL0xpbnV4IHNoaWZ0S2V5IGlzIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5IHx8IGUud2hpY2ggPT09IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCB3b3JrIHdpdGhvdXQgY2FsbGluZyBzY3JvbGwgb24gd2hlZWwgZXZlbnQgYnV0IHdlXG4gICAgICAgICAgICAgICAgLy8gbmVlZCBpdCBmb3IgY2FzZXMgd2hlcmUgeW91IGhhdmUgbW91c2Ugd2hlZWwgd29yayBkaWZmZXJlbnRseVxuICAgICAgICAgICAgICAgIC8vIGxpa2Ugd2l0aCBsZXNzIGNvbW1hbmQgdGhhdCBzY3JvbGwgdGV4dFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG1vdXNld2hlZWwoZXZlbnQsIGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnByZXRlciA9IGludGVycHJldGVycy50b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oaW50ZXJwcmV0ZXIubW91c2V3aGVlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBpbnRlcnByZXRlci5tb3VzZXdoZWVsKGV2ZW50LCBkZWx0YSwgc2VsZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzX2Z1bmN0aW9uKHNldHRpbmdzLm1vdXNld2hlZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gc2V0dGluZ3MubW91c2V3aGVlbChldmVudCwgZGVsdGEsIHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaGF2ZV9zY3JvbGxiYXIoKSB8fCByZXQgPT09IGZhbHNlKSAmJiAhZXZlbnQuY3RybEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbCgtNDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbCg0MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCQuZXZlbnQuc3BlY2lhbC5tb3VzZXdoZWVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGtlZXAgbW91c2V3aGVlbCBwbHVnaW4ganVzdCBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgIHNlbGYub24oJ21vdXNld2hlZWwnLCBtb3VzZXdoZWVsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlY3Rpb24gdGFrZSBmcm9tOlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvd2hlZWxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwib253aGVlbFwiIGluIGRpdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBcIndoZWVsXCI7IC8vIE1vZGVybiBicm93c2VycyBzdXBwb3J0IFwid2hlZWxcIlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50Lm9ubW91c2V3aGVlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZWJraXQgYW5kIElFIHN1cHBvcnQgYXQgbGVhc3QgXCJtb3VzZXdoZWVsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gXCJtb3VzZXdoZWVsXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBhc3N1bWUgdGhhdCByZW1haW5pbmcgYnJvd3NlcnMgYXJlIG9sZGVyIEZpcmVmb3hcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gXCJET01Nb3VzZVNjcm9sbFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpdiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub24oZXZlbnQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudCA9PT0gJ21vdXNld2hlZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSAtIDEgLyA0MCAqIGUub3JpZ2luYWxFdmVudC53aGVlbERlbHRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IGUub3JpZ2luYWxFdmVudC5kZWx0YVkgfHwgZS5vcmlnaW5hbEV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNld2hlZWwoZSwgLWRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfSk7IC8vIG1ha2VfaW50ZXJwcmV0ZXJcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTsgLy8gdGVybWluYWwgcGx1Z2luXG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/jquery.terminal/js/jquery.terminal.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz82MDE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/setimmediate/setImmediate.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyx1REFBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBLG1CQUFtQiwyQkFBMkI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7O0FBRUEsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZCxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0EsS0FBSyxLQUF3QyxFQUFFLEVBRTdDOztBQUVGLFFBQVEsc0JBQWlCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhcmVudCkge1xuICBpZiAocGFyZW50KXtcbiAgICByZXR1cm4gcGFyZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQsIHBhcmVudCk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1t0YXJnZXRdXG5cdH07XG59KSgpO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuICAgICAgICBpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlLCB0YXJnZXQpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXG5cdGlmKG9wdGlvbnMuYXR0cnMubm9uY2UgPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBub25jZSA9IGdldE5vbmNlKCk7XG5cdFx0aWYgKG5vbmNlKSB7XG5cdFx0XHRvcHRpb25zLmF0dHJzLm5vbmNlID0gbm9uY2U7XG5cdFx0fVxuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uY2UoKSB7XG5cdGlmICh0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4gX193ZWJwYWNrX25vbmNlX187XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gdHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nXG5cdFx0ID8gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcykgXG5cdFx0IDogb3B0aW9ucy50cmFuc2Zvcm0uZGVmYXVsdChvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz81MTE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLGlFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/timers-browserify/main.js\n");

/***/ }),

/***/ "./node_modules/wcwidth/combining.js":
/*!*******************************************!*\
  !*** ./node_modules/wcwidth/combining.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = [\n    [ 0x0300, 0x036F ], [ 0x0483, 0x0486 ], [ 0x0488, 0x0489 ],\n    [ 0x0591, 0x05BD ], [ 0x05BF, 0x05BF ], [ 0x05C1, 0x05C2 ],\n    [ 0x05C4, 0x05C5 ], [ 0x05C7, 0x05C7 ], [ 0x0600, 0x0603 ],\n    [ 0x0610, 0x0615 ], [ 0x064B, 0x065E ], [ 0x0670, 0x0670 ],\n    [ 0x06D6, 0x06E4 ], [ 0x06E7, 0x06E8 ], [ 0x06EA, 0x06ED ],\n    [ 0x070F, 0x070F ], [ 0x0711, 0x0711 ], [ 0x0730, 0x074A ],\n    [ 0x07A6, 0x07B0 ], [ 0x07EB, 0x07F3 ], [ 0x0901, 0x0902 ],\n    [ 0x093C, 0x093C ], [ 0x0941, 0x0948 ], [ 0x094D, 0x094D ],\n    [ 0x0951, 0x0954 ], [ 0x0962, 0x0963 ], [ 0x0981, 0x0981 ],\n    [ 0x09BC, 0x09BC ], [ 0x09C1, 0x09C4 ], [ 0x09CD, 0x09CD ],\n    [ 0x09E2, 0x09E3 ], [ 0x0A01, 0x0A02 ], [ 0x0A3C, 0x0A3C ],\n    [ 0x0A41, 0x0A42 ], [ 0x0A47, 0x0A48 ], [ 0x0A4B, 0x0A4D ],\n    [ 0x0A70, 0x0A71 ], [ 0x0A81, 0x0A82 ], [ 0x0ABC, 0x0ABC ],\n    [ 0x0AC1, 0x0AC5 ], [ 0x0AC7, 0x0AC8 ], [ 0x0ACD, 0x0ACD ],\n    [ 0x0AE2, 0x0AE3 ], [ 0x0B01, 0x0B01 ], [ 0x0B3C, 0x0B3C ],\n    [ 0x0B3F, 0x0B3F ], [ 0x0B41, 0x0B43 ], [ 0x0B4D, 0x0B4D ],\n    [ 0x0B56, 0x0B56 ], [ 0x0B82, 0x0B82 ], [ 0x0BC0, 0x0BC0 ],\n    [ 0x0BCD, 0x0BCD ], [ 0x0C3E, 0x0C40 ], [ 0x0C46, 0x0C48 ],\n    [ 0x0C4A, 0x0C4D ], [ 0x0C55, 0x0C56 ], [ 0x0CBC, 0x0CBC ],\n    [ 0x0CBF, 0x0CBF ], [ 0x0CC6, 0x0CC6 ], [ 0x0CCC, 0x0CCD ],\n    [ 0x0CE2, 0x0CE3 ], [ 0x0D41, 0x0D43 ], [ 0x0D4D, 0x0D4D ],\n    [ 0x0DCA, 0x0DCA ], [ 0x0DD2, 0x0DD4 ], [ 0x0DD6, 0x0DD6 ],\n    [ 0x0E31, 0x0E31 ], [ 0x0E34, 0x0E3A ], [ 0x0E47, 0x0E4E ],\n    [ 0x0EB1, 0x0EB1 ], [ 0x0EB4, 0x0EB9 ], [ 0x0EBB, 0x0EBC ],\n    [ 0x0EC8, 0x0ECD ], [ 0x0F18, 0x0F19 ], [ 0x0F35, 0x0F35 ],\n    [ 0x0F37, 0x0F37 ], [ 0x0F39, 0x0F39 ], [ 0x0F71, 0x0F7E ],\n    [ 0x0F80, 0x0F84 ], [ 0x0F86, 0x0F87 ], [ 0x0F90, 0x0F97 ],\n    [ 0x0F99, 0x0FBC ], [ 0x0FC6, 0x0FC6 ], [ 0x102D, 0x1030 ],\n    [ 0x1032, 0x1032 ], [ 0x1036, 0x1037 ], [ 0x1039, 0x1039 ],\n    [ 0x1058, 0x1059 ], [ 0x1160, 0x11FF ], [ 0x135F, 0x135F ],\n    [ 0x1712, 0x1714 ], [ 0x1732, 0x1734 ], [ 0x1752, 0x1753 ],\n    [ 0x1772, 0x1773 ], [ 0x17B4, 0x17B5 ], [ 0x17B7, 0x17BD ],\n    [ 0x17C6, 0x17C6 ], [ 0x17C9, 0x17D3 ], [ 0x17DD, 0x17DD ],\n    [ 0x180B, 0x180D ], [ 0x18A9, 0x18A9 ], [ 0x1920, 0x1922 ],\n    [ 0x1927, 0x1928 ], [ 0x1932, 0x1932 ], [ 0x1939, 0x193B ],\n    [ 0x1A17, 0x1A18 ], [ 0x1B00, 0x1B03 ], [ 0x1B34, 0x1B34 ],\n    [ 0x1B36, 0x1B3A ], [ 0x1B3C, 0x1B3C ], [ 0x1B42, 0x1B42 ],\n    [ 0x1B6B, 0x1B73 ], [ 0x1DC0, 0x1DCA ], [ 0x1DFE, 0x1DFF ],\n    [ 0x200B, 0x200F ], [ 0x202A, 0x202E ], [ 0x2060, 0x2063 ],\n    [ 0x206A, 0x206F ], [ 0x20D0, 0x20EF ], [ 0x302A, 0x302F ],\n    [ 0x3099, 0x309A ], [ 0xA806, 0xA806 ], [ 0xA80B, 0xA80B ],\n    [ 0xA825, 0xA826 ], [ 0xFB1E, 0xFB1E ], [ 0xFE00, 0xFE0F ],\n    [ 0xFE20, 0xFE23 ], [ 0xFEFF, 0xFEFF ], [ 0xFFF9, 0xFFFB ],\n    [ 0x10A01, 0x10A03 ], [ 0x10A05, 0x10A06 ], [ 0x10A0C, 0x10A0F ],\n    [ 0x10A38, 0x10A3A ], [ 0x10A3F, 0x10A3F ], [ 0x1D167, 0x1D169 ],\n    [ 0x1D173, 0x1D182 ], [ 0x1D185, 0x1D18B ], [ 0x1D1AA, 0x1D1AD ],\n    [ 0x1D242, 0x1D244 ], [ 0xE0001, 0xE0001 ], [ 0xE0020, 0xE007F ],\n    [ 0xE0100, 0xE01EF ]\n]\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2N3aWR0aC9jb21iaW5pbmcuanM/YTcyZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3djd2lkdGgvY29tYmluaW5nLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBbXG4gICAgWyAweDAzMDAsIDB4MDM2RiBdLCBbIDB4MDQ4MywgMHgwNDg2IF0sIFsgMHgwNDg4LCAweDA0ODkgXSxcbiAgICBbIDB4MDU5MSwgMHgwNUJEIF0sIFsgMHgwNUJGLCAweDA1QkYgXSwgWyAweDA1QzEsIDB4MDVDMiBdLFxuICAgIFsgMHgwNUM0LCAweDA1QzUgXSwgWyAweDA1QzcsIDB4MDVDNyBdLCBbIDB4MDYwMCwgMHgwNjAzIF0sXG4gICAgWyAweDA2MTAsIDB4MDYxNSBdLCBbIDB4MDY0QiwgMHgwNjVFIF0sIFsgMHgwNjcwLCAweDA2NzAgXSxcbiAgICBbIDB4MDZENiwgMHgwNkU0IF0sIFsgMHgwNkU3LCAweDA2RTggXSwgWyAweDA2RUEsIDB4MDZFRCBdLFxuICAgIFsgMHgwNzBGLCAweDA3MEYgXSwgWyAweDA3MTEsIDB4MDcxMSBdLCBbIDB4MDczMCwgMHgwNzRBIF0sXG4gICAgWyAweDA3QTYsIDB4MDdCMCBdLCBbIDB4MDdFQiwgMHgwN0YzIF0sIFsgMHgwOTAxLCAweDA5MDIgXSxcbiAgICBbIDB4MDkzQywgMHgwOTNDIF0sIFsgMHgwOTQxLCAweDA5NDggXSwgWyAweDA5NEQsIDB4MDk0RCBdLFxuICAgIFsgMHgwOTUxLCAweDA5NTQgXSwgWyAweDA5NjIsIDB4MDk2MyBdLCBbIDB4MDk4MSwgMHgwOTgxIF0sXG4gICAgWyAweDA5QkMsIDB4MDlCQyBdLCBbIDB4MDlDMSwgMHgwOUM0IF0sIFsgMHgwOUNELCAweDA5Q0QgXSxcbiAgICBbIDB4MDlFMiwgMHgwOUUzIF0sIFsgMHgwQTAxLCAweDBBMDIgXSwgWyAweDBBM0MsIDB4MEEzQyBdLFxuICAgIFsgMHgwQTQxLCAweDBBNDIgXSwgWyAweDBBNDcsIDB4MEE0OCBdLCBbIDB4MEE0QiwgMHgwQTREIF0sXG4gICAgWyAweDBBNzAsIDB4MEE3MSBdLCBbIDB4MEE4MSwgMHgwQTgyIF0sIFsgMHgwQUJDLCAweDBBQkMgXSxcbiAgICBbIDB4MEFDMSwgMHgwQUM1IF0sIFsgMHgwQUM3LCAweDBBQzggXSwgWyAweDBBQ0QsIDB4MEFDRCBdLFxuICAgIFsgMHgwQUUyLCAweDBBRTMgXSwgWyAweDBCMDEsIDB4MEIwMSBdLCBbIDB4MEIzQywgMHgwQjNDIF0sXG4gICAgWyAweDBCM0YsIDB4MEIzRiBdLCBbIDB4MEI0MSwgMHgwQjQzIF0sIFsgMHgwQjRELCAweDBCNEQgXSxcbiAgICBbIDB4MEI1NiwgMHgwQjU2IF0sIFsgMHgwQjgyLCAweDBCODIgXSwgWyAweDBCQzAsIDB4MEJDMCBdLFxuICAgIFsgMHgwQkNELCAweDBCQ0QgXSwgWyAweDBDM0UsIDB4MEM0MCBdLCBbIDB4MEM0NiwgMHgwQzQ4IF0sXG4gICAgWyAweDBDNEEsIDB4MEM0RCBdLCBbIDB4MEM1NSwgMHgwQzU2IF0sIFsgMHgwQ0JDLCAweDBDQkMgXSxcbiAgICBbIDB4MENCRiwgMHgwQ0JGIF0sIFsgMHgwQ0M2LCAweDBDQzYgXSwgWyAweDBDQ0MsIDB4MENDRCBdLFxuICAgIFsgMHgwQ0UyLCAweDBDRTMgXSwgWyAweDBENDEsIDB4MEQ0MyBdLCBbIDB4MEQ0RCwgMHgwRDREIF0sXG4gICAgWyAweDBEQ0EsIDB4MERDQSBdLCBbIDB4MEREMiwgMHgwREQ0IF0sIFsgMHgwREQ2LCAweDBERDYgXSxcbiAgICBbIDB4MEUzMSwgMHgwRTMxIF0sIFsgMHgwRTM0LCAweDBFM0EgXSwgWyAweDBFNDcsIDB4MEU0RSBdLFxuICAgIFsgMHgwRUIxLCAweDBFQjEgXSwgWyAweDBFQjQsIDB4MEVCOSBdLCBbIDB4MEVCQiwgMHgwRUJDIF0sXG4gICAgWyAweDBFQzgsIDB4MEVDRCBdLCBbIDB4MEYxOCwgMHgwRjE5IF0sIFsgMHgwRjM1LCAweDBGMzUgXSxcbiAgICBbIDB4MEYzNywgMHgwRjM3IF0sIFsgMHgwRjM5LCAweDBGMzkgXSwgWyAweDBGNzEsIDB4MEY3RSBdLFxuICAgIFsgMHgwRjgwLCAweDBGODQgXSwgWyAweDBGODYsIDB4MEY4NyBdLCBbIDB4MEY5MCwgMHgwRjk3IF0sXG4gICAgWyAweDBGOTksIDB4MEZCQyBdLCBbIDB4MEZDNiwgMHgwRkM2IF0sIFsgMHgxMDJELCAweDEwMzAgXSxcbiAgICBbIDB4MTAzMiwgMHgxMDMyIF0sIFsgMHgxMDM2LCAweDEwMzcgXSwgWyAweDEwMzksIDB4MTAzOSBdLFxuICAgIFsgMHgxMDU4LCAweDEwNTkgXSwgWyAweDExNjAsIDB4MTFGRiBdLCBbIDB4MTM1RiwgMHgxMzVGIF0sXG4gICAgWyAweDE3MTIsIDB4MTcxNCBdLCBbIDB4MTczMiwgMHgxNzM0IF0sIFsgMHgxNzUyLCAweDE3NTMgXSxcbiAgICBbIDB4MTc3MiwgMHgxNzczIF0sIFsgMHgxN0I0LCAweDE3QjUgXSwgWyAweDE3QjcsIDB4MTdCRCBdLFxuICAgIFsgMHgxN0M2LCAweDE3QzYgXSwgWyAweDE3QzksIDB4MTdEMyBdLCBbIDB4MTdERCwgMHgxN0REIF0sXG4gICAgWyAweDE4MEIsIDB4MTgwRCBdLCBbIDB4MThBOSwgMHgxOEE5IF0sIFsgMHgxOTIwLCAweDE5MjIgXSxcbiAgICBbIDB4MTkyNywgMHgxOTI4IF0sIFsgMHgxOTMyLCAweDE5MzIgXSwgWyAweDE5MzksIDB4MTkzQiBdLFxuICAgIFsgMHgxQTE3LCAweDFBMTggXSwgWyAweDFCMDAsIDB4MUIwMyBdLCBbIDB4MUIzNCwgMHgxQjM0IF0sXG4gICAgWyAweDFCMzYsIDB4MUIzQSBdLCBbIDB4MUIzQywgMHgxQjNDIF0sIFsgMHgxQjQyLCAweDFCNDIgXSxcbiAgICBbIDB4MUI2QiwgMHgxQjczIF0sIFsgMHgxREMwLCAweDFEQ0EgXSwgWyAweDFERkUsIDB4MURGRiBdLFxuICAgIFsgMHgyMDBCLCAweDIwMEYgXSwgWyAweDIwMkEsIDB4MjAyRSBdLCBbIDB4MjA2MCwgMHgyMDYzIF0sXG4gICAgWyAweDIwNkEsIDB4MjA2RiBdLCBbIDB4MjBEMCwgMHgyMEVGIF0sIFsgMHgzMDJBLCAweDMwMkYgXSxcbiAgICBbIDB4MzA5OSwgMHgzMDlBIF0sIFsgMHhBODA2LCAweEE4MDYgXSwgWyAweEE4MEIsIDB4QTgwQiBdLFxuICAgIFsgMHhBODI1LCAweEE4MjYgXSwgWyAweEZCMUUsIDB4RkIxRSBdLCBbIDB4RkUwMCwgMHhGRTBGIF0sXG4gICAgWyAweEZFMjAsIDB4RkUyMyBdLCBbIDB4RkVGRiwgMHhGRUZGIF0sIFsgMHhGRkY5LCAweEZGRkIgXSxcbiAgICBbIDB4MTBBMDEsIDB4MTBBMDMgXSwgWyAweDEwQTA1LCAweDEwQTA2IF0sIFsgMHgxMEEwQywgMHgxMEEwRiBdLFxuICAgIFsgMHgxMEEzOCwgMHgxMEEzQSBdLCBbIDB4MTBBM0YsIDB4MTBBM0YgXSwgWyAweDFEMTY3LCAweDFEMTY5IF0sXG4gICAgWyAweDFEMTczLCAweDFEMTgyIF0sIFsgMHgxRDE4NSwgMHgxRDE4QiBdLCBbIDB4MUQxQUEsIDB4MUQxQUQgXSxcbiAgICBbIDB4MUQyNDIsIDB4MUQyNDQgXSwgWyAweEUwMDAxLCAweEUwMDAxIF0sIFsgMHhFMDAyMCwgMHhFMDA3RiBdLFxuICAgIFsgMHhFMDEwMCwgMHhFMDFFRiBdXG5dXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/wcwidth/combining.js\n");

/***/ }),

/***/ "./node_modules/wcwidth/index.js":
/*!***************************************!*\
  !*** ./node_modules/wcwidth/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar defaults = __webpack_require__(/*! defaults */ \"./node_modules/defaults/index.js\")\nvar combining = __webpack_require__(/*! ./combining */ \"./node_modules/wcwidth/combining.js\")\n\nvar DEFAULTS = {\n  nul: 0,\n  control: 0\n}\n\nmodule.exports = function wcwidth(str) {\n  return wcswidth(str, DEFAULTS)\n}\n\nmodule.exports.config = function(opts) {\n  opts = defaults(opts || {}, DEFAULTS)\n  return function wcwidth(str) {\n    return wcswidth(str, opts)\n  }\n}\n\n/*\n *  The following functions define the column width of an ISO 10646\n *  character as follows:\n *  - The null character (U+0000) has a column width of 0.\n *  - Other C0/C1 control characters and DEL will lead to a return value\n *    of -1.\n *  - Non-spacing and enclosing combining characters (general category\n *    code Mn or Me in the\n *    Unicode database) have a column width of 0.\n *  - SOFT HYPHEN (U+00AD) has a column width of 1.\n *  - Other format characters (general category code Cf in the Unicode\n *    database) and ZERO WIDTH\n *    SPACE (U+200B) have a column width of 0.\n *  - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)\n *    have a column width of 0.\n *  - Spacing characters in the East Asian Wide (W) or East Asian\n *    Full-width (F) category as\n *    defined in Unicode Technical Report #11 have a column width of 2.\n *  - All remaining characters (including all printable ISO 8859-1 and\n *    WGL4 characters, Unicode control characters, etc.) have a column\n *    width of 1.\n *  This implementation assumes that characters are encoded in ISO 10646.\n*/\n\nfunction wcswidth(str, opts) {\n  if (typeof str !== 'string') return wcwidth(str, opts)\n\n  var s = 0\n  for (var i = 0; i < str.length; i++) {\n    var n = wcwidth(str.charCodeAt(i), opts)\n    if (n < 0) return -1\n    s += n\n  }\n\n  return s\n}\n\nfunction wcwidth(ucs, opts) {\n  // test for 8-bit control characters\n  if (ucs === 0) return opts.nul\n  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0)) return opts.control\n\n  // binary search in table of non-spacing characters\n  if (bisearch(ucs)) return 0\n\n  // if we arrive here, ucs is not a combining or C0/C1 control character\n  return 1 +\n      (ucs >= 0x1100 &&\n       (ucs <= 0x115f ||                       // Hangul Jamo init. consonants\n        ucs == 0x2329 || ucs == 0x232a ||\n        (ucs >= 0x2e80 && ucs <= 0xa4cf &&\n         ucs != 0x303f) ||                     // CJK ... Yi\n        (ucs >= 0xac00 && ucs <= 0xd7a3) ||    // Hangul Syllables\n        (ucs >= 0xf900 && ucs <= 0xfaff) ||    // CJK Compatibility Ideographs\n        (ucs >= 0xfe10 && ucs <= 0xfe19) ||    // Vertical forms\n        (ucs >= 0xfe30 && ucs <= 0xfe6f) ||    // CJK Compatibility Forms\n        (ucs >= 0xff00 && ucs <= 0xff60) ||    // Fullwidth Forms\n        (ucs >= 0xffe0 && ucs <= 0xffe6) ||\n        (ucs >= 0x20000 && ucs <= 0x2fffd) ||\n        (ucs >= 0x30000 && ucs <= 0x3fffd)));\n}\n\nfunction bisearch(ucs) {\n  var min = 0\n  var max = combining.length - 1\n  var mid\n\n  if (ucs < combining[0][0] || ucs > combining[max][1]) return false\n\n  while (max >= min) {\n    mid = Math.floor((min + max) / 2)\n    if (ucs > combining[mid][1]) min = mid + 1\n    else if (ucs < combining[mid][0]) max = mid - 1\n    else return true\n  }\n\n  return false\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2N3aWR0aC9pbmRleC5qcz9mNDQ1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxrREFBVTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3REFBYTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3djd2lkdGgvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCdkZWZhdWx0cycpXG52YXIgY29tYmluaW5nID0gcmVxdWlyZSgnLi9jb21iaW5pbmcnKVxuXG52YXIgREVGQVVMVFMgPSB7XG4gIG51bDogMCxcbiAgY29udHJvbDogMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdjd2lkdGgoc3RyKSB7XG4gIHJldHVybiB3Y3N3aWR0aChzdHIsIERFRkFVTFRTKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5jb25maWcgPSBmdW5jdGlvbihvcHRzKSB7XG4gIG9wdHMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCBERUZBVUxUUylcbiAgcmV0dXJuIGZ1bmN0aW9uIHdjd2lkdGgoc3RyKSB7XG4gICAgcmV0dXJuIHdjc3dpZHRoKHN0ciwgb3B0cylcbiAgfVxufVxuXG4vKlxuICogIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGRlZmluZSB0aGUgY29sdW1uIHdpZHRoIG9mIGFuIElTTyAxMDY0NlxuICogIGNoYXJhY3RlciBhcyBmb2xsb3dzOlxuICogIC0gVGhlIG51bGwgY2hhcmFjdGVyIChVKzAwMDApIGhhcyBhIGNvbHVtbiB3aWR0aCBvZiAwLlxuICogIC0gT3RoZXIgQzAvQzEgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCBERUwgd2lsbCBsZWFkIHRvIGEgcmV0dXJuIHZhbHVlXG4gKiAgICBvZiAtMS5cbiAqICAtIE5vbi1zcGFjaW5nIGFuZCBlbmNsb3NpbmcgY29tYmluaW5nIGNoYXJhY3RlcnMgKGdlbmVyYWwgY2F0ZWdvcnlcbiAqICAgIGNvZGUgTW4gb3IgTWUgaW4gdGhlXG4gKiAgICBVbmljb2RlIGRhdGFiYXNlKSBoYXZlIGEgY29sdW1uIHdpZHRoIG9mIDAuXG4gKiAgLSBTT0ZUIEhZUEhFTiAoVSswMEFEKSBoYXMgYSBjb2x1bW4gd2lkdGggb2YgMS5cbiAqICAtIE90aGVyIGZvcm1hdCBjaGFyYWN0ZXJzIChnZW5lcmFsIGNhdGVnb3J5IGNvZGUgQ2YgaW4gdGhlIFVuaWNvZGVcbiAqICAgIGRhdGFiYXNlKSBhbmQgWkVSTyBXSURUSFxuICogICAgU1BBQ0UgKFUrMjAwQikgaGF2ZSBhIGNvbHVtbiB3aWR0aCBvZiAwLlxuICogIC0gSGFuZ3VsIEphbW8gbWVkaWFsIHZvd2VscyBhbmQgZmluYWwgY29uc29uYW50cyAoVSsxMTYwLVUrMTFGRilcbiAqICAgIGhhdmUgYSBjb2x1bW4gd2lkdGggb2YgMC5cbiAqICAtIFNwYWNpbmcgY2hhcmFjdGVycyBpbiB0aGUgRWFzdCBBc2lhbiBXaWRlIChXKSBvciBFYXN0IEFzaWFuXG4gKiAgICBGdWxsLXdpZHRoIChGKSBjYXRlZ29yeSBhc1xuICogICAgZGVmaW5lZCBpbiBVbmljb2RlIFRlY2huaWNhbCBSZXBvcnQgIzExIGhhdmUgYSBjb2x1bW4gd2lkdGggb2YgMi5cbiAqICAtIEFsbCByZW1haW5pbmcgY2hhcmFjdGVycyAoaW5jbHVkaW5nIGFsbCBwcmludGFibGUgSVNPIDg4NTktMSBhbmRcbiAqICAgIFdHTDQgY2hhcmFjdGVycywgVW5pY29kZSBjb250cm9sIGNoYXJhY3RlcnMsIGV0Yy4pIGhhdmUgYSBjb2x1bW5cbiAqICAgIHdpZHRoIG9mIDEuXG4gKiAgVGhpcyBpbXBsZW1lbnRhdGlvbiBhc3N1bWVzIHRoYXQgY2hhcmFjdGVycyBhcmUgZW5jb2RlZCBpbiBJU08gMTA2NDYuXG4qL1xuXG5mdW5jdGlvbiB3Y3N3aWR0aChzdHIsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSByZXR1cm4gd2N3aWR0aChzdHIsIG9wdHMpXG5cbiAgdmFyIHMgPSAwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG4gPSB3Y3dpZHRoKHN0ci5jaGFyQ29kZUF0KGkpLCBvcHRzKVxuICAgIGlmIChuIDwgMCkgcmV0dXJuIC0xXG4gICAgcyArPSBuXG4gIH1cblxuICByZXR1cm4gc1xufVxuXG5mdW5jdGlvbiB3Y3dpZHRoKHVjcywgb3B0cykge1xuICAvLyB0ZXN0IGZvciA4LWJpdCBjb250cm9sIGNoYXJhY3RlcnNcbiAgaWYgKHVjcyA9PT0gMCkgcmV0dXJuIG9wdHMubnVsXG4gIGlmICh1Y3MgPCAzMiB8fCAodWNzID49IDB4N2YgJiYgdWNzIDwgMHhhMCkpIHJldHVybiBvcHRzLmNvbnRyb2xcblxuICAvLyBiaW5hcnkgc2VhcmNoIGluIHRhYmxlIG9mIG5vbi1zcGFjaW5nIGNoYXJhY3RlcnNcbiAgaWYgKGJpc2VhcmNoKHVjcykpIHJldHVybiAwXG5cbiAgLy8gaWYgd2UgYXJyaXZlIGhlcmUsIHVjcyBpcyBub3QgYSBjb21iaW5pbmcgb3IgQzAvQzEgY29udHJvbCBjaGFyYWN0ZXJcbiAgcmV0dXJuIDEgK1xuICAgICAgKHVjcyA+PSAweDExMDAgJiZcbiAgICAgICAodWNzIDw9IDB4MTE1ZiB8fCAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZ3VsIEphbW8gaW5pdC4gY29uc29uYW50c1xuICAgICAgICB1Y3MgPT0gMHgyMzI5IHx8IHVjcyA9PSAweDIzMmEgfHxcbiAgICAgICAgKHVjcyA+PSAweDJlODAgJiYgdWNzIDw9IDB4YTRjZiAmJlxuICAgICAgICAgdWNzICE9IDB4MzAzZikgfHwgICAgICAgICAgICAgICAgICAgICAvLyBDSksgLi4uIFlpXG4gICAgICAgICh1Y3MgPj0gMHhhYzAwICYmIHVjcyA8PSAweGQ3YTMpIHx8ICAgIC8vIEhhbmd1bCBTeWxsYWJsZXNcbiAgICAgICAgKHVjcyA+PSAweGY5MDAgJiYgdWNzIDw9IDB4ZmFmZikgfHwgICAgLy8gQ0pLIENvbXBhdGliaWxpdHkgSWRlb2dyYXBoc1xuICAgICAgICAodWNzID49IDB4ZmUxMCAmJiB1Y3MgPD0gMHhmZTE5KSB8fCAgICAvLyBWZXJ0aWNhbCBmb3Jtc1xuICAgICAgICAodWNzID49IDB4ZmUzMCAmJiB1Y3MgPD0gMHhmZTZmKSB8fCAgICAvLyBDSksgQ29tcGF0aWJpbGl0eSBGb3Jtc1xuICAgICAgICAodWNzID49IDB4ZmYwMCAmJiB1Y3MgPD0gMHhmZjYwKSB8fCAgICAvLyBGdWxsd2lkdGggRm9ybXNcbiAgICAgICAgKHVjcyA+PSAweGZmZTAgJiYgdWNzIDw9IDB4ZmZlNikgfHxcbiAgICAgICAgKHVjcyA+PSAweDIwMDAwICYmIHVjcyA8PSAweDJmZmZkKSB8fFxuICAgICAgICAodWNzID49IDB4MzAwMDAgJiYgdWNzIDw9IDB4M2ZmZmQpKSk7XG59XG5cbmZ1bmN0aW9uIGJpc2VhcmNoKHVjcykge1xuICB2YXIgbWluID0gMFxuICB2YXIgbWF4ID0gY29tYmluaW5nLmxlbmd0aCAtIDFcbiAgdmFyIG1pZFxuXG4gIGlmICh1Y3MgPCBjb21iaW5pbmdbMF1bMF0gfHwgdWNzID4gY29tYmluaW5nW21heF1bMV0pIHJldHVybiBmYWxzZVxuXG4gIHdoaWxlIChtYXggPj0gbWluKSB7XG4gICAgbWlkID0gTWF0aC5mbG9vcigobWluICsgbWF4KSAvIDIpXG4gICAgaWYgKHVjcyA+IGNvbWJpbmluZ1ttaWRdWzFdKSBtaW4gPSBtaWQgKyAxXG4gICAgZWxzZSBpZiAodWNzIDwgY29tYmluaW5nW21pZF1bMF0pIG1heCA9IG1pZCAtIDFcbiAgICBlbHNlIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/wcwidth/index.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/ResumeSeptember2019.pdf":
/*!*************************************!*\
  !*** ./src/ResumeSeptember2019.pdf ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"3bc7d2a0e90773dd7953722554534f76.pdf\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvUmVzdW1lU2VwdGVtYmVyMjAxOS5wZGY/Zjk4ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFlLG9GQUF1Qix5Q0FBeUMiLCJmaWxlIjoiLi9zcmMvUmVzdW1lU2VwdGVtYmVyMjAxOS5wZGYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiM2JjN2QyYTBlOTA3NzNkZDc5NTM3MjI1NTQ1MzRmNzYucGRmXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/ResumeSeptember2019.pdf\n");

/***/ }),

/***/ "./src/img/close.png":
/*!***************************!*\
  !*** ./src/img/close.png ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"40c5c8dcab0474b87cbf9f4e2e295a1e.png\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL2Nsb3NlLnBuZz8yZTg2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQWUsb0ZBQXVCLHlDQUF5QyIsImZpbGUiOiIuL3NyYy9pbWcvY2xvc2UucG5nLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjQwYzVjOGRjYWIwNDc0Yjg3Y2JmOWY0ZTJlMjk1YTFlLnBuZ1wiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/img/close.png\n");

/***/ }),

/***/ "./src/img/fullscreen.png":
/*!********************************!*\
  !*** ./src/img/fullscreen.png ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"8967cadca1d6fcf33a8d76a5bc93b2ca.png\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL2Z1bGxzY3JlZW4ucG5nPzQ3MDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBZSxvRkFBdUIseUNBQXlDIiwiZmlsZSI6Ii4vc3JjL2ltZy9mdWxsc2NyZWVuLnBuZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI4OTY3Y2FkY2ExZDZmY2YzM2E4ZDc2YTViYzkzYjJjYS5wbmdcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/img/fullscreen.png\n");

/***/ }),

/***/ "./src/img/minimize.png":
/*!******************************!*\
  !*** ./src/img/minimize.png ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"c9802104f1d668fc00f71a7392395ae3.png\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL21pbmltaXplLnBuZz9kNWJjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQWUsb0ZBQXVCLHlDQUF5QyIsImZpbGUiOiIuL3NyYy9pbWcvbWluaW1pemUucG5nLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImM5ODAyMTA0ZjFkNjY4ZmMwMGY3MWE3MzkyMzk1YWUzLnBuZ1wiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/img/minimize.png\n");

/***/ }),

/***/ "./src/img/powerOff.png":
/*!******************************!*\
  !*** ./src/img/powerOff.png ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"2d4320cf4b37e7636310d85cdb0bbdfd.png\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL3Bvd2VyT2ZmLnBuZz8yMjYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQWUsb0ZBQXVCLHlDQUF5QyIsImZpbGUiOiIuL3NyYy9pbWcvcG93ZXJPZmYucG5nLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIjJkNDMyMGNmNGIzN2U3NjM2MzEwZDg1Y2RiMGJiZGZkLnBuZ1wiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/img/powerOff.png\n");

/***/ }),

/***/ "./src/img/powerOn.png":
/*!*****************************!*\
  !*** ./src/img/powerOn.png ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"8d7e761346476ac33ec8294d27c63aa5.png\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL3Bvd2VyT24ucG5nPzYxZmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBZSxvRkFBdUIseUNBQXlDIiwiZmlsZSI6Ii4vc3JjL2ltZy9wb3dlck9uLnBuZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI4ZDdlNzYxMzQ2NDc2YWMzM2VjODI5NGQyN2M2M2FhNS5wbmdcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/img/powerOn.png\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var jquery_terminal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery.terminal */ \"./node_modules/jquery.terminal/js/jquery.terminal.js\");\n/* harmony import */ var jquery_terminal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery_terminal__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_jquery_terminal_css_jquery_terminal_min_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/jquery.terminal/css/jquery.terminal.min.css */ \"./node_modules/jquery.terminal/css/jquery.terminal.min.css\");\n/* harmony import */ var _node_modules_jquery_terminal_css_jquery_terminal_min_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_jquery_terminal_css_jquery_terminal_min_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styles.css */ \"./src/styles.css\");\n/* harmony import */ var _styles_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_css__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _img_close_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./img/close.png */ \"./src/img/close.png\");\n/* harmony import */ var _img_fullscreen_png__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./img/fullscreen.png */ \"./src/img/fullscreen.png\");\n/* harmony import */ var _img_minimize_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./img/minimize.png */ \"./src/img/minimize.png\");\n/* harmony import */ var _img_powerOff_png__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./img/powerOff.png */ \"./src/img/powerOff.png\");\n/* harmony import */ var _img_powerOn_png__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./img/powerOn.png */ \"./src/img/powerOn.png\");\n/* harmony import */ var _ResumeSeptember2019_pdf__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ResumeSeptember2019.pdf */ \"./src/ResumeSeptember2019.pdf\");\n\n\n\n\n\n\n\n\n\nvar elep = document.getElementById('resume');\nelep.href = _ResumeSeptember2019_pdf__WEBPACK_IMPORTED_MODULE_8__[\"default\"];\nvar ele = document.getElementById('img1');\nele.src = _img_close_png__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\nvar ele2 = document.getElementById('img2');\nele2.src = _img_fullscreen_png__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\nvar ele3 = document.getElementById('img3');\nele3.src = _img_minimize_png__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\nvar ele4 = document.getElementById('img4');\nvar ele5 = document.getElementById('img5');\nele4.src = _img_powerOn_png__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\nele5.src = _img_powerOff_png__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\nvar intro = \"I recommend accessing this site on a computer. There are still mobile version bugs\";\n\nif (window.innerWidth >= 1007) {\n  intro = \"\\n  __  __ _      _                _   _                                           _        \\n |  \\\\/  (_)    | |              | | | |                                         | |       \\n | \\\\  / |_  ___| |__   __ _  ___| | | |     __ _ _ __ _ __ __ _  __ _ _   _  ___| |_ __ _ \\n | |\\\\/| | |/ __| '_ \\\\ / _` |/ _ \\\\ | | |    / _` | '__| '__/ _` |/ _` | | | |/ _ \\\\ __/ _` |\\n | |  | | | (__| | | | (_| |  __/ | | |___| (_| | |  | | | (_| | (_| | |_| |  __/ || (_| |\\n |_|  |_|_|\\\\___|_| |_|\\\\__,_|\\\\___|_| |______\\\\__,_|_|  |_|  \\\\__,_|\\\\__, |\\\\__,_|\\\\___|\\\\__\\\\__,_|\\n                                                                 __/ |                    \\n                                                                |___/                                                                                      \\n\";\n}\n\nvar wait = false;\nvar scanlines = $('.scanlines');\nvar tv = $('.tv');\nvar term = $('#term').terminal(function (command, term) {\n  console.log(\"enter\");\n\n  if (command.match(/^\\s*exit\\s*$/)) {\n    $('.tv').addClass('collapse');\n    term.disable();\n  } else if (command !== '') {\n    processCommand(command, term);\n  } else if (command === '') {\n    holdHistory.push({\n      mess: 'V://> ',\n      color: '#AAAAAA'\n    });\n  }\n}, {\n  name: 'js_demo',\n  exit: false,\n  enabled: true,\n  pauseEvents: false,\n  softPause: false,\n  onInit: function onInit() {\n    set_size();\n  },\n  onFocus: function onFocus() {\n    countLetter2 = 1000;\n    countLetter = 1000;\n    countLoops = 1000;\n    term.clear();\n    term.echo(intro);\n    setAllLines();\n    term.resume();\n  },\n  onBlur: function onBlur() {\n    countLetter2 = 1000;\n    countLetter = 1000;\n    countLoops = 1000;\n    term.clear();\n    term.echo(intro);\n    setAllLines();\n    term.resume();\n  },\n  prompt: 'V://> ',\n  greetings: intro\n});\nterm.enable();\nterm.focus(true);\n$(document).ready(function () {\n  $('.old').addClass('runAnim');\n  $(\"img.img5\").css(\"visibility\", \"hidden\");\n  $(\"img.img4\").on('click', function (e) {\n    e.preventDefault();\n    $('.tv').addClass('collapse');\n    term.disable();\n    $('.old').removeClass('runAnim');\n    $(\"img.img4\").css(\"visibility\", \"hidden\");\n    $(\"img.img5\").css(\"visibility\", \"visible\");\n  }); //red button\n\n  $(\"img.img5\").on('click', function (e) {\n    e.preventDefault(); // animation: flicker 0.12s infinite\n\n    $('.tv').removeClass('collapse'); // $('.tv').addClass('expand');\n\n    $('.old').addClass('runAnim');\n    term.enable();\n    $(\"img.img5\").css(\"visibility\", \"hidden\");\n    $(\"img.img4\").css(\"visibility\", \"visible\");\n  }); //green button\n\n  term.pause();\n  testTime(allIntro); //printLine(allIntro[0]);\n\n  $('a.help1').on('click', function (e) {\n    // term.insert(\"education\");\n    countLetter2 = 1000;\n    countLetter = 1000;\n    countLoops = 1000;\n    term.clear();\n    term.echo(intro);\n    setAllLines(); // term.resume();\n\n    setTimeout(function () {\n      if (!wait) {\n        term.echo(\"[[b;\".concat('#AAAAAA', \";]\", 'V://> Education', \"]\"));\n        processCommand(\"Education\", term);\n      }\n    }, 500); // term.exec(\"education\", true)\n\n    e.preventDefault();\n  });\n  $('a.help2').on('click', function (e) {\n    countLetter2 = 1000;\n    countLetter = 1000;\n    countLoops = 1000;\n    term.clear();\n    term.echo(intro);\n    setAllLines();\n    setTimeout(function () {\n      if (!wait) {\n        term.echo(\"[[b;\".concat('#AAAAAA', \";]\", 'V://> Work', \"]\")); // wait = false;\n\n        processCommand(\"Work\", term);\n      }\n    }, 500);\n    e.preventDefault();\n  });\n  $('a.help3').on('click', function (e) {\n    countLetter2 = 1000;\n    countLetter = 1000;\n    countLoops = 1000;\n    term.clear();\n    term.echo(intro);\n    setAllLines(); // term.resume();\n\n    setTimeout(function () {\n      if (!wait) {\n        term.echo(\"[[b;\".concat('#AAAAAA', \";]\", 'V://> Languages', \"]\")); // wait = false;\n\n        processCommand(\"Languages\", term);\n      }\n    }, 500);\n    e.preventDefault();\n  });\n  $('a.help4').on('click', function (e) {\n    countLetter2 = 1000;\n    countLetter = 1000;\n    countLoops = 1000;\n    term.clear();\n    term.echo(intro);\n    setAllLines(); // term.resume();\n\n    setTimeout(function () {\n      if (!wait) {\n        term.echo(\"[[b;\".concat('#AAAAAA', \";]\", 'V://> Github', \"]\")); // wait = false;\n\n        processCommand(\"Github\", term);\n      }\n    }, 500);\n    e.preventDefault();\n  });\n  $('a.help5').on('click', function (e) {\n    countLetter2 = 1000;\n    countLetter = 1000;\n    countLoops = 1000;\n    term.clear();\n    term.echo(intro);\n    setAllLines(); // term.resume();\n\n    setTimeout(function () {\n      if (!wait) {\n        term.echo(\"[[b;\".concat('#AAAAAA', \";]\", 'V://> LinkedIn', \"]\")); // wait = false;\n\n        processCommand(\"Linkedin\", term);\n      }\n    }, 500);\n    e.preventDefault();\n  });\n  $('a.help6').on('click', function (e) {\n    countLetter2 = 1000;\n    countLetter = 1000;\n    countLoops = 1000;\n    term.clear();\n    term.echo(intro);\n    setAllLines();\n    setTimeout(function () {\n      if (!wait) {\n        term.echo(\"[[b;\".concat('#AAAAAA', \";]\", 'V://> Projects', \"]\")); // wait = false;\n\n        processCommand(\"Projects\", term);\n      }\n    }, 500);\n    e.preventDefault();\n  });\n  $('a.help7').on('click', function (e) {\n    countLetter2 = 1000;\n    countLetter = 1000;\n    countLoops = 1000;\n    term.clear();\n    term.echo(intro);\n    setAllLines();\n    setTimeout(function () {\n      if (!wait) {\n        term.echo(\"[[b;\".concat('#AAAAAA', \";]\", 'V://> About', \"]\")); // wait = false;\n\n        processCommand(\"About\", term);\n      }\n    }, 500);\n    e.preventDefault();\n  });\n});\n\nfunction setAllLines() {\n  for (var i = 0; i < holdHistory.length; i++) {\n    if (!holdHistory[i].hasOwnProperty('mess2')) {\n      term.echo(\"[[b;\".concat(holdHistory[i].color, \";]\").concat(holdHistory[i].mess, \"]\"));\n    } else if (holdHistory[i].hasOwnProperty('mess2')) {\n      term.echo(\"[[b;\".concat(holdHistory[i].color, \";]\").concat(holdHistory[i].mess, \"]\") + \"[[b;\".concat(holdHistory[i].color2, \";]\").concat(holdHistory[i].mess2, \"]\"));\n    }\n  }\n\n  term.resume();\n}\n\nfunction set_size() {\n  // for window height of 170 it should be 2s\n  var height = $(window).height();\n  var width = $(window).width();\n  var time = height * 2 / 170;\n  scanlines[0].style.setProperty(\"--time\", time);\n  tv[0].style.setProperty(\"--width\", width);\n  tv[0].style.setProperty(\"--height\", height);\n}\n\nvar buildWord = \"\";\nvar buildWord2 = \"\";\nvar countLetter = 0;\nvar countLetter2 = 0;\n\nfunction printLine(words) {\n  if (countLetter < 950 && countLetter2 < 950) {\n    setTimeout(function () {\n      if (!words.hasOwnProperty('mess2') && countLetter < words.mess.length) {\n        buildWord += words.mess[countLetter];\n        countLetter++;\n\n        if (countLetter <= 1) {\n          term.echo(\"[[b;\".concat(words.color, \";]\").concat(buildWord, \"]\"));\n          printLine(words);\n        } else if (countLetter >= 2) {\n          term.update(term.last_index(), \"[[b;\".concat(words.color, \";]\").concat(buildWord, \"]\"));\n\n          if (buildWord === words.mess && !runtime) {\n            term.resume();\n          }\n\n          printLine(words);\n        }\n      } else if (words.hasOwnProperty('mess2') && countLetter < words.mess2.length) {\n        if (countLetter <= 0) {\n          buildWord += words.mess[countLetter];\n          countLetter++;\n          term.echo(\"[[b;\".concat(words.color, \";]\").concat(buildWord, \"]\"));\n          printLine(words);\n        } else if (countLetter >= 1 && countLetter < words.mess.length) {\n          buildWord += words.mess[countLetter];\n          countLetter++;\n          term.update(term.last_index(), \"[[b;\".concat(words.color, \";]\").concat(buildWord, \"]\"));\n          printLine(words);\n        } else if (countLetter >= words.mess.length && countLetter2 < words.mess2.length) {\n          buildWord2 += words.mess2[countLetter2];\n          countLetter2++;\n          term.update(term.last_index(), \"[[b;\".concat(words.color, \";]\").concat(words.mess, \"]\") + \"[[b;\".concat(words.color2, \";]\").concat(buildWord2, \"]\"));\n\n          if (buildWord2 === words.mess2 && !runtime) {\n            term.resume();\n          }\n\n          printLine(words);\n        }\n      }\n    }, 15);\n  }\n}\n\nvar yellow = \"#EEFC12\";\nvar red = \"#ce2f2f\";\nvar white = \"#fff\";\nvar runtime = true;\nvar time1 = 500;\nvar countLoops = 0;\nvar waitTime = 26;\nvar holdHistory = [];\n\nfunction resetPrint() {\n  buildWord = \"\";\n  buildWord2 = \"\";\n  countLetter = 0;\n  countLetter2 = 0;\n}\n\nfunction resetCounts() {\n  countLoops = 0;\n  runtime = true;\n}\n\nfunction testTime(allIntro) {\n  if (countLoops >= allIntro.length) {\n    runtime = false;\n    wait = false;\n  }\n\n  if (countLoops === 0) {\n    holdHistory = holdHistory.concat(allIntro);\n    time1 = 500;\n  } else if (countLoops > 950) {\n    runtime = false;\n  } else if (!allIntro[countLoops - 1].hasOwnProperty('mess2') && allIntro[countLoops - 1].mess !== \" \") {\n    time1 = allIntro[countLoops - 1].mess.length * 30;\n  } else if (allIntro[countLoops - 1].mess === \" \") {\n    time1 = 50;\n  } else if (allIntro[countLoops - 1].hasOwnProperty('mess2')) {\n    time1 = (allIntro[countLoops - 1].mess2.length + allIntro[countLoops - 1].mess.length) * waitTime;\n  }\n\n  if (runtime && countLoops < 950) {\n    setTimeout(function () {\n      resetPrint();\n\n      if (countLoops < 950) {\n        printLine(allIntro[countLoops]);\n        countLoops++;\n      }\n\n      testTime(allIntro);\n    }, time1);\n  }\n}\n\nvar allIntro = [{\n  mess: \"Hello And Welcome To My Portfolio\",\n  color: white\n}, {\n  mess: \"For a list of commands type ''help''\",\n  color: white\n}, {\n  mess: \" \",\n  color: white\n}, {\n  mess: \"Here is a general overview of myself\",\n  color: white\n}, {\n  mess: \"Name: \",\n  color: yellow,\n  mess2: \"Michael Larragueta\",\n  color2: white\n}, {\n  mess: \"Location: \",\n  color: yellow,\n  mess2: \"Portland, Oregon\",\n  color2: white\n}, {\n  mess: \"Willing to relocate: \",\n  color: yellow,\n  mess2: \"Yes, within the state of Oregon || Willing to work remotely\",\n  color2: white\n}, {\n  mess: \"Position: \",\n  color: yellow,\n  mess2: \"Junior Web Developer\",\n  color2: white\n}, {\n  mess: \"Skills: \",\n  color: yellow,\n  mess2: \"JavaScript, C#, C++, HTML, CSS, ASP.NET, React, Angular, Jquery, Unity, GIT CLI, React-THREE-Fiber, mySql, Node.js and more\",\n  color2: white\n}, {\n  mess: \"CONTACT INFO\",\n  color: red\n}, {\n  mess: \"Phone: \",\n  color: yellow,\n  mess2: \"(925)451-5515\",\n  color2: white\n}, {\n  mess: \"Email: \",\n  color: yellow,\n  mess2: \"MjLarragueta@gmail.com\",\n  color2: white\n}];\nvar helpCommand = [{\n  mess: \"All Commands: \",\n  color: red\n}, {\n  mess: \"Education: \",\n  color: yellow,\n  mess2: \"Show all education information\",\n  color2: white\n}, {\n  mess: \"Work: \",\n  color: yellow,\n  mess2: \"Show all work experience\",\n  color2: white\n}, {\n  mess: \"Languages: \",\n  color: yellow,\n  mess2: \"Show all of my known programming languages\",\n  color2: white\n}, {\n  mess: \"Github: \",\n  color: yellow,\n  mess2: \"Link to my github profile\",\n  color2: white\n}, {\n  mess: \"LinkedIn: \",\n  color: yellow,\n  mess2: \"Link to my LinkedIn profile\",\n  color2: white\n}, {\n  mess: \"Projects: \",\n  color: yellow,\n  mess2: \"Links to my 3 favorite projects with added descriptions\",\n  color2: white\n}, {\n  mess: \"About: \",\n  color: yellow,\n  mess2: \"About me\",\n  color2: white\n}, {\n  mess: \"Reset: \",\n  color: yellow,\n  mess2: \"Resets terminal page\",\n  color2: white\n}, {\n  mess: \"Exit: \",\n  color: red,\n  mess2: \"Turns terminal off\",\n  color2: white\n}];\nvar educCommand = [{\n  mess: \"Education: \",\n  color: red\n}, {\n  mess: \"Diablo Valley College, Concord CA - C++\",\n  color: yellow\n}, {\n  mess: \"Started: \",\n  color: yellow,\n  mess2: \"September, 2014\",\n  color2: white\n}, {\n  mess: \"Finished: \",\n  color: yellow,\n  mess2: \"June, 2018 \",\n  color2: white\n}, {\n  mess: \"Studied: \",\n  color: yellow,\n  mess2: \"Computer Science\",\n  color2: white\n}, {\n  mess: \" \",\n  color: white\n}, {\n  mess: \"Epicodus, Portland OR - C#/React Track\",\n  color: yellow\n}, {\n  mess: \"Started: \",\n  color: yellow,\n  mess2: \"March 2019\",\n  color2: white\n}, {\n  mess: \"Finsihed: \",\n  color: yellow,\n  mess2: \"September 2019\",\n  color2: white\n}, {\n  mess: \"Studied: \",\n  color: yellow,\n  mess2: \"C#, .NET, React, Jquery, HTML, CSS, JavaScript, Angular ASP.NET, GIT CLI\",\n  color2: white\n}];\nvar unknownCommand = [{\n  mess: \"UNKOWN COMMAND\",\n  color: red\n}, {\n  mess: \"For a list of commands type ''help''\",\n  color: white\n}];\nvar workCommand = [{\n  mess: \"Work History: \",\n  color: red\n}, {\n  mess: \"Invisible Thread, Portland OR\",\n  color: yellow\n}, {\n  mess: \"Title: \",\n  color: yellow,\n  mess2: \"Junior Developer\",\n  color2: white\n}, {\n  mess: \"Started: \",\n  color: yellow,\n  mess2: \"August 2019\",\n  color2: white\n}, {\n  mess: \"Finished: \",\n  color: yellow,\n  mess2: \"October 2019\",\n  color2: white\n}, {\n  mess: \"Details\",\n  color: yellow\n}, {\n  mess: \"  -Re-Built website using React, THREE.js, and React-THREE-Fiber\",\n  color: white\n}, {\n  mess: \"  -Built an augmented reality pathfinding android application using Unity and C#\",\n  color: white\n}, {\n  mess: \"  -Managed Project Workflow and tasks using Trello\",\n  color: white\n}, {\n  mess: \" \",\n  color: white\n}, {\n  mess: \"The Creek Youth Center, Walnut Creek CA\",\n  color: yellow\n}, {\n  mess: \"Title: \",\n  color: yellow,\n  mess2: \"Lead Teachers Aide\",\n  color2: white\n}, {\n  mess: \"Started: \",\n  color: yellow,\n  mess2: \"January 2014\",\n  color2: white\n}, {\n  mess: \"Ended: \",\n  color: yellow,\n  mess2: \"August 2018\",\n  color2: white\n}, {\n  mess: \"Details\",\n  color: yellow\n}, {\n  mess: \"  -Created, planned and executed different learning activities\",\n  color: white\n}, {\n  mess: \"  -Managed and lead groups of 30+ children grade 6th-8th\",\n  color: white\n}, {\n  mess: \"  -Created and ran the tech club where students learned how to build and programArduino based robotics\",\n  color: white\n}];\nvar gitCommand = [{\n  mess: \"https://github.com/toofpaste\",\n  color: red\n}];\nvar linkCommand = [{\n  mess: \"https://www.linkedin.com/in/mlarragueta\",\n  color: red\n}];\nvar langCommand = [{\n  mess: \"C++, Node.js, HTML, Javascript, React, ASP.NET, CSS, jQuery, GIT CLI, AngularJS, Firebase, Webpack, NPM, C#, TypeScript, mySql, MongoDB\",\n  color: white\n}];\nvar aboutCommand = [{\n  mess: \"Born and raised in Concord, California. Out of high school, I attended the University of Nevada Reno where I studied business management. After my second year there I decided that it was not the direction I wanted to go with my career. To save some money I moved back home and attended Diablo Valley College where I discovered my love for computer science. I studied Computer Science there for 4 years. After attempting to afford living in the bay area by working as a valet, I made the decision to move up to Portland and attend Epicodus where I studied a variety of different web development languages. \",\n  color: white\n}];\nvar projCommand = [{\n  mess: \"IBM Watson Connect 4: \",\n  color: yellow\n}, {\n  mess: \"https://github.com/toofpaste/ReactWatsonAPIWorking\",\n  color: white\n}, {\n  mess: \"Details\",\n  color: yellow\n}, {\n  mess: \"  -Written using React for the front end and Node.js to access the watson API\",\n  color: white\n}, {\n  mess: \"  -Using IBM Watson it analyzes a user's tweets and generates a personality profile for them. The Connect 4 AI then uses those personality traits against them in a game of Connect 4\",\n  color: white\n}, {\n  mess: \" \",\n  color: white\n}, {\n  mess: \"Invisible-Thread-Website\",\n  color: yellow\n}, {\n  mess: \"https://github.com/toofpaste/Invisible-Thread-Website\",\n  color: white\n}, {\n  mess: \"Details\",\n  color: yellow\n}, {\n  mess: \"  -Written using React-THREE-Fiber. A React wrapper for THREE.js\",\n  color: white\n}, {\n  mess: \" \",\n  color: white\n}, {\n  mess: \"MultiPlayer Tetris\",\n  color: yellow\n}, {\n  mess: \"https://github.com/toofpaste/MPTetris\",\n  color: white\n}, {\n  mess: \"Details\",\n  color: yellow\n}, {\n  mess: \"  -Written using Javascript, Node.js with CSS and HTML\",\n  color: white\n}, {\n  mess: \"  -A simple Tetris game that drops block shapes down and board while a user tries to move the shapes around to fit the other shapes on. The player tryies to completely fill whole rows of blocks in order to remove them from the game while avoiding filling the game board all the way to the top.\",\n  color: white\n}];\n\nfunction processCommand(command, term) {\n  if (!wait) {\n    var cmd = command.split(\" \");\n    holdHistory.push({\n      mess: \"V://> \".concat(cmd[0]),\n      color: '##AAAAAA'\n    });\n    cmd[0] = cmd[0].toLowerCase();\n\n    if (cmd[0] == \"help\") {\n      wait = true;\n      term.pause();\n      resetPrint();\n      resetCounts();\n      testTime(helpCommand); // return;\n    } else if (cmd[0] == \"education\") {\n      wait = true;\n      term.pause();\n      resetPrint();\n      resetCounts();\n      testTime(educCommand);\n    } else if (cmd[0] == \"work\") {\n      wait = true;\n      term.pause();\n      resetPrint();\n      resetCounts();\n      testTime(workCommand);\n    } else if (cmd[0] == \"github\") {\n      wait = true;\n      term.pause();\n      resetPrint();\n      resetCounts();\n      testTime(gitCommand);\n    } else if (cmd[0] == \"linkedin\") {\n      term.pause();\n      resetPrint();\n      resetCounts();\n      testTime(linkCommand);\n    } else if (cmd[0] == \"languages\") {\n      wait = true;\n      term.pause();\n      resetPrint();\n      resetCounts();\n      testTime(langCommand);\n    } else if (cmd[0] == \"about\") {\n      term.pause();\n      wait = true;\n      resetPrint();\n      resetCounts();\n      testTime(aboutCommand);\n    } else if (cmd[0] == \"projects\") {\n      term.pause();\n      wait = true;\n      resetPrint();\n      resetCounts();\n      testTime(projCommand);\n    } else if (cmd[0] == \"reset\") {\n      term.clear();\n      holdHistory = [];\n      term.echo(intro);\n    } else {\n      term.pause();\n      wait = true;\n      resetPrint();\n      resetCounts();\n      testTime(unknownCommand);\n    }\n  }\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"jquery\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJlbGVwIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImhyZWYiLCJwZCIsImVsZSIsInNyYyIsIkxvZ28iLCJlbGUyIiwiTWF4IiwiZWxlMyIsIk1pbiIsImVsZTQiLCJlbGU1Iiwib2ZmIiwib24iLCJpbnRybyIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJ3YWl0Iiwic2NhbmxpbmVzIiwiJCIsInR2IiwidGVybSIsInRlcm1pbmFsIiwiY29tbWFuZCIsImNvbnNvbGUiLCJsb2ciLCJtYXRjaCIsImFkZENsYXNzIiwiZGlzYWJsZSIsInByb2Nlc3NDb21tYW5kIiwiaG9sZEhpc3RvcnkiLCJwdXNoIiwibWVzcyIsImNvbG9yIiwibmFtZSIsImV4aXQiLCJlbmFibGVkIiwicGF1c2VFdmVudHMiLCJzb2Z0UGF1c2UiLCJvbkluaXQiLCJzZXRfc2l6ZSIsIm9uRm9jdXMiLCJjb3VudExldHRlcjIiLCJjb3VudExldHRlciIsImNvdW50TG9vcHMiLCJjbGVhciIsImVjaG8iLCJzZXRBbGxMaW5lcyIsInJlc3VtZSIsIm9uQmx1ciIsInByb21wdCIsImdyZWV0aW5ncyIsImVuYWJsZSIsImZvY3VzIiwicmVhZHkiLCJjc3MiLCJlIiwicHJldmVudERlZmF1bHQiLCJyZW1vdmVDbGFzcyIsInBhdXNlIiwidGVzdFRpbWUiLCJhbGxJbnRybyIsInNldFRpbWVvdXQiLCJpIiwibGVuZ3RoIiwiaGFzT3duUHJvcGVydHkiLCJjb2xvcjIiLCJtZXNzMiIsImhlaWdodCIsIndpZHRoIiwidGltZSIsInN0eWxlIiwic2V0UHJvcGVydHkiLCJidWlsZFdvcmQiLCJidWlsZFdvcmQyIiwicHJpbnRMaW5lIiwid29yZHMiLCJ1cGRhdGUiLCJsYXN0X2luZGV4IiwicnVudGltZSIsInllbGxvdyIsInJlZCIsIndoaXRlIiwidGltZTEiLCJ3YWl0VGltZSIsInJlc2V0UHJpbnQiLCJyZXNldENvdW50cyIsImNvbmNhdCIsImhlbHBDb21tYW5kIiwiZWR1Y0NvbW1hbmQiLCJ1bmtub3duQ29tbWFuZCIsIndvcmtDb21tYW5kIiwiZ2l0Q29tbWFuZCIsImxpbmtDb21tYW5kIiwibGFuZ0NvbW1hbmQiLCJhYm91dENvbW1hbmQiLCJwcm9qQ29tbWFuZCIsImNtZCIsInNwbGl0IiwidG9Mb3dlckNhc2UiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUEsSUFBSSxHQUFHQyxRQUFRLENBQUNDLGNBQVQsQ0FBd0IsUUFBeEIsQ0FBYjtBQUNBRixJQUFJLENBQUNHLElBQUwsR0FBWUMsZ0VBQVo7QUFDQSxJQUFNQyxHQUFHLEdBQUdKLFFBQVEsQ0FBQ0MsY0FBVCxDQUF3QixNQUF4QixDQUFaO0FBQ0FHLEdBQUcsQ0FBQ0MsR0FBSixHQUFVQyxzREFBVjtBQUNBLElBQU1DLElBQUksR0FBR1AsUUFBUSxDQUFDQyxjQUFULENBQXdCLE1BQXhCLENBQWI7QUFDQU0sSUFBSSxDQUFDRixHQUFMLEdBQVdHLDJEQUFYO0FBQ0EsSUFBTUMsSUFBSSxHQUFHVCxRQUFRLENBQUNDLGNBQVQsQ0FBd0IsTUFBeEIsQ0FBYjtBQUNBUSxJQUFJLENBQUNKLEdBQUwsR0FBV0sseURBQVg7QUFDQSxJQUFNQyxJQUFJLEdBQUdYLFFBQVEsQ0FBQ0MsY0FBVCxDQUF3QixNQUF4QixDQUFiO0FBQ0EsSUFBTVcsSUFBSSxHQUFHWixRQUFRLENBQUNDLGNBQVQsQ0FBd0IsTUFBeEIsQ0FBYjtBQUNBVSxJQUFJLENBQUNOLEdBQUwsR0FBV1Esd0RBQVg7QUFDQUQsSUFBSSxDQUFDUCxHQUFMLEdBQVdTLHlEQUFYO0FBQ0EsSUFBSUMsS0FBSyx1RkFBVDs7QUFDQSxJQUFHQyxNQUFNLENBQUNDLFVBQVAsSUFBcUIsSUFBeEIsRUFBOEI7QUFF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TCxDQUFVaEMsS0FBVjtBQUNELEtBSkssTUFJQTtBQUNKTyxVQUFJLENBQUNzQyxLQUFMO0FBQ0ExQyxVQUFJLEdBQUcsSUFBUDtBQUNBb0UsZ0JBQVU7QUFDVkMsaUJBQVc7QUFDWDFCLGNBQVEsQ0FBQzhCLGNBQUQsQ0FBUjtBQUNEO0FBQ0Y7QUFDRixDIiwiZmlsZSI6Ii4vc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdqcXVlcnkudGVybWluYWwnO1xyXG5pbXBvcnQgJy4uL25vZGVfbW9kdWxlcy9qcXVlcnkudGVybWluYWwvY3NzL2pxdWVyeS50ZXJtaW5hbC5taW4uY3NzJztcclxuaW1wb3J0ICcuL3N0eWxlcy5jc3MnO1xyXG5pbXBvcnQgTG9nbyBmcm9tICcuL2ltZy9jbG9zZS5wbmcnO1xyXG5pbXBvcnQgTWF4IGZyb20gJy4vaW1nL2Z1bGxzY3JlZW4ucG5nJztcclxuaW1wb3J0IE1pbiBmcm9tICcuL2ltZy9taW5pbWl6ZS5wbmcnO1xyXG5pbXBvcnQgb24gZnJvbSAnLi9pbWcvcG93ZXJPZmYucG5nJztcclxuaW1wb3J0IG9mZiBmcm9tICcuL2ltZy9wb3dlck9uLnBuZyc7XHJcbmltcG9ydCBwZCBmcm9tICcuL1Jlc3VtZVNlcHRlbWJlcjIwMTkucGRmJztcclxuY29uc3QgZWxlcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXN1bWUnKTtcclxuZWxlcC5ocmVmID0gcGQ7XHJcbmNvbnN0IGVsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbWcxJyk7XHJcbmVsZS5zcmMgPSBMb2dvO1xyXG5jb25zdCBlbGUyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ltZzInKTtcclxuZWxlMi5zcmMgPSBNYXg7XHJcbmNvbnN0IGVsZTMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW1nMycpO1xyXG5lbGUzLnNyYyA9IE1pbjtcclxuY29uc3QgZWxlNCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbWc0Jyk7XHJcbmNvbnN0IGVsZTUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW1nNScpO1xyXG5lbGU0LnNyYyA9IG9mZjtcclxuZWxlNS5zcmMgPSBvbjtcclxubGV0IGludHJvID0gYEkgcmVjb21tZW5kIGFjY2Vzc2luZyB0aGlzIHNpdGUgb24gYSBjb21wdXRlci4gVGhlcmUgYXJlIHN0aWxsIG1vYmlsZSB2ZXJzaW9uIGJ1Z3NgO1xyXG5pZih3aW5kb3cuaW5uZXJXaWR0aCA+PSAxMDA3KSB7XHJcblxyXG4gIGludHJvID1cclxuICAgIGBcclxuICBfXyAgX18gXyAgICAgIF8gICAgICAgICAgICAgICAgXyAgIF8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXyAgICAgICAgXHJcbiB8ICBcXFxcLyAgKF8pICAgIHwgfCAgICAgICAgICAgICAgfCB8IHwgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB8ICAgICAgIFxyXG4gfCBcXFxcICAvIHxfICBfX198IHxfXyAgIF9fIF8gIF9fX3wgfCB8IHwgICAgIF9fIF8gXyBfXyBfIF9fIF9fIF8gIF9fIF8gXyAgIF8gIF9fX3wgfF8gX18gXyBcclxuIHwgfFxcXFwvfCB8IHwvIF9ffCAnXyBcXFxcIC8gX1xcYCB8LyBfIFxcXFwgfCB8IHwgICAgLyBfXFxgIHwgJ19ffCAnX18vIF9cXGAgfC8gX1xcYCB8IHwgfCB8LyBfIFxcXFwgX18vIF9cXGAgfFxyXG4gfCB8ICB8IHwgfCAoX198IHwgfCB8IChffCB8ICBfXy8gfCB8IHxfX198IChffCB8IHwgIHwgfCB8IChffCB8IChffCB8IHxffCB8ICBfXy8gfHwgKF98IHxcclxuIHxffCAgfF98X3xcXFxcX19ffF98IHxffFxcXFxfXyxffFxcXFxfX198X3wgfF9fX19fX1xcXFxfXyxffF98ICB8X3wgIFxcXFxfXyxffFxcXFxfXywgfFxcXFxfXyxffFxcXFxfX198XFxcXF9fXFxcXF9fLF98XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18vIHwgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfF9fXy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5gO1xyXG59XHJcblxyXG5sZXQgd2FpdCA9IGZhbHNlO1xyXG52YXIgc2NhbmxpbmVzID0gJCgnLnNjYW5saW5lcycpO1xyXG52YXIgdHYgPSAkKCcudHYnKTtcclxudmFyIHRlcm0gPSAkKCcjdGVybScpLnRlcm1pbmFsKGZ1bmN0aW9uIChjb21tYW5kLCB0ZXJtKSB7XHJcbiAgY29uc29sZS5sb2coXCJlbnRlclwiKTtcclxuICBpZiAoY29tbWFuZC5tYXRjaCgvXlxccypleGl0XFxzKiQvKSkge1xyXG4gICAgJCgnLnR2JykuYWRkQ2xhc3MoJ2NvbGxhcHNlJyk7XHJcbiAgICB0ZXJtLmRpc2FibGUoKTtcclxuICB9IGVsc2UgaWYgKGNvbW1hbmQgIT09ICcnKSB7XHJcbiAgICBwcm9jZXNzQ29tbWFuZChjb21tYW5kLCB0ZXJtKTtcclxuICB9ZWxzZSBpZihjb21tYW5kID09PSAnJyl7XHJcbiAgICBob2xkSGlzdG9yeS5wdXNoKHtcclxuICAgICAgbWVzczogJ1Y6Ly8+ICcsXHJcbiAgICAgIGNvbG9yOiAnI0FBQUFBQSdcclxuICAgIH0pO1xyXG4gIH1cclxufSwge1xyXG4gIG5hbWU6ICdqc19kZW1vJyxcclxuICBleGl0OiBmYWxzZSxcclxuICBlbmFibGVkOiB0cnVlLFxyXG4gIHBhdXNlRXZlbnRzOiBmYWxzZSxcclxuICBzb2Z0UGF1c2U6IGZhbHNlLFxyXG4gIG9uSW5pdDogZnVuY3Rpb24gKCkge1xyXG4gICAgc2V0X3NpemUoKTtcclxuICB9LFxyXG4gIG9uRm9jdXM6IGZ1bmN0aW9uKCl7XHJcbiAgICBjb3VudExldHRlcjIgPSAxMDAwO1xyXG4gICAgY291bnRMZXR0ZXIgPSAxMDAwO1xyXG4gICAgY291bnRMb29wcyA9IDEwMDA7XHJcbiAgICB0ZXJtLmNsZWFyKCk7XHJcbiAgICB0ZXJtLmVjaG8oaW50cm8pO1xyXG4gICAgc2V0QWxsTGluZXMoKTtcclxuICAgIHRlcm0ucmVzdW1lKCk7XHJcbiAgfSxcclxuICBvbkJsdXI6IGZ1bmN0aW9uKCl7XHJcbiAgICBjb3VudExldHRlcjIgPSAxMDAwO1xyXG4gICAgY291bnRMZXR0ZXIgPSAxMDAwO1xyXG4gICAgY291bnRMb29wcyA9IDEwMDA7XHJcbiAgICB0ZXJtLmNsZWFyKCk7XHJcbiAgICB0ZXJtLmVjaG8oaW50cm8pO1xyXG4gICAgc2V0QWxsTGluZXMoKTtcclxuICAgIHRlcm0ucmVzdW1lKCk7XHJcbiAgfSxcclxuICBwcm9tcHQ6ICdWOi8vPiAnLFxyXG4gIGdyZWV0aW5nczogaW50cm9cclxufSk7XHJcbnRlcm0uZW5hYmxlKCk7XHJcbnRlcm0uZm9jdXModHJ1ZSk7XHJcbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCl7XHJcbiAgJCgnLm9sZCcpLmFkZENsYXNzKCdydW5BbmltJyk7XHJcbiAgJChgaW1nLmltZzVgKS5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG4gICQoYGltZy5pbWc0YCkub24oJ2NsaWNrJywgZnVuY3Rpb24oZSl7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAkKCcudHYnKS5hZGRDbGFzcygnY29sbGFwc2UnKTtcclxuICAgIHRlcm0uZGlzYWJsZSgpO1xyXG4gICAgJCgnLm9sZCcpLnJlbW92ZUNsYXNzKCdydW5BbmltJyk7XHJcbiAgICAkKGBpbWcuaW1nNGApLmNzcyhcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XHJcbiAgICAkKGBpbWcuaW1nNWApLmNzcyhcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xyXG4gIH0pOyAvL3JlZCBidXR0b25cclxuICAkKGBpbWcuaW1nNWApLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgLy8gYW5pbWF0aW9uOiBmbGlja2VyIDAuMTJzIGluZmluaXRlXHJcbiAgICAkKCcudHYnKS5yZW1vdmVDbGFzcygnY29sbGFwc2UnKTtcclxuICAgIC8vICQoJy50dicpLmFkZENsYXNzKCdleHBhbmQnKTtcclxuICAgICQoJy5vbGQnKS5hZGRDbGFzcygncnVuQW5pbScpO1xyXG4gICAgdGVybS5lbmFibGUoKTtcclxuICAgICQoYGltZy5pbWc1YCkuY3NzKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuICAgICQoYGltZy5pbWc0YCkuY3NzKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcbiAgfSk7IC8vZ3JlZW4gYnV0dG9uXHJcbiAgdGVybS5wYXVzZSgpO1xyXG4gIHRlc3RUaW1lKGFsbEludHJvKTtcclxuICAvL3ByaW50TGluZShhbGxJbnRyb1swXSk7XHJcbiAgJCgnYS5oZWxwMScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICAgIC8vIHRlcm0uaW5zZXJ0KFwiZWR1Y2F0aW9uXCIpO1xyXG4gICAgY291bnRMZXR0ZXIyID0gMTAwMDtcclxuICAgIGNvdW50TGV0dGVyID0gMTAwMDtcclxuICAgIGNvdW50TG9vcHMgPSAxMDAwO1xyXG4gICAgdGVybS5jbGVhcigpO1xyXG4gICAgdGVybS5lY2hvKGludHJvKTtcclxuICAgIHNldEFsbExpbmVzKCk7XHJcbiAgICAvLyB0ZXJtLnJlc3VtZSgpO1xyXG4gICAgc2V0VGltZW91dCgoKT0+e1xyXG4gICAgICBpZighd2FpdCkge1xyXG4gICAgICAgIHRlcm0uZWNobyhgW1tiOyR7JyNBQUFBQUEnfTtdJHsnVjovLz4gRWR1Y2F0aW9uJ31dYCk7XHJcbiAgICAgICAgcHJvY2Vzc0NvbW1hbmQoXCJFZHVjYXRpb25cIiwgdGVybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9LCA1MDApO1xyXG5cclxuICAgIC8vIHRlcm0uZXhlYyhcImVkdWNhdGlvblwiLCB0cnVlKVxyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH0pO1xyXG4gICQoJ2EuaGVscDInKS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICBjb3VudExldHRlcjIgPSAxMDAwO1xyXG4gICAgY291bnRMZXR0ZXIgPSAxMDAwO1xyXG4gICAgY291bnRMb29wcyA9IDEwMDA7XHJcbiAgICB0ZXJtLmNsZWFyKCk7XHJcbiAgICB0ZXJtLmVjaG8oaW50cm8pO1xyXG4gICAgc2V0QWxsTGluZXMoKTtcclxuICAgIHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgaWYoIXdhaXQpIHtcclxuICAgICAgICB0ZXJtLmVjaG8oYFtbYjskeycjQUFBQUFBJ307XSR7J1Y6Ly8+IFdvcmsnfV1gKTtcclxuICAgICAgICAvLyB3YWl0ID0gZmFsc2U7XHJcbiAgICAgICAgcHJvY2Vzc0NvbW1hbmQoXCJXb3JrXCIsIHRlcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSwgNTAwKTtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICB9KTtcclxuICAkKCdhLmhlbHAzJykub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gICAgY291bnRMZXR0ZXIyID0gMTAwMDtcclxuICAgIGNvdW50TGV0dGVyID0gMTAwMDtcclxuICAgIGNvdW50TG9vcHMgPSAxMDAwO1xyXG4gICAgdGVybS5jbGVhcigpO1xyXG4gICAgdGVybS5lY2hvKGludHJvKTtcclxuICAgIHNldEFsbExpbmVzKCk7XHJcbiAgICAvLyB0ZXJtLnJlc3VtZSgpO1xyXG4gICAgc2V0VGltZW91dCgoKT0+e1xyXG4gICAgICBpZighd2FpdCkge1xyXG4gICAgICAgIHRlcm0uZWNobyhgW1tiOyR7JyNBQUFBQUEnfTtdJHsnVjovLz4gTGFuZ3VhZ2VzJ31dYCk7XHJcbiAgICAgICAgLy8gd2FpdCA9IGZhbHNlO1xyXG4gICAgICAgIHByb2Nlc3NDb21tYW5kKFwiTGFuZ3VhZ2VzXCIsIHRlcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSwgNTAwKTtcclxuXHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfSk7XHJcbiAgJCgnYS5oZWxwNCcpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuICAgIGNvdW50TGV0dGVyMiA9IDEwMDA7XHJcbiAgICBjb3VudExldHRlciA9IDEwMDA7XHJcbiAgICBjb3VudExvb3BzID0gMTAwMDtcclxuICAgIHRlcm0uY2xlYXIoKTtcclxuICAgIHRlcm0uZWNobyhpbnRybyk7XHJcbiAgICBzZXRBbGxMaW5lcygpO1xyXG4gICAgLy8gdGVybS5yZXN1bWUoKTtcclxuICAgIHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgaWYoIXdhaXQpIHtcclxuICAgICAgICB0ZXJtLmVjaG8oYFtbYjskeycjQUFBQUFBJ307XSR7J1Y6Ly8+IEdpdGh1Yid9XWApO1xyXG5cclxuICAgICAgICAvLyB3YWl0ID0gZmFsc2U7XHJcbiAgICAgICAgcHJvY2Vzc0NvbW1hbmQoXCJHaXRodWJcIiwgdGVybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9LCA1MDApO1xyXG5cclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICB9KTtcclxuICAkKCdhLmhlbHA1Jykub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gICAgY291bnRMZXR0ZXIyID0gMTAwMDtcclxuICAgIGNvdW50TGV0dGVyID0gMTAwMDtcclxuICAgIGNvdW50TG9vcHMgPSAxMDAwO1xyXG4gICAgdGVybS5jbGVhcigpO1xyXG4gICAgdGVybS5lY2hvKGludHJvKTtcclxuICAgIHNldEFsbExpbmVzKCk7XHJcbiAgICAvLyB0ZXJtLnJlc3VtZSgpO1xyXG4gICAgc2V0VGltZW91dCgoKT0+e1xyXG4gICAgICBpZighd2FpdCkge1xyXG4gICAgICAgIHRlcm0uZWNobyhgW1tiOyR7JyNBQUFBQUEnfTtdJHsnVjovLz4gTGlua2VkSW4nfV1gKTtcclxuICAgICAgICAvLyB3YWl0ID0gZmFsc2U7XHJcbiAgICAgICAgcHJvY2Vzc0NvbW1hbmQoXCJMaW5rZWRpblwiLCB0ZXJtKTtcclxuICAgICAgfVxyXG5cclxuICAgIH0sIDUwMCk7XHJcblxyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH0pO1xyXG4gICQoJ2EuaGVscDYnKS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XHJcbiAgICBjb3VudExldHRlcjIgPSAxMDAwO1xyXG4gICAgY291bnRMZXR0ZXIgPSAxMDAwO1xyXG4gICAgY291bnRMb29wcyA9IDEwMDA7XHJcbiAgICB0ZXJtLmNsZWFyKCk7XHJcbiAgICB0ZXJtLmVjaG8oaW50cm8pO1xyXG4gICAgc2V0QWxsTGluZXMoKTtcclxuICAgIHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgaWYoIXdhaXQpIHtcclxuICAgICAgICB0ZXJtLmVjaG8oYFtbYjskeycjQUFBQUFBJ307XSR7J1Y6Ly8+IFByb2plY3RzJ31dYCk7XHJcbiAgICAgICAgLy8gd2FpdCA9IGZhbHNlO1xyXG4gICAgICAgIHByb2Nlc3NDb21tYW5kKFwiUHJvamVjdHNcIiwgdGVybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9LCA1MDApO1xyXG5cclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICB9KTtcclxuICAkKCdhLmhlbHA3Jykub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG4gICAgY291bnRMZXR0ZXIyID0gMTAwMDtcclxuICAgIGNvdW50TGV0dGVyID0gMTAwMDtcclxuICAgIGNvdW50TG9vcHMgPSAxMDAwO1xyXG4gICAgdGVybS5jbGVhcigpO1xyXG4gICAgdGVybS5lY2hvKGludHJvKTtcclxuICAgIHNldEFsbExpbmVzKCk7XHJcbiAgICBzZXRUaW1lb3V0KCgpPT57XHJcbiAgICAgIGlmKCF3YWl0KSB7XHJcbiAgICAgICAgdGVybS5lY2hvKGBbW2I7JHsnI0FBQUFBQSd9O10keydWOi8vPiBBYm91dCd9XWApO1xyXG4gICAgICAgIC8vIHdhaXQgPSBmYWxzZTtcclxuICAgICAgICBwcm9jZXNzQ29tbWFuZChcIkFib3V0XCIsIHRlcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSw1MDApO1xyXG5cclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICB9KTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBzZXRBbGxMaW5lcygpe1xyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBob2xkSGlzdG9yeS5sZW5ndGg7IGkgKyspe1xyXG4gICAgaWYoIWhvbGRIaXN0b3J5W2ldLmhhc093blByb3BlcnR5KCdtZXNzMicpKXtcclxuICAgICAgdGVybS5lY2hvKGBbW2I7JHtob2xkSGlzdG9yeVtpXS5jb2xvcn07XSR7aG9sZEhpc3RvcnlbaV0ubWVzc31dYCk7XHJcbiAgICB9ZWxzZSBpZihob2xkSGlzdG9yeVtpXS5oYXNPd25Qcm9wZXJ0eSgnbWVzczInKSl7XHJcbiAgICAgIHRlcm0uZWNobyhgW1tiOyR7aG9sZEhpc3RvcnlbaV0uY29sb3J9O10ke2hvbGRIaXN0b3J5W2ldLm1lc3N9XWAgKyBgW1tiOyR7aG9sZEhpc3RvcnlbaV0uY29sb3IyfTtdJHtob2xkSGlzdG9yeVtpXS5tZXNzMn1dYCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRlcm0ucmVzdW1lKCk7XHJcbn1cclxuZnVuY3Rpb24gc2V0X3NpemUoKSB7XHJcbiAgLy8gZm9yIHdpbmRvdyBoZWlnaHQgb2YgMTcwIGl0IHNob3VsZCBiZSAyc1xyXG4gIHZhciBoZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KCk7XHJcbiAgdmFyIHdpZHRoID0gJCh3aW5kb3cpLndpZHRoKCk7XHJcbiAgdmFyIHRpbWUgPSAoaGVpZ2h0ICogMikgLyAxNzA7XHJcbiAgc2NhbmxpbmVzWzBdLnN0eWxlLnNldFByb3BlcnR5KFwiLS10aW1lXCIsIHRpbWUpO1xyXG4gIHR2WzBdLnN0eWxlLnNldFByb3BlcnR5KFwiLS13aWR0aFwiLCB3aWR0aCk7XHJcbiAgdHZbMF0uc3R5bGUuc2V0UHJvcGVydHkoXCItLWhlaWdodFwiLCBoZWlnaHQpO1xyXG59XHJcbmxldCBidWlsZFdvcmQgPSBcIlwiO1xyXG5sZXQgYnVpbGRXb3JkMiA9IFwiXCI7XHJcbmxldCBjb3VudExldHRlciA9IDA7XHJcbmxldCBjb3VudExldHRlcjIgPSAwO1xyXG5cclxuZnVuY3Rpb24gcHJpbnRMaW5lKHdvcmRzKXtcclxuICBpZihjb3VudExldHRlciA8IDk1MCAmJiBjb3VudExldHRlcjIgPCA5NTApIHtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBpZiAoIXdvcmRzLmhhc093blByb3BlcnR5KCdtZXNzMicpICYmIGNvdW50TGV0dGVyIDwgd29yZHMubWVzcy5sZW5ndGgpIHtcclxuICAgICAgICBidWlsZFdvcmQgKz0gd29yZHMubWVzc1tjb3VudExldHRlcl07XHJcbiAgICAgICAgY291bnRMZXR0ZXIrKztcclxuICAgICAgICBpZiAoY291bnRMZXR0ZXIgPD0gMSkge1xyXG4gICAgICAgICAgdGVybS5lY2hvKGBbW2I7JHt3b3Jkcy5jb2xvcn07XSR7YnVpbGRXb3JkfV1gKTtcclxuICAgICAgICAgIHByaW50TGluZSh3b3Jkcyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb3VudExldHRlciA+PSAyKSB7XHJcbiAgICAgICAgICB0ZXJtLnVwZGF0ZSh0ZXJtLmxhc3RfaW5kZXgoKSwgYFtbYjske3dvcmRzLmNvbG9yfTtdJHtidWlsZFdvcmR9XWApO1xyXG4gICAgICAgICAgaWYgKGJ1aWxkV29yZCA9PT0gd29yZHMubWVzcyAmJiAhcnVudGltZSkge1xyXG4gICAgICAgICAgICB0ZXJtLnJlc3VtZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcHJpbnRMaW5lKHdvcmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAod29yZHMuaGFzT3duUHJvcGVydHkoJ21lc3MyJykgJiYgY291bnRMZXR0ZXIgPCB3b3Jkcy5tZXNzMi5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgaWYgKGNvdW50TGV0dGVyIDw9IDApIHtcclxuICAgICAgICAgIGJ1aWxkV29yZCArPSB3b3Jkcy5tZXNzW2NvdW50TGV0dGVyXTtcclxuICAgICAgICAgIGNvdW50TGV0dGVyKys7XHJcbiAgICAgICAgICB0ZXJtLmVjaG8oYFtbYjske3dvcmRzLmNvbG9yfTtdJHtidWlsZFdvcmR9XWApO1xyXG4gICAgICAgICAgcHJpbnRMaW5lKHdvcmRzKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNvdW50TGV0dGVyID49IDEgJiYgY291bnRMZXR0ZXIgPCB3b3Jkcy5tZXNzLmxlbmd0aCkge1xyXG4gICAgICAgICAgYnVpbGRXb3JkICs9IHdvcmRzLm1lc3NbY291bnRMZXR0ZXJdO1xyXG4gICAgICAgICAgY291bnRMZXR0ZXIrKztcclxuICAgICAgICAgIHRlcm0udXBkYXRlKHRlcm0ubGFzdF9pbmRleCgpLCBgW1tiOyR7d29yZHMuY29sb3J9O10ke2J1aWxkV29yZH1dYCk7XHJcbiAgICAgICAgICBwcmludExpbmUod29yZHMpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY291bnRMZXR0ZXIgPj0gd29yZHMubWVzcy5sZW5ndGggJiYgY291bnRMZXR0ZXIyIDwgd29yZHMubWVzczIubGVuZ3RoKSB7XHJcbiAgICAgICAgICBidWlsZFdvcmQyICs9IHdvcmRzLm1lc3MyW2NvdW50TGV0dGVyMl07XHJcbiAgICAgICAgICBjb3VudExldHRlcjIrKztcclxuICAgICAgICAgIHRlcm0udXBkYXRlKHRlcm0ubGFzdF9pbmRleCgpLCBgW1tiOyR7d29yZHMuY29sb3J9O10ke3dvcmRzLm1lc3N9XWAgKyBgW1tiOyR7d29yZHMuY29sb3IyfTtdJHtidWlsZFdvcmQyfV1gKTtcclxuICAgICAgICAgIGlmIChidWlsZFdvcmQyID09PSB3b3Jkcy5tZXNzMiAmJiAhcnVudGltZSkge1xyXG4gICAgICAgICAgICB0ZXJtLnJlc3VtZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcHJpbnRMaW5lKHdvcmRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9XHJcbiAgICB9LCAxNSk7XHJcbiAgfVxyXG59XHJcbmxldCB5ZWxsb3cgPSBcIiNFRUZDMTJcIjtcclxubGV0IHJlZCA9IFwiI2NlMmYyZlwiO1xyXG5sZXQgd2hpdGUgPSBcIiNmZmZcIjtcclxuXHJcbmxldCBydW50aW1lID0gdHJ1ZTtcclxubGV0IHRpbWUxID0gNTAwO1xyXG5sZXQgY291bnRMb29wcyA9IDA7XHJcbmxldCB3YWl0VGltZSA9IDI2O1xyXG5sZXQgaG9sZEhpc3RvcnkgPSBbXTtcclxuZnVuY3Rpb24gcmVzZXRQcmludCgpe1xyXG4gIGJ1aWxkV29yZCA9IFwiXCI7XHJcbiAgYnVpbGRXb3JkMiA9IFwiXCI7XHJcbiAgY291bnRMZXR0ZXIgPSAwO1xyXG4gIGNvdW50TGV0dGVyMiA9IDA7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRDb3VudHMoKXtcclxuICBjb3VudExvb3BzID0gMDtcclxuICBydW50aW1lID0gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gdGVzdFRpbWUoYWxsSW50cm8pe1xyXG4gIGlmKGNvdW50TG9vcHMgPj0gYWxsSW50cm8ubGVuZ3RoKXtcclxuICAgIHJ1bnRpbWUgPSBmYWxzZTtcclxuICAgIHdhaXQgPSBmYWxzZTtcclxuICB9XHJcbiAgaWYoY291bnRMb29wcyA9PT0gMCl7XHJcbiAgICBob2xkSGlzdG9yeSA9IGhvbGRIaXN0b3J5LmNvbmNhdChhbGxJbnRybyk7XHJcbiAgICB0aW1lMSA9IDUwMDtcclxuICB9ZWxzZSBpZihjb3VudExvb3BzID4gOTUwKXtcclxuICAgIHJ1bnRpbWU9ZmFsc2U7XHJcbiAgfWVsc2UgaWYgKCFhbGxJbnRyb1tjb3VudExvb3BzIC0gMV0uaGFzT3duUHJvcGVydHkoJ21lc3MyJykgJiYgYWxsSW50cm9bY291bnRMb29wcyAtIDFdLm1lc3MgIT09IFwiIFwiKSB7XHJcbiAgICAgIHRpbWUxID0gYWxsSW50cm9bY291bnRMb29wcyAtIDFdLm1lc3MubGVuZ3RoICogMzA7XHJcbiAgICB9ZWxzZSBpZiAoYWxsSW50cm9bY291bnRMb29wcyAtIDFdLm1lc3MgPT09IFwiIFwiKSB7XHJcbiAgICAgIHRpbWUxID0gNTA7XHJcbiAgICB9ZWxzZSBpZiAoYWxsSW50cm9bY291bnRMb29wcyAtIDFdLmhhc093blByb3BlcnR5KCdtZXNzMicpKSB7XHJcbiAgICAgIHRpbWUxID0gKGFsbEludHJvW2NvdW50TG9vcHMgLSAxXS5tZXNzMi5sZW5ndGggKyBhbGxJbnRyb1tjb3VudExvb3BzIC0gMV0ubWVzcy5sZW5ndGgpICogd2FpdFRpbWU7XHJcbiAgICB9XHJcbiAgaWYocnVudGltZSAmJiBjb3VudExvb3BzIDwgOTUwKXtcclxuICAgIHNldFRpbWVvdXQoKCk9PntcclxuXHJcbiAgICAgICAgcmVzZXRQcmludCgpO1xyXG4gICAgICBpZihjb3VudExvb3BzIDwgOTUwKSB7XHJcbiAgICAgICAgcHJpbnRMaW5lKGFsbEludHJvW2NvdW50TG9vcHNdKTtcclxuICAgICAgICBjb3VudExvb3BzKys7XHJcbiAgICAgIH1cclxuICAgICAgICB0ZXN0VGltZShhbGxJbnRybyk7XHJcblxyXG4gICAgfSwgdGltZTEpO1xyXG5cclxuICB9XHJcbn1cclxubGV0IGFsbEludHJvID0gW1xyXG4gIHtcclxuICAgIG1lc3M6IFwiSGVsbG8gQW5kIFdlbGNvbWUgVG8gTXkgUG9ydGZvbGlvXCIsXHJcbiAgICBjb2xvcjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiRm9yIGEgbGlzdCBvZiBjb21tYW5kcyB0eXBlICcnaGVscCcnXCIsXHJcbiAgICBjb2xvcjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiIFwiLFxyXG4gICAgY29sb3I6IHdoaXRlXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIkhlcmUgaXMgYSBnZW5lcmFsIG92ZXJ2aWV3IG9mIG15c2VsZlwiLFxyXG4gICAgY29sb3I6IHdoaXRlLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCJOYW1lOiBcIixcclxuICAgIGNvbG9yOiB5ZWxsb3csXHJcbiAgICBtZXNzMjogXCJNaWNoYWVsIExhcnJhZ3VldGFcIixcclxuICAgIGNvbG9yMjogd2hpdGVcclxuXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIkxvY2F0aW9uOiBcIixcclxuICAgIGNvbG9yOiB5ZWxsb3csXHJcbiAgICBtZXNzMjogXCJQb3J0bGFuZCwgT3JlZ29uXCIsXHJcbiAgICBjb2xvcjI6IHdoaXRlXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIldpbGxpbmcgdG8gcmVsb2NhdGU6IFwiLFxyXG4gICAgY29sb3I6IHllbGxvdyxcclxuICAgIG1lc3MyOiBcIlllcywgd2l0aGluIHRoZSBzdGF0ZSBvZiBPcmVnb24gfHwgV2lsbGluZyB0byB3b3JrIHJlbW90ZWx5XCIsXHJcbiAgICBjb2xvcjI6IHdoaXRlXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIlBvc2l0aW9uOiBcIixcclxuICAgIGNvbG9yOiB5ZWxsb3csXHJcbiAgICBtZXNzMjogXCJKdW5pb3IgV2ViIERldmVsb3BlclwiLFxyXG4gICAgY29sb3IyOiB3aGl0ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCJTa2lsbHM6IFwiLFxyXG4gICAgY29sb3I6IHllbGxvdyxcclxuICAgIG1lc3MyOiBcIkphdmFTY3JpcHQsIEMjLCBDKyssIEhUTUwsIENTUywgQVNQLk5FVCwgUmVhY3QsIEFuZ3VsYXIsIEpxdWVyeSwgVW5pdHksIEdJVCBDTEksIFJlYWN0LVRIUkVFLUZpYmVyLCBteVNxbCwgTm9kZS5qcyBhbmQgbW9yZVwiLFxyXG4gICAgY29sb3IyOiB3aGl0ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCJDT05UQUNUIElORk9cIixcclxuICAgIGNvbG9yOiByZWRcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiUGhvbmU6IFwiLFxyXG4gICAgY29sb3I6IHllbGxvdyxcclxuICAgIG1lc3MyOiBcIig5MjUpNDUxLTU1MTVcIixcclxuICAgIGNvbG9yMjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6ICBcIkVtYWlsOiBcIixcclxuICAgIGNvbG9yOiB5ZWxsb3csXHJcbiAgICBtZXNzMjogXCJNakxhcnJhZ3VldGFAZ21haWwuY29tXCIsXHJcbiAgICBjb2xvcjI6IHdoaXRlXHJcbiAgfVxyXG5dO1xyXG5sZXQgaGVscENvbW1hbmQgPSBbXHJcbiAge1xyXG4gICAgbWVzczogXCJBbGwgQ29tbWFuZHM6IFwiLFxyXG4gICAgY29sb3I6IHJlZFxyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCJFZHVjYXRpb246IFwiLFxyXG4gICAgY29sb3I6IHllbGxvdyxcclxuICAgIG1lc3MyOiBcIlNob3cgYWxsIGVkdWNhdGlvbiBpbmZvcm1hdGlvblwiLFxyXG4gICAgY29sb3IyOiB3aGl0ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCJXb3JrOiBcIixcclxuICAgIGNvbG9yOiB5ZWxsb3csXHJcbiAgICBtZXNzMjogXCJTaG93IGFsbCB3b3JrIGV4cGVyaWVuY2VcIixcclxuICAgIGNvbG9yMjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiTGFuZ3VhZ2VzOiBcIixcclxuICAgIGNvbG9yOiB5ZWxsb3csXHJcbiAgICBtZXNzMjogXCJTaG93IGFsbCBvZiBteSBrbm93biBwcm9ncmFtbWluZyBsYW5ndWFnZXNcIixcclxuICAgIGNvbG9yMjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiR2l0aHViOiBcIixcclxuICAgIGNvbG9yOiB5ZWxsb3csXHJcbiAgICBtZXNzMjogXCJMaW5rIHRvIG15IGdpdGh1YiBwcm9maWxlXCIsXHJcbiAgICBjb2xvcjI6IHdoaXRlXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIkxpbmtlZEluOiBcIixcclxuICAgIGNvbG9yOiB5ZWxsb3csXHJcbiAgICBtZXNzMjogXCJMaW5rIHRvIG15IExpbmtlZEluIHByb2ZpbGVcIixcclxuICAgIGNvbG9yMjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiUHJvamVjdHM6IFwiLFxyXG4gICAgY29sb3I6IHllbGxvdyxcclxuICAgIG1lc3MyOiBcIkxpbmtzIHRvIG15IDMgZmF2b3JpdGUgcHJvamVjdHMgd2l0aCBhZGRlZCBkZXNjcmlwdGlvbnNcIixcclxuICAgIGNvbG9yMjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiQWJvdXQ6IFwiLFxyXG4gICAgY29sb3I6IHllbGxvdyxcclxuICAgIG1lc3MyOiBcIkFib3V0IG1lXCIsXHJcbiAgICBjb2xvcjI6IHdoaXRlXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIlJlc2V0OiBcIixcclxuICAgIGNvbG9yOiB5ZWxsb3csXHJcbiAgICBtZXNzMjogXCJSZXNldHMgdGVybWluYWwgcGFnZVwiLFxyXG4gICAgY29sb3IyOiB3aGl0ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCJFeGl0OiBcIixcclxuICAgIGNvbG9yOiByZWQsXHJcbiAgICBtZXNzMjogXCJUdXJucyB0ZXJtaW5hbCBvZmZcIixcclxuICAgIGNvbG9yMjogd2hpdGVcclxuICB9XHJcbl07XHJcbmxldCBlZHVjQ29tbWFuZCA9IFtcclxuICB7XHJcbiAgICBtZXNzOiBcIkVkdWNhdGlvbjogXCIsXHJcbiAgICBjb2xvcjogcmVkXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIkRpYWJsbyBWYWxsZXkgQ29sbGVnZSwgQ29uY29yZCBDQSAtIEMrK1wiLFxyXG4gICAgY29sb3I6IHllbGxvd1xyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCJTdGFydGVkOiBcIixcclxuICAgIGNvbG9yOiB5ZWxsb3csXHJcbiAgICBtZXNzMjogXCJTZXB0ZW1iZXIsIDIwMTRcIixcclxuICAgIGNvbG9yMjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiRmluaXNoZWQ6IFwiLFxyXG4gICAgY29sb3I6IHllbGxvdyxcclxuICAgIG1lc3MyOiBcIkp1bmUsIDIwMTggXCIsXHJcbiAgICBjb2xvcjI6IHdoaXRlXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIlN0dWRpZWQ6IFwiLFxyXG4gICAgY29sb3I6IHllbGxvdyxcclxuICAgIG1lc3MyOiBcIkNvbXB1dGVyIFNjaWVuY2VcIixcclxuICAgIGNvbG9yMjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiIFwiLFxyXG4gICAgY29sb3I6IHdoaXRlXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIkVwaWNvZHVzLCBQb3J0bGFuZCBPUiAtIEMjL1JlYWN0IFRyYWNrXCIsXHJcbiAgICBjb2xvcjogeWVsbG93XHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIlN0YXJ0ZWQ6IFwiLFxyXG4gICAgY29sb3I6IHllbGxvdyxcclxuICAgIG1lc3MyOiBcIk1hcmNoIDIwMTlcIixcclxuICAgIGNvbG9yMjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiRmluc2loZWQ6IFwiLFxyXG4gICAgY29sb3I6IHllbGxvdyxcclxuICAgIG1lc3MyOiBcIlNlcHRlbWJlciAyMDE5XCIsXHJcbiAgICBjb2xvcjI6IHdoaXRlXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIlN0dWRpZWQ6IFwiLFxyXG4gICAgY29sb3I6IHllbGxvdyxcclxuICAgIG1lc3MyOiBcIkMjLCAuTkVULCBSZWFjdCwgSnF1ZXJ5LCBIVE1MLCBDU1MsIEphdmFTY3JpcHQsIEFuZ3VsYXIgQVNQLk5FVCwgR0lUIENMSVwiLFxyXG4gICAgY29sb3IyOiB3aGl0ZVxyXG5cclxuICB9XHJcbl07XHJcbmxldCB1bmtub3duQ29tbWFuZCA9IFtcclxuICB7XHJcbiAgICBtZXNzOiBcIlVOS09XTiBDT01NQU5EXCIsXHJcbiAgICBjb2xvcjogcmVkXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIkZvciBhIGxpc3Qgb2YgY29tbWFuZHMgdHlwZSAnJ2hlbHAnJ1wiLFxyXG4gICAgY29sb3I6IHdoaXRlXHJcbiAgfVxyXG5dO1xyXG5sZXQgd29ya0NvbW1hbmQgPSBbXHJcbiAge1xyXG4gICAgbWVzczogXCJXb3JrIEhpc3Rvcnk6IFwiLFxyXG4gICAgY29sb3I6IHJlZFxyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCJJbnZpc2libGUgVGhyZWFkLCBQb3J0bGFuZCBPUlwiLFxyXG4gICAgY29sb3I6IHllbGxvd1xyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCJUaXRsZTogXCIsXHJcbiAgICBjb2xvcjogeWVsbG93LFxyXG4gICAgbWVzczI6IFwiSnVuaW9yIERldmVsb3BlclwiLFxyXG4gICAgY29sb3IyOiB3aGl0ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCJTdGFydGVkOiBcIixcclxuICAgIGNvbG9yOiB5ZWxsb3csXHJcbiAgICBtZXNzMjogXCJBdWd1c3QgMjAxOVwiLFxyXG4gICAgY29sb3IyOiB3aGl0ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCJGaW5pc2hlZDogXCIsXHJcbiAgICBjb2xvcjogeWVsbG93LFxyXG4gICAgbWVzczI6IFwiT2N0b2JlciAyMDE5XCIsXHJcbiAgICBjb2xvcjI6IHdoaXRlXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIkRldGFpbHNcIixcclxuICAgIGNvbG9yOiB5ZWxsb3dcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiICAtUmUtQnVpbHQgd2Vic2l0ZSB1c2luZyBSZWFjdCwgVEhSRUUuanMsIGFuZCBSZWFjdC1USFJFRS1GaWJlclwiLFxyXG4gICAgY29sb3I6IHdoaXRlXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIiAgLUJ1aWx0IGFuIGF1Z21lbnRlZCByZWFsaXR5IHBhdGhmaW5kaW5nIGFuZHJvaWQgYXBwbGljYXRpb24gdXNpbmcgVW5pdHkgYW5kIEMjXCIsXHJcbiAgICBjb2xvcjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiICAtTWFuYWdlZCBQcm9qZWN0IFdvcmtmbG93IGFuZCB0YXNrcyB1c2luZyBUcmVsbG9cIixcclxuICAgIGNvbG9yOiB3aGl0ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCIgXCIsXHJcbiAgICBjb2xvcjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiVGhlIENyZWVrIFlvdXRoIENlbnRlciwgV2FsbnV0IENyZWVrIENBXCIsXHJcbiAgICBjb2xvcjogeWVsbG93XHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIlRpdGxlOiBcIixcclxuICAgIGNvbG9yOiB5ZWxsb3csXHJcbiAgICBtZXNzMjogXCJMZWFkIFRlYWNoZXJzIEFpZGVcIixcclxuICAgIGNvbG9yMjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiU3RhcnRlZDogXCIsXHJcbiAgICBjb2xvcjogeWVsbG93LFxyXG4gICAgbWVzczI6IFwiSmFudWFyeSAyMDE0XCIsXHJcbiAgICBjb2xvcjI6IHdoaXRlXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIkVuZGVkOiBcIixcclxuICAgIGNvbG9yOiB5ZWxsb3csXHJcbiAgICBtZXNzMjogXCJBdWd1c3QgMjAxOFwiLFxyXG4gICAgY29sb3IyOiB3aGl0ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCJEZXRhaWxzXCIsXHJcbiAgICBjb2xvcjogeWVsbG93XHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIiAgLUNyZWF0ZWQsIHBsYW5uZWQgYW5kIGV4ZWN1dGVkIGRpZmZlcmVudCBsZWFybmluZyBhY3Rpdml0aWVzXCIsXHJcbiAgICBjb2xvcjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiICAtTWFuYWdlZCBhbmQgbGVhZCBncm91cHMgb2YgMzArIGNoaWxkcmVuIGdyYWRlIDZ0aC04dGhcIixcclxuICAgIGNvbG9yOiB3aGl0ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCIgIC1DcmVhdGVkIGFuZCByYW4gdGhlIHRlY2ggY2x1YiB3aGVyZSBzdHVkZW50cyBsZWFybmVkIGhvdyB0byBidWlsZCBhbmQgcHJvZ3JhbcKgQXJkdWlubyBiYXNlZCByb2JvdGljc1wiLFxyXG4gICAgY29sb3I6IHdoaXRlXHJcbiAgfVxyXG5dO1xyXG5sZXQgZ2l0Q29tbWFuZCA9IFtcclxuICB7XHJcbiAgICBtZXNzOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90b29mcGFzdGVcIixcclxuICAgIGNvbG9yOiByZWRcclxuICB9XHJcbl07XHJcbmxldCBsaW5rQ29tbWFuZCA9IFtcclxuICB7XHJcbiAgICBtZXNzOiBcImh0dHBzOi8vd3d3LmxpbmtlZGluLmNvbS9pbi9tbGFycmFndWV0YVwiLFxyXG4gICAgY29sb3I6IHJlZFxyXG4gIH1cclxuXTtcclxubGV0IGxhbmdDb21tYW5kID0gW1xyXG4gIHtcclxuICAgIG1lc3M6IFwiQysrLCBOb2RlLmpzLCBIVE1MLCBKYXZhc2NyaXB0LCBSZWFjdCwgQVNQLk5FVCwgQ1NTLCBqUXVlcnksIEdJVCBDTEksIEFuZ3VsYXJKUywgRmlyZWJhc2UsIFdlYnBhY2ssIE5QTSwgQyMsIFR5cGVTY3JpcHQsIG15U3FsLCBNb25nb0RCXCIsXHJcbiAgICBjb2xvcjogd2hpdGVcclxuICB9XHJcbl07XHJcbmxldCBhYm91dENvbW1hbmQgPSBbXHJcbiAge1xyXG4gICAgbWVzczogXCJCb3JuIGFuZCByYWlzZWQgaW4gQ29uY29yZCwgQ2FsaWZvcm5pYS4gT3V0IG9mIGhpZ2ggc2Nob29sLCBJIGF0dGVuZGVkIHRoZSBVbml2ZXJzaXR5IG9mIE5ldmFkYSBSZW5vIHdoZXJlIEkgc3R1ZGllZCBidXNpbmVzcyBtYW5hZ2VtZW50LiBBZnRlciBteSBzZWNvbmQgeWVhciB0aGVyZSBJIGRlY2lkZWQgdGhhdCBpdCB3YXMgbm90IHRoZSBkaXJlY3Rpb24gSSB3YW50ZWQgdG8gZ28gd2l0aCBteSBjYXJlZXIuIFRvIHNhdmUgc29tZSBtb25leSBJIG1vdmVkIGJhY2sgaG9tZSBhbmQgYXR0ZW5kZWQgRGlhYmxvIFZhbGxleSBDb2xsZWdlIHdoZXJlIEkgZGlzY292ZXJlZCBteSBsb3ZlIGZvciBjb21wdXRlciBzY2llbmNlLiBJIHN0dWRpZWQgQ29tcHV0ZXIgU2NpZW5jZSB0aGVyZSBmb3IgNCB5ZWFycy4gQWZ0ZXIgYXR0ZW1wdGluZyB0byBhZmZvcmQgbGl2aW5nIGluIHRoZSBiYXkgYXJlYSBieSB3b3JraW5nIGFzIGEgdmFsZXQsIEkgbWFkZSB0aGUgZGVjaXNpb24gdG8gbW92ZSB1cCB0byBQb3J0bGFuZCBhbmQgYXR0ZW5kIEVwaWNvZHVzIHdoZXJlIEkgc3R1ZGllZCBhIHZhcmlldHkgb2YgZGlmZmVyZW50IHdlYiBkZXZlbG9wbWVudCBsYW5ndWFnZXMuIFwiLFxyXG4gICAgY29sb3I6IHdoaXRlXHJcbiAgfVxyXG5dO1xyXG5sZXQgcHJvakNvbW1hbmQgPSBbXHJcbiAge1xyXG4gICAgbWVzczogXCJJQk0gV2F0c29uIENvbm5lY3QgNDogXCIsXHJcbiAgICBjb2xvcjogeWVsbG93XHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90b29mcGFzdGUvUmVhY3RXYXRzb25BUElXb3JraW5nXCIsXHJcbiAgICBjb2xvcjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiRGV0YWlsc1wiLFxyXG4gICAgY29sb3I6IHllbGxvd1xyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCIgIC1Xcml0dGVuIHVzaW5nIFJlYWN0IGZvciB0aGUgZnJvbnQgZW5kIGFuZCBOb2RlLmpzIHRvIGFjY2VzcyB0aGUgd2F0c29uIEFQSVwiLFxyXG4gICAgY29sb3I6IHdoaXRlXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIiAgLVVzaW5nIElCTSBXYXRzb24gaXQgYW5hbHl6ZXMgYSB1c2VyJ3MgdHdlZXRzIGFuZCBnZW5lcmF0ZXMgYSBwZXJzb25hbGl0eSBwcm9maWxlIGZvciB0aGVtLiBUaGUgQ29ubmVjdCA0IEFJIHRoZW4gdXNlcyB0aG9zZSBwZXJzb25hbGl0eSB0cmFpdHMgYWdhaW5zdCB0aGVtIGluIGEgZ2FtZSBvZiBDb25uZWN0IDRcIixcclxuICAgIGNvbG9yOiB3aGl0ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCIgXCIsXHJcbiAgICBjb2xvcjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiSW52aXNpYmxlLVRocmVhZC1XZWJzaXRlXCIsXHJcbiAgICBjb2xvcjogeWVsbG93XHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90b29mcGFzdGUvSW52aXNpYmxlLVRocmVhZC1XZWJzaXRlXCIsXHJcbiAgICBjb2xvcjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiRGV0YWlsc1wiLFxyXG4gICAgY29sb3I6IHllbGxvd1xyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCIgIC1Xcml0dGVuIHVzaW5nIFJlYWN0LVRIUkVFLUZpYmVyLiBBIFJlYWN0IHdyYXBwZXIgZm9yIFRIUkVFLmpzXCIsXHJcbiAgICBjb2xvcjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiIFwiLFxyXG4gICAgY29sb3I6IHdoaXRlXHJcbiAgfSxcclxuICB7XHJcbiAgICBtZXNzOiBcIk11bHRpUGxheWVyIFRldHJpc1wiLFxyXG4gICAgY29sb3I6IHllbGxvd1xyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCJodHRwczovL2dpdGh1Yi5jb20vdG9vZnBhc3RlL01QVGV0cmlzXCIsXHJcbiAgICBjb2xvcjogd2hpdGVcclxuICB9LFxyXG4gIHtcclxuICAgIG1lc3M6IFwiRGV0YWlsc1wiLFxyXG4gICAgY29sb3I6IHllbGxvd1xyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCIgIC1Xcml0dGVuIHVzaW5nIEphdmFzY3JpcHQsIE5vZGUuanMgd2l0aCBDU1MgYW5kIEhUTUxcIixcclxuICAgIGNvbG9yOiB3aGl0ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgbWVzczogXCIgIC1BIHNpbXBsZSBUZXRyaXMgZ2FtZSB0aGF0IGRyb3BzIGJsb2NrIHNoYXBlcyBkb3duIGFuZCBib2FyZCB3aGlsZSBhIHVzZXIgdHJpZXMgdG8gbW92ZSB0aGUgc2hhcGVzIGFyb3VuZCB0byBmaXQgdGhlIG90aGVyIHNoYXBlcyBvbi4gVGhlIHBsYXllciB0cnlpZXMgdG8gY29tcGxldGVseSBmaWxsIHdob2xlIHJvd3Mgb2YgYmxvY2tzIGluIG9yZGVyIHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlIGdhbWUgd2hpbGUgYXZvaWRpbmcgZmlsbGluZyB0aGUgZ2FtZSBib2FyZCBhbGwgdGhlIHdheSB0byB0aGUgdG9wLlwiLFxyXG4gICAgY29sb3I6IHdoaXRlXHJcbiAgfVxyXG5dO1xyXG5mdW5jdGlvbiBwcm9jZXNzQ29tbWFuZChjb21tYW5kLCB0ZXJtKSB7XHJcbiAgaWYoIXdhaXQpIHtcclxuICAgIGxldCBjbWQgPSBjb21tYW5kLnNwbGl0KFwiIFwiKTtcclxuICAgIGhvbGRIaXN0b3J5LnB1c2goe1xyXG4gICAgICBtZXNzOiBgVjovLz4gJHtjbWRbMF19YCxcclxuICAgICAgY29sb3I6ICcjI0FBQUFBQSdcclxuICAgIH0pO1xyXG4gICAgY21kWzBdID0gY21kWzBdLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBpZiAoY21kWzBdID09IFwiaGVscFwiKSB7XHJcbiAgICAgIHdhaXQgPSB0cnVlO1xyXG4gICAgICB0ZXJtLnBhdXNlKCk7XHJcbiAgICAgIHJlc2V0UHJpbnQoKTtcclxuICAgICAgcmVzZXRDb3VudHMoKTtcclxuICAgICAgdGVzdFRpbWUoaGVscENvbW1hbmQpO1xyXG4gICAgICAvLyByZXR1cm47XHJcbiAgICB9IGVsc2UgaWYgKGNtZFswXSA9PSBcImVkdWNhdGlvblwiKSB7XHJcbiAgICAgIHdhaXQgPSB0cnVlO1xyXG4gICAgICB0ZXJtLnBhdXNlKCk7XHJcbiAgICAgIHJlc2V0UHJpbnQoKTtcclxuICAgICAgcmVzZXRDb3VudHMoKTtcclxuICAgICAgdGVzdFRpbWUoZWR1Y0NvbW1hbmQpO1xyXG4gICAgfSBlbHNlIGlmIChjbWRbMF0gPT0gXCJ3b3JrXCIpIHtcclxuICAgICAgd2FpdCA9IHRydWU7XHJcbiAgICAgIHRlcm0ucGF1c2UoKTtcclxuICAgICAgcmVzZXRQcmludCgpO1xyXG4gICAgICByZXNldENvdW50cygpO1xyXG4gICAgICB0ZXN0VGltZSh3b3JrQ29tbWFuZCk7XHJcbiAgICB9IGVsc2UgaWYgKGNtZFswXSA9PSBcImdpdGh1YlwiKSB7XHJcbiAgICAgIHdhaXQgPSB0cnVlO1xyXG4gICAgICB0ZXJtLnBhdXNlKCk7XHJcbiAgICAgIHJlc2V0UHJpbnQoKTtcclxuICAgICAgcmVzZXRDb3VudHMoKTtcclxuICAgICAgdGVzdFRpbWUoZ2l0Q29tbWFuZCk7XHJcbiAgICB9IGVsc2UgaWYgKGNtZFswXSA9PSBcImxpbmtlZGluXCIpIHtcclxuICAgICAgdGVybS5wYXVzZSgpO1xyXG4gICAgICByZXNldFByaW50KCk7XHJcbiAgICAgIHJlc2V0Q291bnRzKCk7XHJcbiAgICAgIHRlc3RUaW1lKGxpbmtDb21tYW5kKTtcclxuICAgIH0gZWxzZSBpZiAoY21kWzBdID09IFwibGFuZ3VhZ2VzXCIpIHtcclxuICAgICAgd2FpdCA9IHRydWU7XHJcbiAgICAgIHRlcm0ucGF1c2UoKTtcclxuICAgICAgcmVzZXRQcmludCgpO1xyXG4gICAgICByZXNldENvdW50cygpO1xyXG4gICAgICB0ZXN0VGltZShsYW5nQ29tbWFuZCk7XHJcbiAgICB9IGVsc2UgaWYgKGNtZFswXSA9PSBcImFib3V0XCIpIHtcclxuICAgICAgdGVybS5wYXVzZSgpO1xyXG4gICAgICB3YWl0ID0gdHJ1ZTtcclxuICAgICAgcmVzZXRQcmludCgpO1xyXG4gICAgICByZXNldENvdW50cygpO1xyXG4gICAgICB0ZXN0VGltZShhYm91dENvbW1hbmQpO1xyXG4gICAgfSBlbHNlIGlmIChjbWRbMF0gPT0gXCJwcm9qZWN0c1wiKSB7XHJcbiAgICAgIHRlcm0ucGF1c2UoKTtcclxuICAgICAgd2FpdCA9IHRydWU7XHJcbiAgICAgIHJlc2V0UHJpbnQoKTtcclxuICAgICAgcmVzZXRDb3VudHMoKTtcclxuICAgICAgdGVzdFRpbWUocHJvakNvbW1hbmQpO1xyXG4gICAgfWVsc2UgaWYoY21kWzBdID09IFwicmVzZXRcIil7XHJcbiAgICAgIHRlcm0uY2xlYXIoKTtcclxuICAgICAgaG9sZEhpc3RvcnkgPSBbXTtcclxuICAgICAgdGVybS5lY2hvKGludHJvKTtcclxuICAgIH1lbHNlIHtcclxuICAgICAgdGVybS5wYXVzZSgpO1xyXG4gICAgICB3YWl0ID0gdHJ1ZTtcclxuICAgICAgcmVzZXRQcmludCgpO1xyXG4gICAgICByZXNldENvdW50cygpO1xyXG4gICAgICB0ZXN0VGltZSh1bmtub3duQ29tbWFuZCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js!./styles.css */ \"./node_modules/css-loader/dist/cjs.js!./src/styles.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzLmNzcz81MmY2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSxjQUFjLG1CQUFPLENBQUMsb0hBQXVEOztBQUU3RSw0Q0FBNEMsUUFBUzs7QUFFckQ7QUFDQTs7OztBQUlBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsbUdBQWdEOztBQUVyRTs7QUFFQSxHQUFHLEtBQVUsRUFBRSIsImZpbGUiOiIuL3NyYy9zdHlsZXMuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGVzLmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZXMuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZXMuY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/styles.css\n");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = jQuery;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIj9jZDBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6ImpxdWVyeS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0galF1ZXJ5OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///jquery\n");

/***/ })

/******/ });